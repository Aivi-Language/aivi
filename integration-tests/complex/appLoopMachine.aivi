@no_prelude
module integrationTests.complex.appLoopMachine

use aivi
use aivi.testing
use aivi.collections

// App-level state machine:
//   happy path:        Idle → Busy → Idle
//   fault-recovery:    Idle → Busy → Faulted → Idle
machine AppLoop =
  {
            -> Idle    : init {}
    Idle    -> Busy    : process { jobId: Int }
    Busy    -> Idle    : complete { value: Int }
    Busy    -> Faulted : fault { msg: Text }
    Faulted -> Idle    : recover {}
  }

Job = { jobId: Int, shouldFault: Bool }

reverseList = xs => List.foldl (acc x => [x, ...acc]) [] xs

@test "app loop drives state machine through transitions and fault recovery"
appLoopMachine = do Effect {
  { init, process, complete, fault, recover, currentState, can } = AppLoop

  // Machine starts in Idle; calling init explicitly must fail
  initAttempt <- attempt (init {})
  initAttempt match
    | Err e => assertEq (constructorName e) "InvalidTransition"
    | Ok _  => fail "init from Idle must be rejected"

    jobs = [
      { jobId: 1, shouldFault: False }
      { jobId: 2, shouldFault: True }
      { jobId: 3, shouldFault: False }
      { jobId: 4, shouldFault: True }
    ]

  // Process all jobs in a tail-recursive effect loop, collecting results
  results <- do Effect {
    loop state = { pending: jobs, outputs: [] } => {
      state.pending match
        | []             => pure (reverseList state.outputs)
        | [job, ...rest] => do Effect {
            // Verify Idle state and can-checks before each job
            assertEq (constructorName (currentState Unit)) "Idle"
            assertEq (can.process Unit) True
            assertEq (can.complete Unit) False
            assertEq (can.fault Unit) False
            assertEq (can.recover Unit) False

            // Transition Idle → Busy
            process { jobId: job.jobId }
            assertEq (constructorName (currentState Unit)) "Busy"
            assertEq (can.process Unit) False
            assertEq (can.complete Unit) True
            assertEq (can.fault Unit) True
            assertEq (can.recover Unit) False

            // Invalid transition while Busy: process again must fail
            doubleProcess <- attempt (process { jobId: 999 })
            doubleProcess match
              | Err e => assertEq (constructorName e) "InvalidTransition"
              | Ok _  => fail "process from Busy must be rejected"

            output <- if job.shouldFault
              then do Effect {
                // Fault path: Busy → Faulted → Idle
                fault { msg: "job failed" }
                assertEq (constructorName (currentState Unit)) "Faulted"
                assertEq (can.complete Unit) False
                assertEq (can.recover Unit) True

                // Invalid: complete from Faulted must fail
                badComplete <- attempt (complete { value: 0 })
                badComplete match
                  | Err e => assertEq (constructorName e) "InvalidTransition"
                  | Ok _  => fail "complete from Faulted must be rejected"

                // Recover: Faulted → Idle
                recover {}
                assertEq (constructorName (currentState Unit)) "Idle"
                pure (0- job.jobId)
              }
              else do Effect {
                // Happy path: Busy → Idle
                v = job.jobId * 100
                complete { value: v }
                assertEq (constructorName (currentState Unit)) "Idle"
                pure v
              }

            recurse { pending: rest, outputs: [output, ...state.outputs] }
          }
    }
  }

  // Verify collected outputs match expected values in job order
  assertEq results [100, -2, 300, -4]

  // Final state is Idle; invalid transitions must all fail
  assertEq (constructorName (currentState Unit)) "Idle"

  badComplete <- attempt (complete { value: 0 })
  badComplete match
    | Err e => assertEq (constructorName e) "InvalidTransition"
    | Ok _  => fail "complete from Idle must be rejected"

    badRecover <- attempt (recover {})
    badRecover match
      | Err e => assertEq (constructorName e) "InvalidTransition"
      | Ok _  => fail "recover from Idle must be rejected"

    pure Unit
}
