@no_prelude
module integrationTests.complex.PersistentSegmentTree

use aivi
use aivi.testing
use aivi.collections

listLength = xs => xs ?
  | []        => 0
  | [_, ...t] => 1 + listLength t

isEmpty = xs => xs ?
  | [] => True
  | _  => False

at = xs idx => xs ?
  | []        => None
  | [h, ...t] => if idx == 0 then Some h else at t (idx - 1)

minInt = a b => if a < b then a else b
maxInt = a b => if a < b then b else a

// Segment metadata for aggregate queries
SegmentMeta = { sum: Int, min: Int, max: Int }

// Persistent segment tree ADT
SegmentTree =
  Empty
| Node {
    start: Int
    end: Int
    sum: Int
    min: Int
    max: Int
    left: SegmentTree
    right: SegmentTree
}

// Extract metadata from a tree node
nodeMeta : SegmentTree -> Option SegmentMeta
nodeMeta =
  | Empty                  => None
  | Node { sum, min, max } => Some { sum, min, max }

// Combine two child metas
combineMeta = leftMeta rightMeta => (leftMeta, rightMeta) ?
  | (None, None)       => None
  | (Some lm, None)    => Some lm
  | (None, Some rm)    => Some rm
  | (Some lm, Some rm) => Some {
    sum: lm.sum + rm.sum
    min: minInt lm.min rm.min
    max: maxInt lm.max rm.max
  }

// Rebuild node from children
nodeFromChildren = start end left right => combineMeta (nodeMeta left) (nodeMeta right) ?
  | None   => Empty
  | Some m => Node {
    start: start
    end: end
    sum: m.sum
    min: m.min
    max: m.max
    left: left
    right: right
  }

// Build tree from a range of the array
buildRange = arr start end => {
  if start == end then
    at arr start ?
      | Some value => Node {
        start: start
        end: end
        sum: value
        min: value
        max: value
        left: Empty
        right: Empty
      }
      | None => Empty
  else {
        mid = (start + end) / 2
        left = buildRange arr start mid
        right = buildRange arr (mid + 1) end
        nodeFromChildren start end left right
  }
}

// Create tree from list
fromList : List Int -> SegmentTree
fromList = arr =>
  if isEmpty arr then Empty
  else buildRange arr 0 (listLength arr - 1)

// Query range [l..r] for metadata
  queryRange : SegmentTree -> Int -> Int -> Option SegmentMeta
  queryRange = tree l r => tree ?
    | Empty                                           => None
    | Node { start, end, sum, min, max, left, right } =>
      if r < start || end < l then None
      else if l <= start && end <= r then Some { sum, min, max }
      else combineMeta (queryRange left l r) (queryRange right l r)

// Point update at index (returns new tree, old is unchanged)
  updatePoint : SegmentTree -> Int -> Int -> SegmentTree
  updatePoint = tree idx value => tree ?
    | Empty                                             => Empty
    | Node { start, end } when idx < start || idx > end => tree
    | Node { start, end } when start == end             => Node {
      start: start
      end: end
      sum: value
      min: value
      max: value
      left: Empty
      right: Empty
    }
    | Node { start, end, left, right } => {
      newLeft = updatePoint left idx value
      newRight = updatePoint right idx value
      nodeFromChildren start end newLeft newRight
    }

    @test
persistency = effect {
  arr = [1, 2, 3, 4]
  tree = fromList arr

  queryAll = queryRange tree 0 3
  _ <- assert (queryAll == Some { sum: 10, min: 1, max: 4 })

  querySlice = queryRange tree 1 2
  _ <- assert (querySlice == Some { sum: 5, min: 2, max: 3 })

  updated = updatePoint tree 2 7
  _ <- assert (queryRange updated 2 2 == Some { sum: 7, min: 7, max: 7 })

  // Original tree stays intact (persistence)
  _ <- assert (queryRange tree 2 2 == Some { sum: 3, min: 3, max: 3 })

  _ <- assert (queryRange Empty 0 0 == None)
}
