@no_prelude
module integrationTests.complex.Dinic

use aivi
use aivi.testing
use aivi.collections
use aivi.graph (Graph, fromEdges, edgesFrom)

// Edge with capacity
Edge = { from: Int, to: Int, cap: Int }

// Residual network state
Residual = {
  graph: Graph
  capacities: Map Text Int
}

edgeKey = from to => "{from}:{to}"

getCap = from to caps => Map.getOrElse (edgeKey from to) 0 caps

setCap = from to value caps => Map.insert (edgeKey from to) value caps

append = xs ys => xs ?
  | []        => ys
  | [h, ...t] => [h, ...append t ys]

backwardEdges = edges => edges ?
  | []           => []
  | [e, ...rest] => [{ from: e.to, to: e.from, cap: 0 }, ...backwardEdges rest]

edgePairs = edges => edges ?
  | []           => []
  | [e, ...rest] => [(e.from, e.to), ...edgePairs rest]

minInt = a b => if a < b then a else b

bigFlow : Int
bigFlow = 1000000000

// Build residual network from edges
buildResidual : List Edge -> Residual
buildResidual = edges => {
  backward = backwardEdges edges
  allEdges = append edges backward
  graph = fromEdges (edgePairs allEdges)

  { graph: graph, capacities: insertCaps allEdges (Map.empty) }
}

insertCaps = items caps => items ?
  | []           => caps
  | [e, ...rest] => insertCaps rest (setCap e.from e.to e.cap caps)

// BFS to build level graph, returns (reachable, levels)
bfsLevels = residual source sink => {
  q0 = Queue.enqueue source (Queue.empty)
  levels0 = ~map{ source => 0 }
  levels = bfsVisit residual sink q0 levels0
  (Map.has sink levels, levels)
}

bfsVisit = residual sink q levels => (Queue.dequeue q) ?
  | None               => levels
  | Some (current, q2) => {
    levelCurrent = Map.getOrElse current (-1) levels
    graph = residual.graph
    neighbors = edgesFrom graph current
    (q3, levels3) = bfsExplore residual current levelCurrent neighbors q2 levels
    bfsVisit residual sink q3 levels3
  }

bfsExplore = residual current levelCurrent edges q levels => edges ?
  | []              => (q, levels)
  | [edge, ...tail] => {
    next = edge.to
    caps = residual.capacities
    cap = getCap current next caps
    already = Map.has next levels
    if cap > 0 && already == False then
      bfsExplore residual current levelCurrent tail (Queue.enqueue next q) (Map.insert next (levelCurrent + 1) levels)
    else
      bfsExplore residual current levelCurrent tail q levels
  }

// Push flow along an edge
pushFlow = residual from to delta => {
  caps0 = residual.capacities
  forward = getCap from to caps0
  backward = getCap to from caps0
  caps =
    caps0
  |> setCap from to (forward - delta)
  |> setCap to from (backward + delta)
    residual <| { capacities: caps }
}

// DFS to find blocking flow
dfsFlow = residual levels node sink flow =>
  if flow == 0 then (0, residual)
  else
  if node == sink then (flow, residual)
  else {
    graph = residual.graph
    neighbors = edgesFrom graph node
    dfsExplore residual levels node sink flow neighbors
  }

dfsExplore = residual levels node sink flow edges => edges ?
  | []              => (0, residual)
  | [edge, ...tail] => {
    caps = residual.capacities
    cap = getCap node edge.to caps
    levelNode = Map.getOrElse node (-1) levels
    levelNext = Map.getOrElse edge.to (-1) levels

    if cap > 0 && levelNext == levelNode + 1 then {
      available = minInt flow cap
      (pushed, after) = dfsFlow residual levels edge.to sink available
      if pushed > 0 then
        (pushed, pushFlow after node edge.to pushed)
      else
        dfsExplore after levels node sink flow tail
    }
    else
      dfsExplore residual levels node sink flow tail
  }

// Find blocking flow using repeated DFS
blockingFlow = residual source sink levels acc => {
  (pushed, updated) = dfsFlow residual levels source sink bigFlow
  if pushed == 0 then (acc, updated)
  else blockingFlow updated source sink levels (acc + pushed)
}

// Dinic's max flow algorithm
maxFlow : List Edge -> Int -> Int -> (Int, Residual)
maxFlow = edges source sink => {
  start = buildResidual edges
  maxFlowGo start source sink 0
}

maxFlowGo = state source sink total => {
  (reachable, levels) = bfsLevels state source sink
  if reachable == False then
    (total, state)
  else {
    (newTotal, updated) = blockingFlow state source sink levels total
    maxFlowGo updated source sink newTotal
  }
}

@test
flowTest = effect {
  edges = [
    { from: 0, to: 1, cap: 10 }
    { from: 0, to: 2, cap: 5 }
    { from: 1, to: 2, cap: 15 }
    { from: 1, to: 3, cap: 10 }
    { from: 2, to: 4, cap: 10 }
    { from: 3, to: 4, cap: 10 }
    { from: 3, to: 5, cap: 10 }
    { from: 4, to: 5, cap: 10 }
  ]

  (result, _) <- pure (maxFlow edges 0 5)
  _           <- assert (result == 20)

  (zero, _) <- pure (maxFlow [] 0 1)
  _         <- assert (zero == 0)
}
