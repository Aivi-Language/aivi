@no_prelude
module integrationTests.complex.Dinic

use aivi
use aivi.testing
use aivi.collections
use aivi.graph (fromEdges, edgesFrom)

// Edge with integer capacity
Edge = { from: Int, to: Int, cap: Int }

// Helpers -- text keys for capacity map
edgeKey = from to => "{ from }:{ to }"
getCap = from to caps => Map.getOrElse (edgeKey from to) 0 caps
setCap = from to value caps => Map.insert (edgeKey from to) value caps
addCap = from to delta caps => setCap from to (getCap from to caps + delta) caps

bigFlow : Int
bigFlow = 1000000000

// Build residual network from edges
buildResidual = edges => {
  backward = List.map (e => { from: e.to, to: e.from, cap: 0 }) edges
  allEdges = edges ++ backward
  graph = fromEdges (List.map (e => (e.from, e.to)) allEdges)
  caps = List.foldl (acc e => addCap e.from e.to e.cap acc) Map.empty allEdges
  { graph: graph, capacities: caps }
}

// BFS to build level graph, returns (reachable, levels)
bfsLevels = residual source sink => {
  q0 = Queue.enqueue source Queue.empty
  levels0 = Map.insert source 0 Map.empty
  levels = bfsVisit residual source sink q0 levels0
  (Map.has sink levels, levels)
}

bfsVisit = residual source sink q levels => (Queue.dequeue q) match
  | None               => levels
  | Some (current, q2) => {
      levelCurrent = Map.getOrElse current (-1) levels
      neighbors = edgesFrom residual.graph current
      (q3, levels3) = List.foldl ((q0, lvls) edge => {
        next = edge.to
        cap = getCap current next residual.capacities
        isVisited = next == source || Map.has next lvls
        if cap > 0 && !isVisited then
          (Queue.enqueue next q0, Map.insert next (levelCurrent + 1) lvls)
        else
          (q0, lvls)
      }) (q2, levels) neighbors
          bfsVisit residual source sink q3 levels3
    }

// Push flow along an edge, updating forward and backward caps
pushFlow = residual from to delta => {
  caps0 = residual.capacities
  forward = getCap from to caps0
  backward = getCap to from caps0
  newCaps = caps0 |> setCap from to (forward - delta) |> setCap to from (backward + delta)
  residual <| { capacities: newCaps }
}

// DFS to find one augmenting path in the level graph
dfsFlow = residual levels node sink flow =>
  if flow == 0 then (0, residual)
  else if node == sink then (flow, residual)
  else {
    neighbors = edgesFrom residual.graph node
    dfsExplore residual levels node sink flow neighbors
  }

dfsExplore = residual levels node sink flow edges => edges match
  | []              => (0, residual)
  | [edge, ...tail] => {
      cap = getCap node edge.to residual.capacities
      levelNode = Map.getOrElse node (-1) levels
      levelNext = Map.getOrElse edge.to (-1) levels
      if cap > 0 && levelNext == levelNode + 1 then {
        available = if flow < cap then flow else cap
        (pushed, after) = dfsFlow residual levels edge.to sink available
        if pushed > 0 then (pushed, pushFlow after node edge.to pushed)
        else dfsExplore after levels node sink flow tail
      }
      else dfsExplore residual levels node sink flow tail
    }

// Find blocking flow using repeated DFS
blockingFlow = residual source sink levels acc => {
  (pushed, updated) = dfsFlow residual levels source sink bigFlow
  if pushed == 0 then (acc, updated)
  else blockingFlow updated source sink levels (acc + pushed)
}

// Dinic's max flow algorithm
maxFlow = edges source sink => {
  start = buildResidual edges
  maxFlowGo start source sink 0
}

maxFlowGo = state source sink total => {
  (reachable, levels) = bfsLevels state source sink
  if !reachable then (total, state)
  else {
    (newTotal, updated) = blockingFlow state source sink levels total
    maxFlowGo updated source sink newTotal
  }
}

@test "Dinic's max-flow algorithm"
flowTest = do Effect {
  edges =
    [
      { from: 0, to: 1, cap: 10 }
      { from: 0, to: 2, cap: 5 }
      { from: 1, to: 2, cap: 15 }
      { from: 1, to: 3, cap: 10 }
      { from: 2, to: 4, cap: 10 }
      { from: 3, to: 4, cap: 10 }
      { from: 3, to: 5, cap: 10 }
      { from: 4, to: 5, cap: 10 }
    ]

    (result, _) <- pure (maxFlow edges 0 5)
    assert (result == 15)

    (zero, _) <- pure (maxFlow [] 0 1)
    assert (zero == 0)
}
