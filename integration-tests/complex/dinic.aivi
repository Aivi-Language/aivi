@no_prelude
module integrationTests.complex.Dinic

use aivi
use aivi.testing
use aivi.collections
use aivi.graph (Graph, fromWeightedEdges, edgesFrom)

// Edge with capacity
Edge = { from: Int, to: Int, cap: Int }

// Residual key for capacity lookup
ResidualKey = { from: Int, to: Int }

// Residual network state
Residual = {
  graph: Graph
  capacities: Map ResidualKey Int
}

// Get capacity or 0 from map
getOrZero = key map => Map.getOrElse key 0 map

// Build residual network from edges
buildResidual : List Edge -> Residual
buildResidual = edges => {
  backward = List.map edges (e => { from: e.to, to: e.from, cap: 0 })
  allEdges = edges ++ backward
  weighted = List.map allEdges (e => (e.from, e.to, Float e.cap))
  graph = fromWeightedEdges weighted

  { graph: graph, capacities: insertCaps allEdges Map.empty }
}

insertCaps = items caps => items ?
  | []           => caps
  | [e, ...rest] => insertCaps rest (Map.insert { from: e.from, to: e.to } e.cap caps)

// BFS to build level graph, returns (reachable, levels)
bfsLevels = residual source sink => {
  q0 = Queue.enqueue Queue.empty source
  levels0 = ~map{ source => 0 }
  levels = bfsVisit residual sink q0 levels0
  (Map.has sink levels, levels)
}

bfsVisit = residual sink q levels => (Queue.dequeue q) ?
  | None               => levels
  | Some (current, q2) => {
    levelCurrent = Map.getOrElse current - 1 levels
    neighbors = edgesFrom residual.graph current
    (q3, levels3) = bfsExplore residual current levelCurrent neighbors q2 levels
    bfsVisit residual sink q3 levels3
  }

bfsExplore = residual current levelCurrent edges q levels => edges ?
  | []              => (q, levels)
  | [edge, ...tail] => {
    next = edge.to
    cap = getOrZero { from: current, to: next } residual.capacities
    already = Map.has next levels
    if cap > 0 && !already then
      bfsExplore residual current levelCurrent tail (Queue.enqueue q next) (Map.insert next (levelCurrent + 1) levels)
    else
      bfsExplore residual current levelCurrent tail q levels
  }

// Push flow along an edge
pushFlow = residual from to delta => {
  forward = getOrZero { from: from, to: to } residual.capacities
  backward = getOrZero { from: to, to: from } residual.capacities
  caps = residual.capacities
    |> Map.insert { from: from, to: to } (forward - delta)
    |> Map.insert { from: to, to: from } (backward + delta)
    residual <| { capacities: caps }
}

// DFS to find blocking flow
dfsFlow = residual levels node sink flow =>
  if flow == 0 then (0, residual)
  else
  if node == sink then (flow, residual)
  else {
    neighbors = edgesFrom residual.graph node
    dfsExplore residual levels node sink flow neighbors
  }

dfsExplore = residual levels node sink flow edges => edges ?
  | []              => (0, residual)
  | [edge, ...tail] => {
    cap = getOrZero { from: node, to: edge.to } residual.capacities
    levelNode = Map.getOrElse node - 1 levels
    levelNext = Map.getOrElse edge.to - 1 levels

    if cap > 0 && levelNext == levelNode + 1 then {
      available = Int.min flow cap
      (pushed, after) = dfsFlow residual levels edge.to sink available
      if pushed > 0 then
        (pushed, pushFlow after node edge.to pushed)
      else
        dfsExplore after levels node sink flow tail
    }
    else
      dfsExplore residual levels node sink flow tail
  }

// Find blocking flow using repeated DFS
blockingFlow = residual source sink levels acc => {
  (pushed, updated) = dfsFlow residual levels source sink Int.max
  if pushed == 0 then (acc, updated)
  else blockingFlow updated source sink levels (acc + pushed)
}

// Dinic's max flow algorithm
maxFlow : List Edge -> Int -> Int -> (Int, Residual)
maxFlow = edges source sink => {
  start = buildResidual edges
  maxFlowGo start source sink 0
}

maxFlowGo = state source sink total => {
  (reachable, levels) = bfsLevels state source sink
  if !reachable then (total, state)
  else {
    (newTotal, updated) = blockingFlow state source sink levels total
    maxFlowGo updated source sink newTotal
  }
}

@test
flowTest = effect {
  edges = [
    { from: 0, to: 1, cap: 10 }
    { from: 0, to: 2, cap: 5 }
    { from: 1, to: 2, cap: 15 }
    { from: 1, to: 3, cap: 10 }
    { from: 2, to: 4, cap: 10 }
    { from: 3, to: 4, cap: 10 }
    { from: 3, to: 5, cap: 10 }
    { from: 4, to: 5, cap: 10 }
  ]

  (result, _) = maxFlow edges 0 5
  _ <- assert (result == 20)

  (zero, _) = maxFlow [] 0 1
  _ <- assert (zero == 0)
}
