@no_prelude
module integrationTests.complex.FenwickTree

use aivi
use aivi.testing
use aivi.collections

// Fenwick tree (Binary Indexed Tree) for efficient prefix sums
Fenwick = { size: Int, tree: Map Int Int }

listLength = xs => xs ?
  | []        => 0
  | [_, ...t] => 1 + listLength t

at = xs idx => xs ?
  | []        => None
  | [h, ...t] => if idx == 0 then Some h else at t (idx - 1)

// Extract lowest set bit
lowbit : Int -> Int
lowbit = idx => idx ?
  | _ when idx % 2 == 1 => 1
  | _                   => 2 * lowbit (idx / 2)

// Add delta to all affected indices
addDelta = size idx delta tree =>
  if idx > size then tree
  else {
    cur = Map.getOrElse idx 0 tree
    updated = Map.insert idx (cur + delta) tree
    addDelta size (idx + lowbit idx) delta updated
  }

// Build Fenwick tree from list
buildFromList : List Int -> Fenwick
buildFromList = arr => {
  size = listLength arr
  { size: size, tree: buildTree arr size 1 Map.empty }
}

buildTree = arr size idx tree => {
    if idx > size then
      tree
    else
      at arr (idx - 1) ?
        | None       => buildTree arr size (idx + 1) tree
        | Some value => buildTree arr size (idx + 1) (addDelta size idx value tree)
  }

// Query prefix sum [1..idx]
prefix : Fenwick -> Int -> Int
prefix = fenwick idx => prefixGo fenwick idx 0

prefixGo = fenwick i acc => {
  if i == 0 then
    acc
  else {
    val = Map.getOrElse i 0 fenwick.tree
    prefixGo fenwick (i - lowbit i) (acc + val)
  }
}

// Query range sum [l..r]
rangeSum : Fenwick -> Int -> Int -> Option Int
rangeSum = fenwick l r =>
  if l > r || l < 1 then None
  else Some (prefix fenwick r - prefix fenwick (l - 1))

// Point update at index
update : Fenwick -> Int -> Int -> Fenwick
update = fenwick idx value =>
  if idx < 1 || idx > fenwick.size then fenwick
  else {
    prev = rangeSum fenwick idx idx
    delta = prev ? | Some v => value - v | None => value
    fenwick <| { tree: addDelta fenwick.size idx delta fenwick.tree }
  }

// Naive sum for verification
naiveSum : List Int -> Int -> Int -> Int
naiveSum = arr l r => arr ?
  | []                              => 0
  | [h, ...t] when l <= 1 && r >= 1 => h + naiveSum t (l - 1) (r - 1)
  | [_, ...t]                       => naiveSum t (l - 1) (r - 1)

// Verify indices match naive implementation
verifyIndices = indices fen arr => indices ?
  | []        => True
  | [h, ...t] => {
    expected = naiveSum arr h h
    matches = rangeSum fen h h ?
      | Some got => got == expected
      | None     => False
    matches && verifyIndices t fen arr
  }

  @test
behaviors = effect {
  values = [3, 1, 4, 1, 5]
  fenwick = buildFromList values

  sum05 = rangeSum fenwick 1 5
  _ <- assert (sum05 == Some 14)

  sum23 = rangeSum fenwick 2 3
  _ <- assert (sum23 == Some 5)

  _ <- assert (rangeSum fenwick 6 6 == None)

  updated = update fenwick 3 9
  _ <- assert (rangeSum updated 3 3 == Some 9)
  _ <- assert (rangeSum fenwick 3 3 == Some 4)

  _ <- assert (verifyIndices [1, 2, 3, 4, 5] updated values)
}
