@no_prelude
module integrationTests.complex.FenwickTree

use aivi
use aivi.testing
use aivi.collections

// Fenwick tree (Binary Indexed Tree) for efficient prefix sums
Fenwick = { size: Int, tree: Map Int Int }

// Extract lowest set bit via recursive halving
lowbit : Int -> Int
lowbit = _ match
  | idx when idx % 2 == 1 => 1
  | idx                   => 2 * lowbit (idx / 2)

// Add delta to all affected indices
addDelta = size idx delta tree =>
  if idx > size then tree
  else {
    cur = Map.getOrElse idx 0 tree
    updated = Map.insert idx (cur + delta) tree
    addDelta size (idx + lowbit idx) delta updated
  }

// Build Fenwick tree from list
buildFromList : List Int -> Fenwick
buildFromList = arr => {
  size = List.length arr
  { size: size, tree: buildTree arr size 1 Map.empty }
}

buildTree = arr size idx tree =>
  if idx > size then tree
  else
  List.at (idx - 1) arr match
    | None       => buildTree arr size (idx + 1) tree
    | Some value => buildTree arr size (idx + 1) (addDelta size idx value tree)

// Query prefix sum [1..idx]
prefix : Fenwick -> Int -> Int
prefix = fenwick idx => prefixGo fenwick idx 0

prefixGo = fenwick i acc =>
  if i == 0 then acc
  else {
    val = Map.getOrElse i 0 fenwick.tree
    prefixGo fenwick (i - lowbit i) (acc + val)
  }

// Query range sum [l..r]
rangeSum : Fenwick -> Int -> Int -> Option Int
rangeSum = fenwick l r =>
  if l > r || l < 1 || r > fenwick.size then None
  else Some (prefix fenwick r - prefix fenwick (l - 1))

// Point update at index
update : Fenwick -> Int -> Int -> Fenwick
update = fenwick idx value =>
  if idx < 1 || idx > fenwick.size then fenwick
  else {
    prev = rangeSum fenwick idx idx
    delta = prev match
      | Some v => value - v
      | None   => value
    fenwick <| { tree: addDelta fenwick.size idx delta fenwick.tree }
  }

// Naive sum for verification
naiveSum : List Int -> Int -> Int -> Int
naiveSum = arr l r => arr match
  | []                              => 0
  | [h, ...t] when l <= 1 && r >= 1 => h + naiveSum t (l - 1) (r - 1)
  | [_, ...t]                       => naiveSum t (l - 1) (r - 1)

// Verify indices match naive implementation using a generator
verifyIndices = indices fen arr =>
  generate {
    i <- indices
    expected = naiveSum arr i i
    result = rangeSum fen i i match
      | Some got => got == expected
      | None     => False
    yield result
  }
|> List.foldl (acc ok => acc && ok) True

@test
behaviors = do Effect {
  values = [3, 1, 4, 1, 5]
  fenwick = buildFromList values

  sum05 = rangeSum fenwick 1 5
  assert (sum05 == Some 14)

  sum23 = rangeSum fenwick 2 3
  assert (sum23 == Some 5)

  assert (rangeSum fenwick 6 6 == None)

  updated = update fenwick 3 9
  assert (rangeSum updated 3 3 == Some 9)
  assert (rangeSum fenwick 3 3 == Some 4)

  assert (verifyIndices [1, 2, 3, 4, 5] fenwick values)
  assert (verifyIndices [1, 2, 3, 4, 5] updated [3, 1, 9, 1, 5])
}
