@no_prelude
module integrationTests.complex.dijkstraEffectful

use aivi
use aivi.testing
use aivi.graph (fromWeightedEdges, edgesFrom)
use aivi.collections

// Process edges from the current node: relax each edge
// and push updated vertices onto the priority queue.
processEdges = dists d edges pq => edges match
  | []              => pure { dists: dists, pq: pq }
  | [edge, ...rest] => do Effect {
    currentDist = Map.getOrElse edge.to 999999.0 dists
    newDist = d + edge.weight
    nextState = if newDist < currentDist
    then {
      dists: Map.insert edge.to newDist dists
      pq: Heap.push (newDist, edge.to) pq
    }
    else { dists: dists, pq: pq }
    processEdges nextState.dists d rest nextState.pq
  }

@test "Dijkstra with mutable state"
dijkstra_shortestPaths = do Effect {
  // Graph: 0->1 (2.0), 0->2 (5.0), 1->2 (1.0), 1->3 (4.0), 2->3 (1.0)
  g = fromWeightedEdges [(0, 1, 2.0), (0, 2, 5.0), (1, 2, 1.0), (1, 3, 4.0), (2, 3, 1.0)]

  // Distance table: source node 0 starts at 0.0
  dists0 = Map.insert 0 0.0 Map.empty

  // Dijkstra main loop with min-heap priority queue and loop/recurse
  loop state = { dists: dists0, pq: Heap.push (0.0, 0) Heap.empty } => {
    dists = state.dists
    pq = state.pq
    result = Heap.popMin pq
    result match
      | None                     => pure dists
      | Some ((d, node), restPq) => do Effect {
        currentDist = Map.getOrElse node 999999.0 dists
        if d > currentDist
        then do Effect { recurse { dists: dists, pq: restPq } }
        else do Effect {
          edges = edgesFrom g node
          nextState <- processEdges dists d edges restPq
          recurse nextState
        }
      }
  }

  dists <- loop

  // Verify shortest distances from node 0
  d0 = Map.getOrElse 0 999999.0 dists
  d1 = Map.getOrElse 1 999999.0 dists
  d2 = Map.getOrElse 2 999999.0 dists
  d3 = Map.getOrElse 3 999999.0 dists

  assert (d0 == 0.0)
  assert (d1 == 2.0)
  assert (d2 == 3.0)
  assert (d3 == 4.0)
}
