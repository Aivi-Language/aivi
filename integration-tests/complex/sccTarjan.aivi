@no_prelude
module integrationTests.complex.SCCTarjan

use aivi
use aivi.testing
use aivi.collections

// Adjacency list graph
Graph = { nodes: List Int, adj: Map Int (List Int) }

// Tarjan's algorithm state
TarjanState = {
  index: Map Int Int
  lowlink: Map Int Int
  stack: List Int
  onStack: Set Int
  nextIndex: Int
  components: List (List Int)
}

// Helper to get value or fallback from map
getOr = map key fallback => Map.get key map ?
  | Some v => v
  | None   => fallback

// Pop nodes from stack until we reach the root of SCC
popComponent = node state => {
  (newStack, comp) = popUntil node state.stack []
  state <| {
    stack: newStack
    onStack: removeAll comp state.onStack
    components: [comp, ...state.components]
  }
}

popUntil = node stack acc => stack ?
  | []                       => ([], acc)
  | [h, ...t] when h == node => (t, [h, ...acc])
  | [h, ...t]                => popUntil node t [h, ...acc]

removeAll = nodes set => nodes ?
  | []        => set
  | [h, ...t] => removeAll t (Set.remove h set)

// Get neighbors of a node
neighbors = node graph => Map.get node graph.adj ?
  | Some list => list
  | None      => []

// Visit a node in DFS
visitNode = graph node state => {
  // Initialize node's index and lowlink
  state1 = state <| {
    index: Map.insert node state.nextIndex state.index
    lowlink: Map.insert node state.nextIndex state.lowlink
    stack: [node, ...state.stack]
    onStack: Set.insert node state.onStack
    nextIndex: state.nextIndex + 1
  }

  after = processNeighbors graph node (neighbors node graph) state1
  nodeLow = getOr after.lowlink node Int.max
  nodeIdx = getOr after.index node Int.max
  if nodeLow == nodeIdx then popComponent node after else after
}

processNeighbors = graph node nexts state => nexts ?
  | []              => state
  | [next, ...tail] => {
    acc =
    if Map.has next state.index then
      if Set.has next state.onStack then {
        lowNode = getOr state.lowlink node Int.max
        idxNext = getOr state.index next Int.max
        state <| { lowlink: Map.insert node (Int.min lowNode idxNext) state.lowlink }
      }
      else
        state
    else {
      nested = visitNode graph next state
      lowNode = getOr nested.lowlink node Int.max
      lowNext = getOr nested.lowlink next Int.max
      nested <| { lowlink: Map.insert node (Int.min lowNode lowNext) nested.lowlink }
    }
    processNeighbors graph node tail acc
  }

// Find all strongly connected components using Tarjan's algorithm
strongComponents : Graph -> List (List Int)
strongComponents = graph => {
  initial = {
    index: Map.empty
    lowlink: Map.empty
    stack: []
    onStack: Set.empty
    nextIndex: 0
    components: []
  }

  finalState = processNodes graph graph.nodes initial
  finalState.components
}

processNodes = graph nodes state => nodes ?
  | []        => state
  | [h, ...t] => {
    nextState = if Map.has h state.index then state else visitNode graph h state
    processNodes graph t nextState
  }

// Check if list contains element
contains = list target => list ?
  | []                         => False
  | [h, ...t] when h == target => True
  | [_, ...t]                  => contains t target

// Check if any element satisfies predicate
listAny = list pred => list ?
  | []        => False
  | [h, ...t] => if pred h then True else listAny t pred

  @test
sccSmoke = effect {
  adj = ~map{
    0 => [1]
    1 => [2]
    2 => [0, 3]
    3 => []
  }
  graph = { nodes: [0, 1, 2, 3], adj: adj }

  comps = strongComponents graph
  _ <- assert (List.length comps == 2)
  _ <- assert (listAny comps (cmp => contains cmp 0))
}
