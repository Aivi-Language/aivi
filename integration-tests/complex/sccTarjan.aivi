@no_prelude
module integrationTests.complex.SCCTarjan

use aivi
use aivi.testing
use aivi.collections

// Adjacency list graph
Graph = { nodes: List Int, adj: Map Int (List Int) }

bigInt : Int
bigInt = 1000000000

// Tarjan's algorithm state
TarjanState = {
  index: Map Int Int
  lowlink: Map Int Int
  stack: List Int
  onStack: Set Int
  nextIndex: Int
  components: List (List Int)
}

// Helper to get value or fallback from map
getOr = map key fallback => Map.get key map match
  | Some v => v
  | None   => fallback

// Pop nodes from stack until we reach the root of SCC
popComponent = node state => {
  (newStack, comp) = popUntil node state.stack []
  state <| {
    stack: newStack
    onStack: List.foldl (s n => Set.remove n s) state.onStack comp
    components: [comp, ...state.components]
  }
}

popUntil = node stack acc => stack match
  | []                       => ([], acc)
  | [h, ...t] when h == node => (t, [h, ...acc])
  | [h, ...t]                => popUntil node t [h, ...acc]

// Get neighbors of a node
neighbors = node graph => Map.get node graph.adj match
  | Some list => list
  | None      => []

// Visit a node in DFS
visitNode = graph node state => {
  // Initialize node's index and lowlink
  state1 = state <| {
    index: Map.insert node state.nextIndex state.index
    lowlink: Map.insert node state.nextIndex state.lowlink
    stack: [node, ...state.stack]
    onStack: Set.insert node state.onStack
    nextIndex: state.nextIndex + 1
  }

  after = List.foldl (s next =>
    if Map.has next s.index then
      if Set.has next s.onStack then {
        lowNode = getOr s.lowlink node bigInt
        idxNext = getOr s.index next bigInt
        s <| { lowlink: Map.insert node (if lowNode < idxNext then lowNode else idxNext) s.lowlink }
      }
      else s
    else {
      nested = visitNode graph next s
      lowNode = getOr nested.lowlink node bigInt
      lowNext = getOr nested.lowlink next bigInt
      nested <| { lowlink: Map.insert node (if lowNode < lowNext then lowNode else lowNext) nested.lowlink }
    }
  ) state1 (neighbors node graph)

  nodeLow = getOr after.lowlink node bigInt
  nodeIdx = getOr after.index node bigInt
  if nodeLow == nodeIdx then popComponent node after else after
}

// Find all strongly connected components using Tarjan's algorithm
strongComponents : Graph -> List (List Int)
strongComponents = graph => {
  initial = {
    index: Map.empty
    lowlink: Map.empty
    stack: []
    onStack: Set.empty
    nextIndex: 0
    components: []
  }

  finalState = List.foldl (s h =>
    if Map.has h s.index then s else visitNode graph h s
  ) initial graph.nodes

  finalState.components
}

@test "Tarjan SCC detection"
sccSmoke = do Effect {
  adj = ~map{
    0 => [1]
    1 => [2]
    2 => [0, 3]
    3 => []
  }
  graph = { nodes: [0, 1, 2, 3], adj: adj }

  comps <- pure (strongComponents graph)
  assert (List.length comps == 2)
  assert (List.find (cmp => List.find (_ == 0) cmp != None) comps != None)
}
