@no_prelude
module integrationTests.complex.SCCTarjan

use aivi
use aivi.testing
use aivi.collections

Graph = { nodes: List Int, adj: Map Int (List Int) }
TarjanState =
  { index: Map Int Int
    lowlink: Map Int Int
    stack: List Int
    onStack: Set Int
    nextIndex: Int
    components: List (List Int)
  }

minInt = a b =>
  if a < b then a else b

lookupOr = map key fallback => (Map.get key map) ?
  | Some v => v
  | None   => fallback

popComponent = node state => {
  pop = stack acc => stack ?
    | []        => ([], acc)
    | [h, ...t] =>
      if h == node then
        (t, [h, ...acc])
    else
      pop t [h, ...acc]

    (newStack, comp) = pop state.stack []
    state <| {
        stack: newStack
        onStack: Set.remove node state.onStack
        components: [comp, ...state.components]
    }
}

visitNode = graph node state => {
  state1 =
    state <| {
        index: Map.insert node state.nextIndex state.index
        lowlink: Map.insert node state.nextIndex state.lowlink
        stack: [node, ...state.stack]
        onStack: Set.insert node state.onStack
        nextIndex: state.nextIndex + 1
    }

  neighbors =
    (Map.get node graph.adj) ?
      | Some list => list
      | None      => []

    foldNeighbors = list accState => list ?
      | []              => accState
      | [next, ...tail] => {
          acc =
            if Map.has next accState.index then
              if Set.has next accState.onStack then {
                    lowNode = lookupOr accState.lowlink node Int.max
                    lowNext = lookupOr accState.lowlink next Int.max
                    accState <| {
                          lowlink: Map.insert node (minInt lowNode lowNext) accState.lowlink
                    }
              }
          else
            accState
          else {
              nested = visitNode graph next accState
              lowNode = lookupOr nested.lowlink node Int.max
              lowNext = lookupOr nested.lowlink next Int.max
              nested <| {
                  lowlink: Map.insert node (minInt lowNode lowNext) nested.lowlink
              }
          }

          foldNeighbors tail acc
      }

    after = foldNeighbors neighbors state1
    nodeLow = lookupOr after.lowlink node Int.max
    nodeIdx = lookupOr after.index node Int.max
    if nodeLow == nodeIdx then popComponent node after else after
}

listAny = list pred => list ?
  | []        => False
  | [h, ...t] => if pred h then True else listAny t pred

strongComponents = graph => {
  initial = {
    index: Map.empty
    lowlink: Map.empty
    stack: []
    onStack: Set.empty
    nextIndex: 0
    components: []
  }

  foldNodes = nodes state => nodes ?
    | []        => state
    | [h, ...t] => {
        s = if Map.has h state.index then state else visitNode graph h state
        foldNodes t s
    }

    finalState = foldNodes graph.nodes initial
    finalState.components
}

contains = list target => list ?
  | []        => False
  | [h, ...t] => if h == target then True else contains t target

  @test
sccSmoke =
  effect {
      adj0 = Map.insert 0 [1] Map.empty
      adj1 = Map.insert 1 [2] adj0
      adj2 = Map.insert 2 [0, 3] adj1
      adj3 = Map.insert 3 [] adj2
      graph = { nodes: [0, 1, 2, 3], adj: adj3 }

      comps = strongComponents graph
      _ <- assert (List.length comps == 2)
      _ <- assert (listAny comps (cmp => contains cmp 0))
  }
