@no_prelude
module integrationTests.complex.DijkstraHeap

use aivi
use aivi.testing
use aivi.collections
use aivi.math (sum)
use aivi.graph (Graph, fromWeightedEdges, edgesFrom)

// Large constant for infinity
infinity : Float
infinity = 1000000.0

priority2 = item => item ? | (p, _) => p

popMin2 = items => items match
  | []        => None
  | [h, ...t] => Some (popMin2Go h [] t)

popMin2Go = best restAcc items => items match
  | []        => (best, restAcc)
  | [x, ...t] => {
    bestP = priority2 best
    xP = priority2 x
    if xP < bestP then
      popMin2Go x [best, ...restAcc] t
    else
      popMin2Go best [x, ...restAcc] t
  }

// Build weighted graph from edge list
buildGraph = fromWeightedEdges [
  (0, 1, 2.0)
  (0, 2, 5.0)
  (1, 2, 1.0)
  (1, 3, 4.0)
  (2, 3, 1.0)
]

// Expand all neighbors, returning updated (queue, dist)
expandNeighbors : List { to: Int, weight: Float } -> List (Float, Int) -> Map Int Float -> Float -> (List (Float, Int), Map Int Float)
expandNeighbors = edges queue dist currentDist => edges match
  | []              => (queue, dist)
  | [edge, ...tail] => {
    tentative = sum [currentDist, edge.weight]
    prev = Map.getOrElse edge.to infinity dist
    if tentative < prev then
      expandNeighbors tail [(tentative, edge.to), ...queue] (Map.insert edge.to tentative dist) currentDist
    else
      expandNeighbors tail queue dist currentDist
  }

// Main search loop
search : List (Float, Int) -> Map Int Float -> Set Int -> Graph -> Map Int Float
search = queue dist visited graph => popMin2 queue match
  | None                             => dist
  | Some ((currentDist, node), rest) =>
    if Set.has node visited then
      search rest dist visited graph
    else {
      neighbors = edgesFrom graph node
      (nextQueue, nextDist) = expandNeighbors neighbors rest dist currentDist
      search nextQueue nextDist (Set.insert node visited) graph
    }

// Dijkstra entry point
dijkstra : Graph -> Int -> Map Int Float
dijkstra = graph start =>
  search [(0.0, start)] (~map{ start => 0.0 }) (Set.empty) graph

@test
shortestPaths = do Effect {
  graph     <- pure buildGraph
  distances <- pure (dijkstra graph 0)
  assert (Map.get 3 distances == Some 4.0)
  assert (Map.get 2 distances == Some 3.0)
}
