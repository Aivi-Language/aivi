@no_prelude
module integrationTests.complex.DijkstraHeap

use aivi
use aivi.testing
use aivi.collections
use aivi.math (sum)
use aivi.graph (Graph, fromWeightedEdges, edgesFrom)

// Large constant for infinity
infinity : Float
infinity = 1000000.0

// Build weighted graph from edge list
buildGraph = fromWeightedEdges [
  (0, 1, 2.0)
  (0, 2, 5.0)
  (1, 2, 1.0)
  (1, 3, 4.0)
  (2, 3, 1.0)
]

// Expand all neighbors, returning updated (queue, dist)
expandNeighbors : List { to: Int, weight: Float } -> Heap (Float, Int) -> Map Int Float -> Float -> (Heap (Float, Int), Map Int Float)
expandNeighbors = edges queue dist currentDist => edges ?
  | []              => (queue, dist)
  | [edge, ...tail] => {
    tentative = sum [currentDist, edge.weight]
    prev = Map.getOrElse edge.to infinity dist
    if tentative < prev then
      expandNeighbors tail (Heap.push (tentative, edge.to) queue) (Map.insert edge.to tentative dist) currentDist
    else
      expandNeighbors tail queue dist currentDist
  }

// Main search loop
search : Heap (Float, Int) -> Map Int Float -> Set Int -> Graph -> Map Int Float
search = queue dist visited graph => (Heap.popMin queue) ?
  | None                             => dist
  | Some ((currentDist, node), rest) =>
    if Set.has node visited then
      search rest dist visited graph
    else {
      neighbors = edgesFrom graph node
      (nextQueue, nextDist) = expandNeighbors neighbors rest dist currentDist
      search nextQueue nextDist (Set.insert node visited) graph
    }

// Dijkstra entry point
dijkstra : Graph -> Int -> Map Int Float
dijkstra = graph start =>
  search (Heap.push (0.0, start) Heap.empty) (~map{ start => 0.0 }) Set.empty graph

  @test
  shortestPaths = effect {
    graph     <- pure buildGraph
    distances <- pure (dijkstra graph 0)
    _         <- assert (Map.get 3 distances == Some 4.0)
    _         <- assert (Map.get 2 distances == Some 3.0)
  }
