@no_prelude
module integrationTests.complex.DijkstraHeap

use aivi
use aivi.testing
use aivi.collections
use aivi.graph (Graph, fromWeightedEdges, edgesFrom)

// Large constant for infinity
infinity : Float
infinity = 1000000.0

// Build weighted graph from edge list
buildGraph = fromWeightedEdges [
  (0, 1, 2.0)
  (0, 2, 5.0)
  (1, 2, 1.0)
  (1, 3, 4.0)
  (2, 3, 1.0)
]

// Expand all neighbors using List.foldl, returning updated (queue, dist)
expandNeighbors = edges queue dist currentDist =>
  List.foldl ((q, d) edge => {
      tentative = currentDist + edge.weight
      prev = Map.getOrElse edge.to infinity d
      if tentative < prev then
        (Heap.push (tentative, edge.to) q, Map.insert edge.to tentative d)
      else
        (q, d)
  }) (queue, dist) edges

// Main search loop using Heap.popMin
search : Heap (Float, Int) -> Map Int Float -> Set Int -> Graph -> Map Int Float
search = queue dist visited graph => Heap.popMin queue match
  | None                             => dist
  | Some ((currentDist, node), rest) =>
    if Set.has node visited then
      search rest dist visited graph
    else {
      neighbors = edgesFrom graph node
      (nextQueue, nextDist) = expandNeighbors neighbors rest dist currentDist
      search nextQueue nextDist (Set.insert node visited) graph
    }

// Dijkstra entry point
dijkstra : Graph -> Int -> Map Int Float
dijkstra = graph start =>
  search (Heap.push (0.0, start) Heap.empty) (~map{ start => 0.0 }) Set.empty graph

@test "Dijkstra with immutable heap"
shortestPaths = do Effect {
  graph <- pure buildGraph
  distances <- pure (dijkstra graph 0)
  assert (Map.get 3 distances == Some 4.0)
  assert (Map.get 2 distances == Some 3.0)
}
