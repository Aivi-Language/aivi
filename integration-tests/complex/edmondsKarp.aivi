@no_prelude
module integrationTests.complex.EdmondsKarp

use aivi
use aivi.testing
use aivi.collections
use aivi.graph (fromEdges, edgesFrom)

// Edge with integer capacity
Edge = { from: Int, to: Int, cap: Int }

// Helpers -- text keys avoid record-key issues in Map
edgeKey = from to => "{ from }:{ to }"
getCap = from to caps => Map.getOrElse (edgeKey from to) 0 caps
setCap = from to value caps => Map.insert (edgeKey from to) value caps
addCap = from to delta caps => setCap from to (getCap from to caps + delta) caps

// Build residual network from edges
buildResidual = edges => {
  backward = List.map (e => { from: e.to, to: e.from, cap: 0 }) edges
  allEdges = edges ++ backward
  graph = fromEdges (List.map (e => (e.from, e.to)) allEdges)
  caps = List.foldl (acc e => addCap e.from e.to e.cap acc) Map.empty allEdges
  { graph: graph, capacities: caps }
}

// BFS from source to sink, returns Option (Map Int Int) parent map
bfs = residual source sink => {
  q0 = Queue.enqueue source Queue.empty
  bfsLoop residual source sink q0 Map.empty
}

bfsLoop = residual source sink q parents => (Queue.dequeue q) match
  | None               => None
  | Some (current, q2) =>
    if current == sink then Some parents
    else {
      neighbors = edgesFrom residual.graph current
      (q3, parents3) = List.foldl ((q0, par) edge => {
        next = edge.to
        cap = getCap current next residual.capacities
        isVisited = next == source || Map.has next par
        if cap > 0 && !isVisited then
          (Queue.enqueue next q0, Map.insert next current par)
        else
          (q0, par)
      }) (q2, parents) neighbors
          bfsLoop residual source sink q3 parents3
    }

// Reconstruct path from parent map
reconstructPath = parents source sink =>
  buildPath sink source parents [sink]

buildPath = node source parents acc =>
  if node == source then acc
  else (Map.get node parents) match
    | None        => []
    | Some parent => buildPath parent source parents ([parent] ++ acc)

// Find minimum capacity along a path
pathCapacity = path caps => walkMin path caps 0

walkMin = path caps best => path match
  | []              => best
  | [_]             => best
  | [a, b, ...rest] => {
      c = getCap a b caps
      newBest = if best == 0 then c else if c < best then c else best
      walkMin ([b] ++ rest) caps newBest
    }

// Update capacities along a path (push delta flow)
updateCaps = path delta caps => path match
  | []              => caps
  | [_]             => caps
  | [a, b, ...rest] => {
      fwd = getCap a b caps
      bwd = getCap b a caps
      caps2 = caps |> setCap a b (fwd - delta) |> setCap b a (bwd + delta)
      updateCaps ([b] ++ rest) delta caps2
    }

// Edmonds-Karp max flow algorithm
edmondsKarp = edges source sink => {
  residual = buildResidual edges
  ekLoop residual source sink 0
}

ekLoop = residual source sink totalFlow => (bfs residual source sink) match
  | None         => totalFlow
  | Some parents => {
      path = reconstructPath parents source sink
      delta = pathCapacity path residual.capacities
      if delta == 0 then totalFlow
      else {
        newCaps = updateCaps path delta residual.capacities
        ekLoop (residual <| { capacities: newCaps }) source sink (totalFlow + delta)
      }
    }

@test "Edmonds-Karp max-flow"
flowTest = do Effect {
  // CLRS max-flow example (6 nodes, expected max flow = 23)
  edges =
    [
      { from: 0, to: 1, cap: 16 }
      { from: 0, to: 2, cap: 13 }
      { from: 1, to: 2, cap: 10 }
      { from: 2, to: 1, cap: 4 }
      { from: 1, to: 3, cap: 12 }
      { from: 3, to: 2, cap: 9 }
      { from: 2, to: 4, cap: 14 }
      { from: 4, to: 3, cap: 7 }
      { from: 3, to: 5, cap: 20 }
      { from: 4, to: 5, cap: 4 }
    ]

    result <- pure (edmondsKarp edges 0 5)
    assert (result == 23)

    zero <- pure (edmondsKarp [] 0 1)
    assert (zero == 0)
}
