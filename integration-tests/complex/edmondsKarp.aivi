@no_prelude
module integrationTests.complex.EdmondsKarp

use aivi
use aivi.testing
use aivi.collections
use aivi.graph (Graph, fromWeightedEdges, edgesFrom)

// Edge with capacity
Edge = { from: Int, to: Int, cap: Float }

// Residual key for capacity lookup
ResidualKey = { from: Int, to: Int }

// Residual network state
Residual = {
  graph: Graph
  capacities: Map ResidualKey Float
}

// Get capacity or 0 from map
getOrZero = key map => Map.get key map ?
  | Some v => v
  | None   => 0.0

// Build residual network from edges
buildResidual : List Edge -> Residual
buildResidual = edges => {
  backward = List.map edges (e => { from: e.to, to: e.from, cap: 0.0 })
  allEdges = edges ++ backward
  weighted = List.map allEdges (e => (e.from, e.to, e.cap))
  graph = fromWeightedEdges weighted

  // Build capacity map
  addCaps = items acc isZero => items ?
    | []           => acc
    | [e, ...rest] => {
        key = { from: e.from, to: e.to }
        val = if isZero then 0.0 else e.cap
        addCaps rest (Map.insert key val acc) isZero
      }

  caps = addCaps edges Map.empty False
  capsWithReverse = addCaps backward caps True
  { graph: graph, capacities: capsWithReverse }
}

// BFS to find augmenting path
bfs = residual source sink => {
  visit = queue visited parents => queue ?
    | []                 => None
    | [current, ...rest] =>
      if current == sink then Some parents
      else {
        edges = edgesFrom residual.graph current

        explore = list q seen pars => list ?
          | []              => visit q seen pars
          | [edge, ...tail] => {
              next = edge.to
              cap = getOrZero { from: current, to: next } residual.capacities
              if cap > 0.0 && !Set.has next seen then
                explore tail (q ++ [next]) (Set.insert next seen) (Map.insert next current pars)
              else
                explore tail q seen pars
            }

        explore edges rest visited parents
      }

  visit [source] (Set.insert source Set.empty) Map.empty
}

// Reconstruct path from parents map
reconstruct = parents sink source acc =>
  if sink == source then [source, ...acc]
  else Map.get sink parents ?
    | Some prev => reconstruct parents prev source [sink, ...acc]
    | None      => []

// Calculate bottleneck capacity along path
pathCapacity = residual path => path ?
  | []              => 0.0
  | [_]             => Float Int.max
  | [a, b, ...rest] => {
      cap = getOrZero { from: a, to: b } residual.capacities
      Float.min cap (pathCapacity residual [b, ...rest])
    }

// Update capacities along path
updatePath = residual path delta => {
  apply = from to caps => {
    forward = getOrZero { from, to } caps
    backward = getOrZero { from: to, to: from } caps
    caps
      |> Map.insert { from, to } (forward - delta)
      |> Map.insert { from: to, to: from } (backward + delta)
  }

  go = nodes caps => nodes ?
    | []              => caps
    | [_]             => caps
    | [a, b, ...rest] => go [b, ...rest] (apply a b caps)

  residual <| { capacities: go path residual.capacities }
}

// Main augmenting path loop
augment = residual source sink parents total => {
  path = reconstruct parents sink source []
  delta = pathCapacity residual path
  if delta == 0.0 then (total, residual)
  else augment (updatePath residual path delta) source sink Map.empty (total + delta)
}

// Edmonds-Karp max flow algorithm
maxFlow : List Edge -> Int -> Int -> (Float, Residual)
maxFlow = edges source sink => {
  residual = buildResidual edges

  go = state total => bfs state source sink ?
    | None         => (total, state)
    | Some parents => {
        (newTotal, updated) = augment state source sink parents total
        go updated newTotal
      }

  go residual 0.0
}

@test
maxFlowTest = effect {
  edges = [
    { from: 0, to: 1, cap: 16.0 }
    { from: 0, to: 2, cap: 13.0 }
    { from: 1, to: 2, cap: 10.0 }
    { from: 2, to: 1, cap: 4.0 }
    { from: 1, to: 3, cap: 12.0 }
    { from: 3, to: 2, cap: 9.0 }
    { from: 2, to: 4, cap: 14.0 }
    { from: 4, to: 3, cap: 7.0 }
    { from: 3, to: 5, cap: 20.0 }
    { from: 4, to: 5, cap: 4.0 }
  ]

  (flow, _) = maxFlow edges 0 5
  _ <- assert (flow == 23.0)

  (zeroFlow, _) = maxFlow [] 0 1
  _ <- assert (zeroFlow == 0.0)
}
