@no_prelude
module integrationTests.complex.EdmondsKarp

use aivi
use aivi.testing
use aivi.collections
use aivi.graph (Graph, fromEdges, edgesFrom)

// Edge with capacity
Edge = { from: Int, to: Int, cap: Float }

// Residual key for capacity lookup
ResidualKey = { from: Int, to: Int }

// Residual network state
Residual = {
  graph: Graph
  capacities: Map ResidualKey Float
}

// Get capacity or 0 from map
getOrZero = key map => Map.getOrElse key 0.0 map

bigCap : Float
bigCap = 1000000000.0

// Build residual network from edges using List.map and ++
buildResidual : List Edge -> Residual
buildResidual = edges => {
  backward = List.map (e => { from: e.to, to: e.from, cap: 0.0 }) edges
  allEdges = edges ++ backward
  graph = fromEdges (List.map (e => (e.from, e.to)) allEdges)
  { graph: graph, capacities: List.foldl (caps e => Map.insert { from: e.from, to: e.to } e.cap caps) Map.empty allEdges }
}

// BFS to find augmenting path using foldl for neighbor exploration
bfs = residual source sink =>
  bfsVisit residual sink (Queue.enqueue source Queue.empty) (Set.insert source Set.empty) Map.empty

bfsVisit = residual sink q visited parents => (Queue.dequeue q) match
  | None               => None
  | Some (current, q2) =>
    if current == sink then
      Some parents
    else {
      edges = edgesFrom residual.graph current
      (q3, visited3, parents3) = List.foldl ((q0, vis, par) edge => {
        next = edge.to
        cap = getOrZero { from: current, to: next } residual.capacities
        if cap > 0.0 && !(Set.has next vis) then
          (Queue.enqueue next q0, Set.insert next vis, Map.insert next current par)
        else
          (q0, vis, par)
      }) (q2, visited, parents) edges
          bfsVisit residual sink q3 visited3 parents3
    }

// Reconstruct path from parents map
reconstruct : Map Int Int -> Int -> Int -> List Int -> List Int
reconstruct = parents sink source acc =>
  if sink == source then [source, ...acc]
  else (Map.get sink parents) match
    | Some prev => reconstruct parents prev source [sink, ...acc]
    | None      => []

// Calculate bottleneck capacity along path
pathCapacity : Residual -> List Int -> Float
pathCapacity = residual path => path match
  | []              => 0.0
  | [_]             => bigCap
  | [a, b, ...rest] => {
    cap = getOrZero { from: a, to: b } residual.capacities
    restCap = pathCapacity residual [b, ...rest]
    if cap < restCap then cap else restCap
  }

// Update capacities along path
updatePath = residual path delta =>
  residual <| { capacities: updatePathGo delta path residual.capacities }

updatePathGo = delta nodes caps => nodes match
  | []              => caps
  | [_]             => caps
  | [a, b, ...rest] => {
    forward = getOrZero { from: a, to: b } caps
    backward = getOrZero { from: b, to: a } caps
    updated =
    caps
    |> Map.insert { from: a, to: b } (forward - delta)
    |> Map.insert { from: b, to: a } (backward + delta)
    updatePathGo delta [b, ...rest] updated
  }

// Main augmenting path loop
augment = residual source sink parents total => {
  path = reconstruct parents sink source []
  delta = pathCapacity residual path
  if delta == 0.0 then (total, residual)
  else (total + delta, updatePath residual path delta)
}

// Edmonds-Karp max flow algorithm
maxFlow : List Edge -> Int -> Int -> (Float, Residual)
maxFlow = edges source sink => maxFlowGo (buildResidual edges) source sink 0.0

maxFlowGo = state source sink total => bfs state source sink match
  | None         => (total, state)
  | Some parents => {
    (newTotal, updated) = augment state source sink parents total
    maxFlowGo updated source sink newTotal
  }

@test
maxFlowTest = do Effect {
  edges = [
    { from: 0, to: 1, cap: 16.0 }
    { from: 0, to: 2, cap: 13.0 }
    { from: 1, to: 2, cap: 10.0 }
    { from: 2, to: 1, cap: 4.0 }
    { from: 1, to: 3, cap: 12.0 }
    { from: 3, to: 2, cap: 9.0 }
    { from: 2, to: 4, cap: 14.0 }
    { from: 4, to: 3, cap: 7.0 }
    { from: 3, to: 5, cap: 20.0 }
    { from: 4, to: 5, cap: 4.0 }
  ]

  (flow, _) = maxFlow edges 0 5
  assert (flow == 23.0)

  (zeroFlow, _) = maxFlow [] 0 1
  assert (zeroFlow == 0.0)
}
