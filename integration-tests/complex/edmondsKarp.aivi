@no_prelude
module integrationTests.complex.EdmondsKarp

use aivi
use aivi.testing
use aivi.collections
use aivi.graph (Graph, fromEdges, edgesFrom)

// Edge with capacity
Edge = { from: Int, to: Int, cap: Float }

// Residual key for capacity lookup
ResidualKey = { from: Int, to: Int }

// Residual network state
Residual = {
  graph: Graph
  capacities: Map ResidualKey Float
}

// Get capacity or 0 from map
getOrZero = key map => Map.getOrElse key 0.0 map

append = xs ys => xs ?
  | []        => ys
  | [h, ...t] => [h, ...append t ys]

backwardEdges = _ ?
  | []           => []
  | [e, ...rest] => [{ from: e.to, to: e.from, cap: 0.0 }, ...backwardEdges rest]

edgePairs = _ ?
  | []           => []
  | [e, ...rest] => [(e.from, e.to), ...edgePairs rest]

bigCap : Float
bigCap = 1000000000.0

// Build residual network from edges
buildResidual : List Edge -> Residual
buildResidual = edges => {
  backward = backwardEdges edges
  allEdges = append edges backward
  graph = fromEdges (edgePairs allEdges)

  { graph: graph, capacities: insertCaps allEdges Map.empty }
}

insertCaps = items caps => items ?
  | []           => caps
  | [e, ...rest] => insertCaps rest (Map.insert { from: e.from, to: e.to } e.cap caps)

// BFS to find augmenting path
bfs = residual source sink =>
  bfsVisit residual sink (Queue.enqueue source Queue.empty) (Set.insert source Set.empty) Map.empty

bfsVisit = residual sink q visited parents => (Queue.dequeue q) ?
  | None               => None
  | Some (current, q2) =>
    if current == sink then
      Some parents
    else {
      edges = edgesFrom residual.graph current
      (q3, visited3, parents3) = bfsExplore residual current edges q2 visited parents
      bfsVisit residual sink q3 visited3 parents3
    }

bfsExplore = residual current edges q visited parents => edges ?
  | []              => (q, visited, parents)
  | [edge, ...tail] => {
    next = edge.to
    cap = getOrZero { from: current, to: next } residual.capacities
    if cap > 0.0 && Set.has next visited == False then
      bfsExplore residual current tail (Queue.enqueue next q) (Set.insert next visited) (Map.insert next current parents)
    else
      bfsExplore residual current tail q visited parents
  }

// Reconstruct path from parents map
reconstruct : Map Int Int -> Int -> Int -> List Int -> List Int
reconstruct = parents sink source acc => {
  if sink == source then
    [source, ...acc]
  else
    (Map.get sink parents) ?
      | Some prev => reconstruct parents prev source [sink, ...acc]
      | None      => []
}

// Calculate bottleneck capacity along path
pathCapacity : Residual -> List Int -> Float
pathCapacity = residual path => pathCapacityGo residual path

pathCapacityGo : Residual -> List Int -> Float
pathCapacityGo = residual path => path ?
  | []              => 0.0
  | [_]             => bigCap
  | [a, b, ...rest] => {
    cap = getOrZero { from: a, to: b } residual.capacities
    restCap = pathCapacityGo residual [b, ...rest]
    if cap < restCap then cap else restCap
  }

// Update capacities along path
updatePath = residual path delta => {
  residual <| { capacities: updatePathGo delta path residual.capacities }
}

updatePathGo = delta nodes caps => nodes ?
  | []              => caps
  | [_]             => caps
  | [a, b, ...rest] => updatePathGo delta [b, ...rest] (updatePathApply delta a b caps)

updatePathApply = delta from to caps => {
  forward = getOrZero { from: from, to: to } caps
  backward = getOrZero { from: to, to: from } caps
  caps
  |> Map.insert { from: from, to: to } (forward - delta)
  |> Map.insert { from: to, to: from } (backward + delta)
}

// Main augmenting path loop
augment = residual source sink parents total => {
  path = reconstruct parents sink source []
  delta = pathCapacity residual path
  if delta == 0.0 then (total, residual)
  else (total + delta, updatePath residual path delta)
}

// Edmonds-Karp max flow algorithm
maxFlow : List Edge -> Int -> Int -> (Float, Residual)
maxFlow = edges source sink => maxFlowGo (buildResidual edges) source sink 0.0

maxFlowGo = state source sink total => bfs state source sink ?
  | None         => (total, state)
  | Some parents => {
    (newTotal, updated) = augment state source sink parents total
    maxFlowGo updated source sink newTotal
  }

  @test
maxFlowTest = effect {
  edges = [
    { from: 0, to: 1, cap: 16.0 }
    { from: 0, to: 2, cap: 13.0 }
    { from: 1, to: 2, cap: 10.0 }
    { from: 2, to: 1, cap: 4.0 }
    { from: 1, to: 3, cap: 12.0 }
    { from: 3, to: 2, cap: 9.0 }
    { from: 2, to: 4, cap: 14.0 }
    { from: 4, to: 3, cap: 7.0 }
    { from: 3, to: 5, cap: 20.0 }
    { from: 4, to: 5, cap: 4.0 }
  ]

  (flow, _) = maxFlow edges 0 5
  _ <- assert (flow == 23.0)

  (zeroFlow, _) = maxFlow [] 0 1
  _ <- assert (zeroFlow == 0.0)
}
