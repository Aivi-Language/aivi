@no_prelude
module integrationTests.complex.TopologicalSort

use aivi
use aivi.testing
use aivi.collections

// Type alias for adjacency list graph
Graph = { nodes: List Int, adj: Map Int (List Int) }

// Get neighbors of a node
neighbors = node graph => Map.get node graph.adj ?
  | Some ns => ns
  | None    => []

// Build initial indegree map
buildIndegree = graph => {
  // Start with all nodes having 0 indegree
  init = List.foldl graph.nodes Map.empty (acc node => Map.insert node 0 acc)
  // Count incoming edges for each node
  List.foldl graph.nodes init (acc u =>
    List.foldl (neighbors u graph) acc (acc2 v =>
      Map.insert v ((Map.get v acc2 ? | Some n => n | None => 0) + 1) acc2
    )
  )
}

// Get initial queue of nodes with indegree 0
initialQueue = indegree graph =>
  List.filter graph.nodes (node => (Map.get node indegree ? | Some 0 => True | _ => False))

// Process neighbors, reducing their indegree
processNeighbors = neighbors indegree queue => neighbors ?
  | []           => (indegree, queue)
  | [n, ...tail] => {
      remaining = (Map.get n indegree ? | Some v => v - 1 | None => 0)
      updated = Map.insert n remaining indegree
      newQueue = if remaining == 0 then [n, ...queue] else queue
      processNeighbors tail updated newQueue
  }

// Main sorting loop using Kahn's algorithm
sortLoop = graph queue indegree order => queue ?
  | [] =>
      if List.length order == List.length graph.nodes then
        Ok order
    else {
  // Find nodes still with positive indegree (cycle)
        cycleNodes = List.filter graph.nodes (n =>
        (Map.get n indegree ? | Some d when d > 0 => True | _ => False)
        )
        Err cycleNodes
    }
| [current, ...rest] => {
    edges = neighbors current graph
    (nextIndegree, nextQueue) = processNeighbors edges indegree rest
    sortLoop graph nextQueue nextIndegree [current, ...order]
}

// Topological sort entry point
  topologicalSort : Graph -> Result (List Int) (List Int)
  topologicalSort = graph => {
      indegree = buildIndegree graph
      queue = initialQueue indegree graph
      sortLoop graph queue indegree []
  }

  @test
  topoSmoke = effect {
      adj = ~map{
          0 => [1, 2]
          1 => [3]
          2 => [3]
          3 => []
      }
      graph = { nodes: [0, 1, 2, 3], adj: adj }

      result = topologicalSort graph
      _ <- assert (result == Ok [3, 2, 1, 0] || result == Ok [3, 1, 2, 0])

  // Test cyclic graph detection
      cyclicAdj = ~map{ 0 => [1], 1 => [0] }
      cyclicGraph = { nodes: [0, 1], adj: cyclicAdj }
      cycle = topologicalSort cyclicGraph
      _ <- assert (cycle == Err [0, 1] || cycle == Err [1, 0])
  }
