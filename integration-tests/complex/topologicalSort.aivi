@no_prelude
module integrationTests.complex.TopologicalSort

use aivi
use aivi.testing
use aivi.collections

// Type alias for adjacency list graph
Graph = { nodes: List Int, adj: Map Int (List Int) }

// Get neighbors of a node
neighbors = node graph => Map.get node graph.adj match
  | Some ns => ns
  | None    => []

reverseList = xs => List.foldl (acc x => [x, ...acc])[] xs

buildIndegree : Graph -> Map Int Int
buildIndegree = graph => {
  zeros = List.foldl (acc n => Map.insert n 0 acc) Map.empty graph.nodes
  List.foldl (acc u => List.foldl (ind n => Map.insert n (Map.getOrElse n 0 ind + 1) ind) acc (neighbors u graph)) zeros graph.nodes
}

enqueueZero = nodes indeg q =>
  List.foldl (q2 n => if Map.getOrElse n 0 indeg == 0 then Queue.enqueue n q2 else q2) q nodes

relax = ns indeg q =>
  List.foldl (state n => {
      next = Map.getOrElse n 0 state.indeg - 1
      {
        indeg: Map.insert n next state.indeg
        q: if next == 0 then Queue.enqueue n state.q else state.q
      }
  }) { indeg: indeg, q: q } ns

cycleNodes = nodes indeg =>
  nodes
|> List.foldl (acc n => if Map.getOrElse n 0 indeg > 0 then [n, ...acc] else acc)[]
|> reverseList

sortLoop = graph indeg q outRev => (Queue.dequeue q) match
  | None => {
      out = reverseList outRev
      if List.length out == List.length graph.nodes then Ok out else Err (cycleNodes graph.nodes indeg)
    }
  | Some (node, q2) => {
      res = relax (neighbors node graph) indeg q2
      sortLoop graph res.indeg res.q [node, ...outRev]
    }

topologicalSort : Graph -> Result (List Int) (List Int)
topologicalSort = graph => {
  indeg = buildIndegree graph
  q0 = enqueueZero graph.nodes indeg Queue.empty
  sortLoop graph indeg q0 []
}

@test "Kahn topological sort"
topoSmoke = do Effect {
  adj = ~map{
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []
  }
  graph = { nodes: [0, 1, 2, 3], adj: adj }

  result <- pure (topologicalSort graph)
  assert (result == Ok [0, 1, 2, 3] || result == Ok [0, 2, 1, 3])

  // Test cyclic graph detection
  cyclicAdj = ~map{ 0 => [1], 1 => [0] }
  cyclicGraph = { nodes: [0, 1], adj: cyclicAdj }
  cycle <- pure (topologicalSort cyclicGraph)
  assert (cycle == Err [0, 1] || cycle == Err [1, 0])
}
