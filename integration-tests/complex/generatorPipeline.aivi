@no_prelude
module integrationTests.complex.generatorPipeline

use aivi
use aivi.testing
use aivi.generator
use aivi.collections

// --- Pure helpers ---

reverseList = xs => List.foldl (acc x => [x, ...acc]) [] xs

// Trial-division primality (pure)
isPrime = n =>
  n > 1 && primeCheck n 2

primeCheck = n d =>
  if d * d > n then True
  else if n % d == 0 then False
  else primeCheck n (d + 1)

// Bounded Fibonacci list built by recursion, then lifted into a generator
fibListAcc = a b limit acc =>
  if a > limit then reverseList acc
  else fibListAcc b (a + b) limit [a, ...acc]

fibsUpTo = limit => fromList (fibListAcc 0 1 limit [])

// Running-total scan over a list using List.foldl
scanTotals = xs =>
  reverseList
  (List.foldl (state x => { sum: state.sum + x, acc: [state.sum + x, ...state.acc] })
    { sum: 0, acc: [] }
    xs).acc

@test "bounded fibonacci via generator"
generatorFibs = do Effect {
  fibs = toList (fibsUpTo 20)
  assertEq fibs [0, 1, 1, 2, 3, 5, 8, 13, 21]
}

@test "prime sieve via range + guard filter"
generatorPrimes = do Effect {
  primes = generate {
    n <- range 2 20
    n -> isPrime n
    yield n
  }
  assertEq (toList primes) [2, 3, 5, 7, 11, 13, 17, 19]
}

@test "map and filter pipeline on generator"
generatorMapFilter = do Effect {
  // Even squares from 1..10
  result = generate {
    n <- range 1 11
    n -> n % 2 == 0
    yield (n * n)
  }
  assertEq (toList result) [4, 16, 36, 64, 100]
}

@test "cartesian product via generator bind"
generatorCartesian = do Effect {
  pairs = generate {
    x <- fromList [1, 2, 3]
    y <- fromList [10, 20]
    yield (x * y)
  }
  assertEq (toList pairs) [10, 20, 20, 40, 30, 60]
}

@test "generator foldl for running totals"
generatorScan = do Effect {
  // Sum of 1..5 = 15; verify via foldl
  total = foldl (acc x => acc + x) 0 (range 1 6)
  assertEq total 15

  // Running totals of [1, 2, 3, 4, 5] should be [1, 3, 6, 10, 15]
  totals = scanTotals [1, 2, 3, 4, 5]
  assertEq totals [1, 3, 6, 10, 15]
}

@test "generator pipeline: fibs filtered to primes"
generatorFibPrimes = do Effect {
  // Fibonacci numbers up to 100 that are also prime
  fibPrimes = generate {
    n <- fibsUpTo 100
    n -> isPrime n
    yield n
  }
  // Fib primes <= 100: 2, 3, 5, 13, 89
  assertEq (toList fibPrimes) [2, 3, 5, 13, 89]
}

@test "loop recurse inside generate"
generatorLoopRecurse = do Effect {
  // Collatz sequence from 6 until reaching 1
  collatz = generate {
    loop n = 6 => {
      yield n
      if n == 1 then {}
      else if n % 2 == 0 then recurse (n / 2)
      else recurse (n * 3 + 1)
    }
  }
  assertEq (toList collatz) [6, 3, 10, 5, 16, 8, 4, 2, 1]
}
