@no_prelude
module integrationTests.complex.AStar

use aivi
use aivi.testing
use aivi.collections
use aivi.graph
use aivi.vector

positions =
  Map.insert 0 ((0.0, 0.0) v2) Map.empty
|> Map.insert 1 ((1.0, 0.0) v2)
|> Map.insert 2 ((2.0, 1.0) v2)
|> Map.insert 3 ((3.0, 0.0) v2)

heuristic = goal node => (Map.get goal positions, Map.get node positions) ?
  | (Some target, Some current) => magnitude (target - current)
  | _                           => 0.0

reconstruct = came node => {
    go = current acc => (Map.get current came) ?
      | Some prev => go prev [current, ...acc]
      | None      => [current, ...acc]

  go node []
}

expandNeighbors = edges queue scores parents current currentG goal heuristicFunc => edges ?
  | []              => (queue, scores, parents)
  | [edge, ...tail] => {
      tentative = currentG + edge.weight
    prevScore =
      (Map.get edge.to scores) ?
        | Some v => v
        | None   => 1_000_000.0

  res =
    if tentative < prevScore then
      (
      Heap.push queue (tentative + heuristicFunc goal edge.to, edge.to, tentative),
      Map.insert edge.to tentative scores,
      Map.insert edge.to current parents
    )
    else
      (queue, scores, parents)

  (nextQueue, nextScores, nextParents) = res
  expandNeighbors tail nextQueue nextScores nextParents current currentG goal heuristicFunc
}

search = queue scores parents graph goal heuristicFunc => Heap.popMin queue ?
  | None                                => None
  | Some ((_, current, currentG), rest) =>
    if current == goal then
      Some (reconstruct parents goal)
    else {
      edges = edgesFrom graph current
      (nextQueue, nextScores, nextParents) =
      expandNeighbors edges rest scores parents current currentG goal heuristicFunc
      search nextQueue nextScores nextParents graph goal heuristicFunc
    }

astar = graph start goal heuristicFunc => {
    openSet = Heap.push Heap.empty (heuristicFunc goal start, start, 0.0)
  scores = Map.insert start 0.0 Map.empty
  search openSet scores Map.empty graph goal heuristicFunc
}

buildGraph = {
  weighted = [
    (0, 1, 1.0)
    (0, 2, 4.0)
    (1, 2, 2.0)
    (1, 3, 5.0)
    (2, 3, 1.0)
  ]

  fromWeightedEdges weighted
}

@test
astarSmoke =
  effect {
    graph = buildGraph
    _ <- assert (astar graph 0 3 heuristic == Some [0, 1, 2, 3])

    zeroHeuristic = _ _ => 0.0
    _ <- assert (astar graph 0 3 zeroHeuristic == Some [0, 1, 2, 3])

    bad = astar graph 3 0 zeroHeuristic
    _ <- assert (bad == None)
  }
