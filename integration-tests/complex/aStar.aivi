@no_prelude
module integrationTests.complex.AStar

use aivi
use aivi.testing (assert)

type Edge = { to: Int, cost: Int }
type Graph = Map Int (List Edge)
type QueueItem = { node: Int, g: Int, f: Int }

takeMin = queue =>
  queue ?
    | [] => None
    | [item] => Some (item, [])
    | [head, ...tail] =>
        (best, rest) = takeMin tail
        if head.f <= best.f then Some (head, [best, ...rest]) else Some (best, [head, ...rest])

reconstruct = (cameFrom, current) =>
  (Map.get current cameFrom) ?
    | Some prev => reconstruct (cameFrom, prev) ++ [current]
    | None => [current]

aStar = (graph, start, goal, heuristic) =>
  openSet = [{ node: start, g: 0, f: heuristic start }]
  gScore = Map.insert start 0 Map.empty
  cameFrom = Map.empty
  closed = Set.empty
  loop = (queue, scores, parents, visited) =>
    queue ?
      | [] => None
      | _ =>
          (current, rest) = takeMin queue ? | None => (None, []) | Some value => value
          item = current
          if item.node == goal then Some (reconstruct (parents, goal))
          else if Set.has item.node visited then loop (rest, scores, parents, visited)
          else
            neighbors = (Map.get item.node graph) ? | Some list => list | None => []
            (newQueue, newScores, newParents) =
              neighbors ?
                | [] => (rest, scores, parents)
                | [edge, ...tail] =>
                    tentG = item.g + edge.cost
                    prevG = (Map.get edge.to scores) ? | Some v => v | None => INF
                    already = Set.has edge.to visited
                    (queue', scores', parents') =
                      if (tentG < prevG) && !already then
                        q' = [...rest, { node: edge.to, g: tentG, f: tentG + heuristic edge.to }]
                        (q', Map.insert edge.to tentG scores, Map.insert edge.to item.node parents)
                      else (rest, scores, parents)
                    loop (q', scores', parents', Set.insert item.node visited)
            newQueue
  loop (openSet, gScore, cameFrom, closed)

@test
heuristicZero = _ => 0

graphSample =
  Map.insert 0 [{ to: 1, cost: 1 }, { to: 2, cost: 4 }] Map.empty
  |> Map.insert 1 [{ to: 2, cost: 2 }, { to: 3, cost: 5 }] Map.empty
  |> Map.insert 2 [{ to: 3, cost: 1 }] Map.empty

testPath = effect {
  path = aStar graphSample 0 3 (node => if node == 3 then 0 else 1)
  _ <- assert (path == Some [0, 1, 2, 3])

  dijkstraPath = aStar graphSample 0 3 heuristicZero
  _ <- assert (dijkstraPath == Some [0, 1, 2, 3])

  noPath = aStar graphSample 3 0 heuristicZero
  _ <- assert (noPath == None)
}
