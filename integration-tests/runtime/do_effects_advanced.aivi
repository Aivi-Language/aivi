@no_prelude
module integrationTests.runtime.doEffectsAdvanced

use aivi
use aivi.testing

// --- do Option nested ---

@test "do option nested binds"
doOptionNested = do Effect {
  result = do Option {
    a <- Some 10
    b <- Some 20
    c <- Some 12
    Some (a + b + c)
  }
  assertEq result (Some 42)
}

@test "do option short-circuits on first none"
doOptionShortCircuitFirst = do Effect {
  result = do Option {
    a <- None
    b <- Some 20
    Some (a + b)
  }
  assertEq result None
}

// --- do Result nested ---

@test "do result nested binds"
doResultNested = do Effect {
  result = do Result {
    a <- Ok 10
    b <- Ok 20
    Ok (a + b)
  }
  assertEq result (Ok 30)
}

@test "do result short-circuits on err"
doResultShortCircuit = do Effect {
  result = do Result {
    a <- Ok 10
    b <- Err "nope"
    Ok (a + b)
  }
  assertEq result (Err "nope")
}

// --- do List (cartesian) ---

@test "do list cartesian product"
doListCartesian = do Effect {
  result = do List {
    x <- [1, 2]
    y <- [10, 20]
    [x + y]
  }
  assertEq result [11, 21, 12, 22]
}

// --- attempt and error recovery ---

@test "attempt catches failure"
attemptCatches = do Effect {
  res <- attempt (fail "oops")
  res match
    | Ok _  => fail "unexpected ok"
    | Err e => assertEq e "oops"
}

@test "attempt wraps success"
attemptSuccess = do Effect {
  res <- attempt (pure 42)
  res match
    | Ok v  => assertEq v 42
    | Err _ => fail "unexpected err"
}

// --- given precondition ---

validatePositive = n => do Effect {
  given n > 0 or fail "must be positive"
  pure n
}

@test "given passes on valid input"
givenPasses = do Effect {
  res <- attempt (validatePositive 5)
  res match
    | Ok v  => assertEq v 5
    | Err _ => fail "unexpected error"
}

@test "given fails on invalid input"
givenFails = do Effect {
  res <- attempt (validatePositive (-1))
  res match
    | Err e => assertEq e "must be positive"
    | Ok _  => fail "should have failed"
}
