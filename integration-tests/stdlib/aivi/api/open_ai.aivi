@no_prelude
module integrationTests.stdlib.aivi.api.openAi.tests

use aivi
use aivi.testing
use aivi.list (map, length, filter)
use aivi.math (sum, sqrt)

// ─── Types (mirror aivi.api.openai) ───────────────────────────────────────────

ApiKey = Text!

ModelId = Text!

Client = {
  apiKey: ApiKey
  baseUrl: Text
  timeoutMs: Int
}

ApiError = {
  code: Option Text
  message: Text
  param: Option Text
  kind: Text
}

Usage = {
  promptTokens: Int
  completionTokens: Int
  totalTokens: Int
}

Page A = {
  object: Text
  data: List A
  firstId: Option Text
  lastId: Option Text
  hasMore: Bool
}

// ─── Chat ─────────────────────────────────────────────────────────────────────

ChatRole = System | User | Assistant | Tool | Developer

Message = {
  role: ChatRole
  content: Text
  name: Option Text
}

FinishReason = Stop | Length | ToolCalls | ContentFilter | FunctionCall

ResponseMessage = {
  role: Text
  content: Option Text
  refusal: Option Text
}

Choice = {
  index: Int
  message: ResponseMessage
  finishReason: FinishReason
}

ReasoningEffort = EffortLow | EffortMedium | EffortHigh

ChatRequest = {
  model: ModelId
  messages: List Message
  maxTokens: Option Int
  temperature: Option Float
  topP: Option Float
  n: Option Int
  stop: Option (List Text)
  presencePenalty: Option Float
  frequencyPenalty: Option Float
  seed: Option Int
  user: Option Text
  reasoningEffort: Option ReasoningEffort
}

ChatResponse = {
  id: Text
  object: Text
  created: Int
  model: Text
  choices: List Choice
  usage: Usage
  systemFingerprint: Option Text
}

// ─── Models ───────────────────────────────────────────────────────────────────

Model = {
  id: Text
  object: Text
  created: Int
  ownedBy: Text
}

DeleteResult = {
  id: Text
  object: Text
  deleted: Bool
}

// ─── Embeddings ───────────────────────────────────────────────────────────────

EmbeddingInput = SingleText Text | MultiText (List Text)

EncodingFormat = FloatFormat | Base64Format

EmbeddingRequest = {
  model: ModelId
  input: EmbeddingInput
  encodingFormat: Option EncodingFormat
  dimensions: Option Int
  user: Option Text
}

EmbeddingObject = {
  index: Int
  embedding: List Float
  object: Text
}

EmbeddingUsage = {
  promptTokens: Int
  totalTokens: Int
}

EmbeddingResponse = {
  object: Text
  model: Text
  data: List EmbeddingObject
  usage: EmbeddingUsage
}

// ─── Images ───────────────────────────────────────────────────────────────────

ImageSize = SizeAuto | Square256 | Square512 | Square1024 | Landscape1792 | Portrait1792 | Landscape1536 | Portrait1536

ImageQuality = QualityAuto | Standard | Hd | Low | Medium | High

ImageStyle = Vivid | Natural

ImageResponseFormat = UrlFormat | B64JsonFormat

ImageRequest = {
  prompt: Text
  model: Option ModelId
  n: Option Int
  size: Option ImageSize
  quality: Option ImageQuality
  style: Option ImageStyle
  responseFormat: Option ImageResponseFormat
  user: Option Text
}

GeneratedImage = {
  url: Option Text
  b64Json: Option Text
  revisedPrompt: Option Text
}

ImageResponse = {
  created: Int
  data: List GeneratedImage
}

// ─── Audio ────────────────────────────────────────────────────────────────────

Voice = Alloy | Ash | Ballad | Coral | Echo | Fable | Nova | Onyx | Sage | Shimmer

AudioFormat = Mp3 | Opus | Aac | Flac | Wav | Pcm

SpeechRequest = {
  model: ModelId
  input: Text
  voice: Voice
  responseFormat: Option AudioFormat
  speed: Option Float
}

TranscriptionRequest = {
  model: ModelId
  language: Option Text
  prompt: Option Text
  temperature: Option Float
}

Transcription = { text: Text }

// ─── Helpers ──────────────────────────────────────────────────────────────────

gpt4o : ModelId
gpt4o = ModelId "gpt-4o"

gpt4oMini : ModelId
gpt4oMini = ModelId "gpt-4o-mini"

gpt41 : ModelId
gpt41 = ModelId "gpt-4.1"

o3 : ModelId
o3 = ModelId "o3"

o4Mini : ModelId
o4Mini = ModelId "o4-mini"

textEmbedding3Small : ModelId
textEmbedding3Small = ModelId "text-embedding-3-small"

textEmbedding3Large : ModelId
textEmbedding3Large = ModelId "text-embedding-3-large"

dallE3 : ModelId
dallE3 = ModelId "dall-e-3"

tts1 : ModelId
tts1 = ModelId "tts-1"

whisper1 : ModelId
whisper1 = ModelId "whisper-1"

client : ApiKey -> Client
client = apiKey => {
  apiKey
  baseUrl: "https://api.openai.com/v1"
  timeoutMs: 30000
}

userMsg : Text -> Message
userMsg = content => { role: User, content, name: None }

systemMsg : Text -> Message
systemMsg = content => { role: System, content, name: None }

assistantMsg : Text -> Message
assistantMsg = content => { role: Assistant, content, name: None }

namedMsg : ChatRole -> Text -> Text -> Message
namedMsg = role name content => { role, content, name: Some name }

minimalChatRequest : ModelId -> List Message -> ChatRequest
minimalChatRequest = model messages => {
  model
  messages
  maxTokens: None
  temperature: None
  topP: None
  n: None
  stop: None
  presencePenalty: None
  frequencyPenalty: None
  seed: None
  user: None
  reasoningEffort: None
}

withTemperature : Float -> ChatRequest -> ChatRequest
withTemperature = t req => req <| { temperature: Some t }

withMaxTokens : Int -> ChatRequest -> ChatRequest
withMaxTokens = n req => req <| { maxTokens: Some n }

withSeed : Int -> ChatRequest -> ChatRequest
withSeed = s req => req <| { seed: Some s }

extractText : ChatResponse -> Option Text
extractText = resp => resp.choices match
  | [{ message: { content }, _ }, ..._] => content
  | _                                   => None

// Embedding dimension helper (pure structure check, no Float arithmetic needed)
embeddingDim : List Float -> Int
embeddingDim = xs => length xs

reasoningEffortToText : ReasoningEffort -> Text
reasoningEffortToText = e => e match
  | EffortLow    => "low"
  | EffortMedium => "medium"
  | EffortHigh   => "high"

// ─── Mock data ────────────────────────────────────────────────────────────────

mockApiKey : ApiKey
mockApiKey = ApiKey "sk-test-0000000000000000000000000000000000000000000000000"

mockClient : Client
mockClient = client mockApiKey

mockUsage : Usage
mockUsage = { promptTokens: 20, completionTokens: 10, totalTokens: 30 }

mockResponseMessage : ResponseMessage
mockResponseMessage = { role: "assistant", content: Some "Hello! How can I help?", refusal: None }

mockChoice : Choice
mockChoice = { index: 0, message: mockResponseMessage, finishReason: Stop }

mockChatResponse : ChatResponse
mockChatResponse =
  {
    id: "chatcmpl-abc123"
    object: "chat.completion"
    created: 1741570283
    model: "gpt-4o-2024-08-06"
    choices: [mockChoice]
    usage: mockUsage
    systemFingerprint: Some "fp_abc123"
  }

mockModel : Model
mockModel = { id: "gpt-4o", object: "model", created: 1686935002, ownedBy: "openai" }

mockModelPage : Page Model
mockModelPage =
  {
    object: "list"
    data: [mockModel, { id: "gpt-4o-mini", object: "model", created: 1686935003, ownedBy: "openai" }]
    firstId: Some "gpt-4o"
    lastId: Some "gpt-4o-mini"
    hasMore: False
  }

mockEmbeddingVec : List Float
mockEmbeddingVec = [0.0023, -0.0093, 0.0181, -0.0028, 0.0061]

mockEmbeddingObj : EmbeddingObject
mockEmbeddingObj = { index: 0, embedding: mockEmbeddingVec, object: "embedding" }

mockEmbeddingResponse : EmbeddingResponse
mockEmbeddingResponse =
  {
    object: "list"
    model: "text-embedding-3-small"
    data: [mockEmbeddingObj]
    usage: { promptTokens: 5, totalTokens: 5 }
  }

mockImage : GeneratedImage
mockImage =
  {
    url: Some "https://oaidalleapiprodscus.blob.core.windows.net/private/img-abc.png"
    b64Json: None
    revisedPrompt: Some "A photorealistic red robot on Mars."
  }

mockImageResponse : ImageResponse
mockImageResponse = { created: 1741570283, data: [mockImage] }

// ─── Tests: Client construction ───────────────────────────────────────────────

@test "client holds api key"
clientHoldsApiKey = do Effect {
  assertEq mockClient.apiKey mockApiKey
}

@test "client default base url"
clientDefaultBaseUrl = do Effect {
  assertEq mockClient.baseUrl "https://api.openai.com/v1"
}

@test "client default timeout"
clientDefaultTimeout = do Effect {
  assertEq mockClient.timeoutMs 30000
}

@test "client can be patched to custom timeout"
clientCustomTimeout = do Effect {
  slow = mockClient <| { timeoutMs: 60000 }
  assertEq slow.timeoutMs 60000
}

// ─── Tests: ModelId branding ──────────────────────────────────────────────────

@test "ModelId wraps text"
modelIdWrapsText = do Effect {
  id = ModelId "gpt-4o"
  assertEq id gpt4o
}

@test "known model constants are distinct"
modelConstantsDistinct = do Effect {
  assertEq (gpt4o == gpt4oMini) False
  assertEq (gpt41 == o3) False
  assertEq (textEmbedding3Small == textEmbedding3Large) False
}

@test "model id can be compared"
modelIdComparison = do Effect {
  assertEq gpt4o (ModelId "gpt-4o")
  assertEq dallE3 (ModelId "dall-e-3")
}

// ─── Tests: Message helpers ───────────────────────────────────────────────────

@test "userMsg sets role and content"
userMsgFields = do Effect {
  msg = userMsg "What is AIVI?"
  assertEq msg.role User
  assertEq msg.content "What is AIVI?"
  assertEq msg.name None
}

@test "systemMsg sets role and content"
systemMsgFields = do Effect {
  msg = systemMsg "You are a helpful assistant."
  assertEq msg.role System
  assertEq msg.content "You are a helpful assistant."
}

@test "assistantMsg sets role"
assistantMsgFields = do Effect {
  msg = assistantMsg "I am here to help."
  assertEq msg.role Assistant
  assertEq msg.content "I am here to help."
}

@test "namedMsg includes name"
namedMsgFields = do Effect {
  msg = namedMsg User "Alice" "Hello!"
  assertEq msg.name (Some "Alice")
  assertEq msg.role User
}

// ─── Tests: ChatRequest construction ─────────────────────────────────────────

@test "minimalChatRequest fills all optional fields with None"
minimalRequestDefaults = do Effect {
  req = minimalChatRequest gpt4o [userMsg "Hi"]
  assertEq req.model gpt4o
  assertEq (length req.messages) 1
  assertEq req.temperature None
  assertEq req.maxTokens None
  assertEq req.n None
  assertEq req.stop None
  assertEq req.presencePenalty None
  assertEq req.frequencyPenalty None
  assertEq req.seed None
  assertEq req.user None
  assertEq req.reasoningEffort None
}

@test "withTemperature patches temperature"
withTemperaturePatches = do Effect {
  base = minimalChatRequest gpt4o [userMsg "Hi"]
  req = withTemperature 0.3 base
  assertEq req.temperature (Some 0.3)
  assertEq req.model gpt4o
}

@test "withMaxTokens patches max tokens"
withMaxTokensPatches = do Effect {
  base = minimalChatRequest gpt4oMini [systemMsg "sys"]
  req = withMaxTokens 512 base
  assertEq req.maxTokens (Some 512)
}

@test "withSeed patches seed"
withSeedPatches = do Effect {
  base = minimalChatRequest gpt4o [userMsg "test"]
  req = withSeed 42 base
  assertEq req.seed (Some 42)
}

@test "request builders can be chained with pipes"
requestBuilderChaining = do Effect {
  base = minimalChatRequest gpt4o [userMsg "chain test"]
  req = base |> withTemperature 0.8 |> withMaxTokens 1024 |> withSeed 99
  assertEq req.temperature (Some 0.8)
  assertEq req.maxTokens (Some 1024)
  assertEq req.seed (Some 99)
}

// ─── Tests: ChatResponse parsing ─────────────────────────────────────────────

@test "mock chat response has correct id"
chatResponseId = do Effect {
  assertEq mockChatResponse.id "chatcmpl-abc123"
}

@test "mock chat response has correct model"
chatResponseModel = do Effect {
  assertEq mockChatResponse.model "gpt-4o-2024-08-06"
}

@test "mock chat response usage totals match"
chatResponseUsageTotals = do Effect {
  u = mockChatResponse.usage
  assertEq u.totalTokens (u.promptTokens + u.completionTokens)
}

@test "extractText returns first choice content"
extractTextFromResponse = do Effect {
  text = extractText mockChatResponse
  assertEq text (Some "Hello! How can I help?")
}

@test "extractText returns None for empty choices"
extractTextEmptyChoices = do Effect {
  emptyResp = mockChatResponse <| { choices: [] }
  assertEq (extractText emptyResp) None
}

@test "extractText returns None when content is None"
extractTextContentNone = do Effect {
  noContent = mockChatResponse <| { choices: [mockChoice <| { message: { content: None, role: "assistant", refusal: None } }] }
  assertEq (extractText noContent) None
}

// ─── Tests: FinishReason ADT ──────────────────────────────────────────────────

@test "finish reason pattern matching covers all cases"
finishReasonMatching = do Effect {
  label = reason => reason match
    | Stop          => "stop"
    | Length        => "length"
    | ToolCalls     => "tool_calls"
    | ContentFilter => "content_filter"
    | FunctionCall  => "function_call"
    assertEq (label Stop) "stop"
    assertEq (label Length) "length"
    assertEq (label ToolCalls) "tool_calls"
    assertEq (label ContentFilter) "content_filter"
    assertEq (label FunctionCall) "function_call"
}

// ─── Tests: ChatRole ADT ─────────────────────────────────────────────────────

@test "chat roles are distinct"
chatRolesDistinct = do Effect {
  assertEq (User == System) False
  assertEq (Assistant == Tool) False
  assertEq (Developer == User) False
}

@test "filter messages by role"
filterByRole = do Effect {
  msgs =
    [systemMsg "sys"
      userMsg "q1"
      userMsg "q2"
      assistantMsg "ans"
    ]
  userMsgs = filter (m => m.role == User) msgs
  assertEq (length userMsgs) 2
}

// ─── Tests: ReasoningEffort ADT ──────────────────────────────────────────────

@test "reasoning effort values"
reasoningEffortValues = do Effect {
  assertEq (reasoningEffortToText EffortLow) "low"
  assertEq (reasoningEffortToText EffortHigh) "high"
}

// ─── Tests: Models ────────────────────────────────────────────────────────────

@test "mock model has expected fields"
mockModelFields = do Effect {
  assertEq mockModel.id "gpt-4o"
  assertEq mockModel.object "model"
  assertEq mockModel.ownedBy "openai"
}

@test "mock model page contains two models"
mockModelPageLength = do Effect {
  assertEq (length mockModelPage.data) 2
}

@test "model page has hasMore false"
modelPageHasMoreFalse = do Effect {
  assertEq mockModelPage.hasMore False
}

@test "model page cursor ids are present"
modelPageCursorIds = do Effect {
  assertEq mockModelPage.firstId (Some "gpt-4o")
  assertEq mockModelPage.lastId (Some "gpt-4o-mini")
}

@test "can extract model ids from page"
extractModelIds = do Effect {
  ids = map (m => m.id) mockModelPage.data
  assertEq ids ["gpt-4o", "gpt-4o-mini"]
}

@test "delete result has correct shape"
deleteResultShape = do Effect {
  dr = { id: "ft-abc123", object: "model", deleted: True }
  assertEq dr.deleted True
  assertEq dr.id "ft-abc123"
}

// ─── Tests: EmbeddingInput ────────────────────────────────────────────────────

@test "single text embedding input"
singleTextInput = do Effect {
  inp = SingleText "The quick brown fox"
  inp match
    | SingleText t => assertEq t "The quick brown fox"
    | _            => assert False
}

@test "multi text embedding input"
multiTextInput = do Effect {
  inp = MultiText ["foo", "bar", "baz"]
  inp match
    | MultiText ts => assertEq (length ts) 3
    | _            => assert False
}

@test "embedding request construction"
embeddingRequestConstruction = do Effect {
  req =
    {
      model: textEmbedding3Small
      input: SingleText "Hello world"
      encodingFormat: Some FloatFormat
      dimensions: Some 512
      user: None
    }
    assertEq req.model textEmbedding3Small
    assertEq req.dimensions (Some 512)
}

// ─── Tests: EmbeddingResponse ────────────────────────────────────────────────

@test "mock embedding response has one object"
embeddingResponseDataLength = do Effect {
  assertEq (length mockEmbeddingResponse.data) 1
}

@test "embedding object has correct index"
embeddingObjectIndex = do Effect {
  obj = List.head mockEmbeddingResponse.data
  obj match
    | Some e => assertEq e.index 0
    | None   => assert False
}

@test "embedding object has non-empty vector"
embeddingObjectVectorLength = do Effect {
  obj = List.head mockEmbeddingResponse.data
  obj match
    | Some e => assertEq (length e.embedding) 5
    | None   => assert False
}

@test "embedding usage prompt tokens"
embeddingUsagePromptTokens = do Effect {
  assertEq mockEmbeddingResponse.usage.promptTokens 5
  assertEq mockEmbeddingResponse.usage.totalTokens 5
}

// ─── Tests: Cosine similarity ────────────────────────────────────────────────

@test "embedding vector has expected dimension"
embeddingVectorDim = do Effect {
  v = [1.0, 0.0, 0.0]
  assertEq (embeddingDim v) 3
}

@test "embedding vector elements are accessible"
embeddingVectorElements = do Effect {
  v = [0.1, 0.9, 0.2]
  assertEq (length v) 3
}

@test "two embedding vectors can be compared by dimension"
embeddingDimMatch = do Effect {
  a = [0.3, 0.5, 0.8]
  b = [0.1, 0.9, 0.2]
  assertEq (embeddingDim a) (embeddingDim b)
}

// ─── Tests: ImageRequest ─────────────────────────────────────────────────────

@test "image request requires prompt"
imageRequestPrompt = do Effect {
  req =
    {
      prompt: "A red robot on Mars"
      model: Some dallE3
      n: Some 1
      size: Some Square1024
      quality: Some Hd
      style: Some Vivid
      responseFormat: Some UrlFormat
      user: None
    }
    assertEq req.prompt "A red robot on Mars"
    assertEq req.model (Some dallE3)
    assertEq req.quality (Some Hd)
    assertEq req.style (Some Vivid)
}

@test "image request with minimal fields"
imageRequestMinimal = do Effect {
  req =
    {
      prompt: "A landscape"
      model: None
      n: None
      size: None
      quality: None
      style: None
      responseFormat: None
      user: None
    }
    assertEq req.prompt "A landscape"
    assertEq req.model None
}

@test "mock image response has one image"
imageResponseLength = do Effect {
  assertEq (length mockImageResponse.data) 1
}

@test "mock image has url"
mockImageHasUrl = do Effect {
  img = List.head mockImageResponse.data
  img match
    | Some i => assertEq i.url (Some "https://oaidalleapiprodscus.blob.core.windows.net/private/img-abc.png")
    | None   => assert False
}

@test "mock image has revised prompt"
mockImageRevisedPrompt = do Effect {
  img = List.head mockImageResponse.data
  img match
    | Some i => assertEq i.revisedPrompt (Some "A photorealistic red robot on Mars.")
    | None   => assert False
}

@test "image size ADT covers all variants"
imageSizeVariants = do Effect {
  label = s => s match
    | SizeAuto      => "auto"
    | Square256     => "256x256"
    | Square512     => "512x512"
    | Square1024    => "1024x1024"
    | Landscape1792 => "1792x1024"
    | Portrait1792  => "1024x1792"
    | Landscape1536 => "1536x1024"
    | Portrait1536  => "1024x1536"
    assertEq (label Square1024) "1024x1024"
    assertEq (label Landscape1792) "1792x1024"
    assertEq (label SizeAuto) "auto"
}

@test "image quality ADT covers all variants"
imageQualityVariants = do Effect {
  label = q => q match
    | QualityAuto => "auto"
    | Standard    => "standard"
    | Hd          => "hd"
    | Low         => "low"
    | Medium      => "medium"
    | High        => "high"
    assertEq (label Hd) "hd"
    assertEq (label QualityAuto) "auto"
}

// ─── Tests: Speech ────────────────────────────────────────────────────────────

@test "speech request fields"
speechRequestFields = do Effect {
  req =
    {
      model: tts1
      input: "Hello from AIVI!"
      voice: Nova
      responseFormat: Some Mp3
      speed: Some 1.0
    }
    assertEq req.model tts1
    assertEq req.voice Nova
    assertEq req.responseFormat (Some Mp3)
}

@test "voice ADT covers common voices"
voiceAdtVariants = do Effect {
  label = v => v match
    | Alloy   => "alloy"
    | Ash     => "ash"
    | Ballad  => "ballad"
    | Coral   => "coral"
    | Echo    => "echo"
    | Fable   => "fable"
    | Nova    => "nova"
    | Onyx    => "onyx"
    | Sage    => "sage"
    | Shimmer => "shimmer"
    assertEq (label Nova) "nova"
    assertEq (label Alloy) "alloy"
    assertEq (label Shimmer) "shimmer"
}

@test "audio format ADT covers all formats"
audioFormatVariants = do Effect {
  label = f => f match
    | Mp3  => "mp3"
    | Opus => "opus"
    | Aac  => "aac"
    | Flac => "flac"
    | Wav  => "wav"
    | Pcm  => "pcm"
    assertEq (label Mp3) "mp3"
    assertEq (label Wav) "wav"
}

// ─── Tests: Transcription ─────────────────────────────────────────────────────

@test "transcription request fields"
transcriptionRequestFields = do Effect {
  req =
    {
      model: whisper1
      language: Some "en"
      prompt: Some "Transcription of a podcast."
      temperature: Some 0.0
    }
    assertEq req.model whisper1
    assertEq req.language (Some "en")
    assertEq req.temperature (Some 0.0)
}

@test "transcription result has text field"
transcriptionResult = do Effect {
  t = { text: "The quick brown fox jumped over the lazy dog." }
  assertEq t.text "The quick brown fox jumped over the lazy dog."
}

// ─── Tests: ApiError ─────────────────────────────────────────────────────────

@test "api error has required fields"
apiErrorFields = do Effect {
  err =
    {
      code: Some "rate_limit_exceeded"
      message: "Rate limit exceeded. Please retry after 60 seconds."
      param: None
      kind: "requests"
    }
    assertEq err.kind "requests"
    assertEq err.code (Some "rate_limit_exceeded")
    assertEq err.param None
}

@test "api error without code"
apiErrorNoCode = do Effect {
  err = { code: None, message: "Internal server error", param: None, kind: "server_error" }
  assertEq err.code None
}

// ─── Tests: Page pagination ───────────────────────────────────────────────────

@test "page with has_more true signals next page"
pageHasMore = do Effect {
  pg =
    {
      object: "list"
      data: ["a", "b", "c"]
      firstId: Some "a"
      lastId: Some "c"
      hasMore: True
    }
    assertEq pg.hasMore True
    assertEq (length pg.data) 3
}

@test "empty page"
emptyPage = do Effect {
  pg =
    {
      object: "list"
      data: []
      firstId: None
      lastId: None
      hasMore: False
    }
    assertEq pg.hasMore False
    assertEq (length pg.data) 0
}

// ─── Tests: EncodingFormat ───────────────────────────────────────────────────

@test "encoding format variants"
encodingFormatVariants = do Effect {
  label = f => f match
    | FloatFormat  => "float"
    | Base64Format => "base64"
    assertEq (label FloatFormat) "float"
    assertEq (label Base64Format) "base64"
}

// ─── Tests: Conversation building ────────────────────────────────────────────

@test "build a multi-turn conversation"
multiTurnConversation = do Effect {
  conv =
    [systemMsg "You are a coding assistant."
      userMsg "How do I reverse a list in AIVI?"
      assistantMsg "Use `List.reverse xs`."
      userMsg "Thanks! What about sorting?"
    ]
    assertEq (length conv) 4
  roles = map (m => m.role) conv
  assertEq roles [System, User, Assistant, User]
}

@test "conversation messages have correct content"
conversationContent = do Effect {
  conv = [systemMsg "sys", userMsg "user q"]
  firstContent = conv match
    | []          => ""
    | [msg, ..._] => msg.content
    assertEq firstContent "sys"
}

// ─── Tests: Request with stop sequences ─────────────────────────────────────

@test "chat request with stop sequences"
chatRequestStopSequences = do Effect {
  req = minimalChatRequest gpt4o [userMsg "hello"] <| { stop: Some ["STOP", "END"] }
  req.stop match
    | Some ss => assertEq (length ss) 2
    | None    => assert False
}

// ─── Tests: Usage struct ─────────────────────────────────────────────────────

@test "usage totals are consistent"
usageTotalsConsistent = do Effect {
  u = { promptTokens: 100, completionTokens: 50, totalTokens: 150 }
  assertEq u.totalTokens (u.promptTokens + u.completionTokens)
}
