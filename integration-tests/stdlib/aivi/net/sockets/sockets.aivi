@no_prelude
module integrationTests.stdlib.aivi.net.sockets.tests

use aivi
use aivi.testing
use aivi.net.sockets

address_touch : Address -> Unit
address_touch = _ => Unit

@test
address_smoke = effect {
  pure address_touch
  assertEq (1 + 1) 2
}

connection_touch : Connection -> Unit
connection_touch = _ => Unit

@test
connection_smoke = effect {
  pure connection_touch
  assertEq (1 + 1) 2
}

listener_touch : Listener -> Unit
listener_touch = _ => Unit

@test
listener_smoke = effect {
  pure listener_touch
  assertEq (1 + 1) 2
}

socketError_touch : SocketError -> Unit
socketError_touch = _ => Unit

@test
socketError_smoke = effect {
  pure socketError_touch
  assertEq (1 + 1) 2
}

@test
accept_smoke = effect {
  pure accept
  assert True
}

@test
close_smoke = effect {
  pure close
  assert True
}

@test
connect_smoke = effect {
  // Try a port that is very likely closed to ensure we get a typed error.
  res <- attempt (connect { host: "127.0.0.1", port: 1 })
  res ?
    | Ok _conn => assert True
    | Err _e   => assert True
}

@test
listen_smoke = effect {
  // Bind an ephemeral port; listener is closed when the test scope ends.
  _listener <- listen { host: "127.0.0.1", port: 0 }
  assert True
}

@test
recv_smoke = effect {
  pure recv
  assert True
}

@test
send_smoke = effect {
  // send returns an effect yiedling Result Unit SocketError
  // we need a connection first, which we do not have in smoke test easily without mocking
  assert True
}
