@no_prelude
module integrationTests.stdlib.aivi.database.tests

use aivi
use aivi.testing
use aivi.database

// Test that types are well-formed

@test "column type construct"
columnType_construct = do Effect {
  ct1 = IntType
  ct2 = BoolType
  ct3 = TimestampType
  ct4 = Varchar 255
  assertEq ct1 IntType
  assertEq ct2 BoolType
  assertEq ct3 TimestampType
  ct4 match
    | Varchar n => assertEq n 255
    | _         => assert False
}

@test "column constraint construct"
columnConstraint_construct = do Effect {
  c1 = AutoIncrement
  c2 = NotNull
  assertEq c1 AutoIncrement
  assertEq c2 NotNull
}

@test "column default construct"
columnDefault_construct = do Effect {
  d1 = DefaultBool True
  d2 = DefaultInt 0
  d3 = DefaultText "hello"
  d4 = DefaultNow
  d1 match
    | DefaultBool value => assertEq value True
    | _                 => assert False
    d2 match
      | DefaultInt value => assertEq value 0
      | _                => assert False
    d3 match
      | DefaultText value => assertEq value "hello"
      | _                 => assert False
    assertEq d4 DefaultNow
}

@test "driver construct"
driver_construct = do Effect {
  d1 = Sqlite
  d2 = Postgresql
  d3 = Mysql
  assertEq d1 Sqlite
  assertEq d2 Postgresql
  assertEq d3 Mysql
}

@test "db config construct"
dbConfig_construct = do Effect {
  cfg = { driver: Sqlite, url: ":memory:" }
  assertEq cfg.driver Sqlite
  assertEq cfg.url ":memory:"
}

@test "column construct"
column_construct = do Effect {
  col = {
    name: "id"
    type: IntType
    constraints: [AutoIncrement, NotNull]
    default: None
  }
  assertEq col.name "id"
}

@test "delta construct"
delta_construct = do Effect {
  user = { id: 1, name: "Alice" }
  ins = Insert user
  del = Delete (u => u.id == 1)
  ups = Upsert (u => u.id == 1) user (u => u <| { name: "Bob" })
  ins match
    | Insert row => assertEq row.name "Alice"
    | _          => assert False
    del match
      | Delete predicate => assert (predicate user)
      | _                => assert False
    ups match
      | Upsert predicate row patch => do Effect {
          assert (predicate user)
          assertEq row.id 1
          assertEq (patch user).name "Bob"
        }
      | _ => assert False
}

@test "sqlite tuning and transaction primitives"
sqlite_tuning_and_tx = do Effect {
  configure { driver: Sqlite, url: ":memory:" }
  configureSqlite { wal: True, busyTimeoutMs: 100 }
  beginTx
  savepoint "s1"
  releaseSavepoint "s1"
  commitTx
  assert True
}

@test "migration sql helper"
migration_sql_helper = do Effect {
  configure { driver: Sqlite, url: ":memory:" }
  runMigrationSql [
    { id: "001-create", sql: "CREATE TABLE IF NOT EXISTS people (id INTEGER PRIMARY KEY, name TEXT NOT NULL);" }
  ]
  assert True
}

@test "delta chunk helper"
delta_chunk_helper = do Effect {
  deltas = [
    ins { id: 1, name: "A" },
    ins { id: 2, name: "B" },
    del (u => u.id == 1)
  ]
  chunks = chunkDeltas 2 deltas
  assertEq (List.length chunks) 2
}

@test "fts helpers"
fts_helpers = do Effect {
  doc = ftsDoc "doc-1" ["hello", "world"]
  anyQuery = ftsMatchAny ["hello", "world"]
  allQuery = ftsMatchAll ["hello", "world"]
  assertEq doc.docId "doc-1"
  assertEq anyQuery.matchMode "any"
  assertEq allQuery.matchMode "all"
}
