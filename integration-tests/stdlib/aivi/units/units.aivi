@no_prelude
module integrationTests.stdlib.aivi.units.tests

use aivi
use aivi.testing
use aivi.math
use aivi.units

@test "quantity"
quantity_smoke = do Effect {
  m = defineUnit "m" 1.0
  a = { value: 2.0, unit: m }
  b = { value: 3.0, unit: m }
  // Avoid `Units.(+)`/`Units.(*)` operator projection: native backend doesn't support it yet.
  sumVal = math.sum [a.value, b.value]
  scaledVal = math.sum [a.value, a.value, a.value, a.value]
  sum = { value: sumVal, unit: a.unit }
  scaled = { value: scaledVal, unit: a.unit }
  assert (abs (sum.value - 5.0) < 0.0000001)
  assert (abs (scaled.value - 8.0) < 0.0000001)
}

@test "unit"
unit_smoke = do Effect {
  u = defineUnit "s" 1.0
  assert (u.name == "s")
  assert (u.factor == 1.0)
}

@test "convert"
convert_smoke = do Effect {
  m = defineUnit "m" 1.0
  km = defineUnit "km" 1000.0
  q = { value: 1500.0, unit: m }
  qKm = convert q km
  assert (abs (qKm.value - 1.5) < 0.0000001)
  assert (qKm.unit.name == "km")
}

@test "define unit"
defineUnit_smoke = do Effect {
  m = defineUnit "m" 1.0
  km = defineUnit "km" 1000.0
  assert (m.name == "m")
  assert (km.factor == 1000.0)
}

@test "same unit"
sameUnit_smoke = do Effect {
  m = defineUnit "m" 1.0
  km = defineUnit "km" 1000.0
  a = { value: 1.0, unit: m }
  b = { value: 2.0, unit: m }
  c = { value: 1.0, unit: km }
  assert (sameUnit a b == True)
  assert (sameUnit a c == False)
}
