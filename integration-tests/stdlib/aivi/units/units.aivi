@no_prelude
module integrationTests.stdlib.aivi.units.tests

use aivi
use aivi.testing
use aivi.math
use aivi.units (Unit, Quantity, defineUnit, convert, sameUnit)

@test
quantity_smoke = effect {
  m = defineUnit "m" 1.0
  a = { value: 2.0, unit: m }
  b = { value: 3.0, unit: m }
  // Avoid `Units.(+)`/`Units.(*)` operator projection: native backend doesn't support it yet.
  sum = { value: a.value + b.value, unit: a.unit }
  scaled = { value: a.value * 4.0, unit: a.unit }
  assert (abs (sum.value - 5.0) < 0.0000001)
  assert (abs (scaled.value - 8.0) < 0.0000001)
}

@test
unit_smoke = effect {
  u = defineUnit "s" 1.0
  assert (u.name == "s")
  assert (u.factor == 1.0)
}

@test
convert_smoke = effect {
  m = defineUnit "m" 1.0
  km = defineUnit "km" 1000.0
  q = { value: 1500.0, unit: m }
  qKm = convert q km
  assert (abs (qKm.value - 1.5) < 0.0000001)
  assert (qKm.unit.name == "km")
}

@test
defineUnit_smoke = effect {
  m = defineUnit "m" 1.0
  km = defineUnit "km" 1000.0
  assert (m.name == "m")
  assert (km.factor == 1000.0)
}

@test
sameUnit_smoke = effect {
  m = defineUnit "m" 1.0
  km = defineUnit "km" 1000.0
  a = { value: 1.0, unit: m }
  b = { value: 2.0, unit: m }
  c = { value: 1.0, unit: km }
  assert (sameUnit a b == True)
  assert (sameUnit a c == False)
}
