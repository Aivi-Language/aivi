@no_prelude
module integrationTests.stdlib.aivi.prelude.tests

use aivi
use aivi.testing
use aivi.prelude
use aivi.text

@test "bool"
bool_functional = do Effect {
  assert (True && True)
  assert (True || False)
  assert (False || True)
  assert (!False)
  assert (!(True && False))
  assert (True != False)
  assert (True == True)
}

@test "bytes"
bytes_functional = do Effect {
  b = toBytes Utf8 "abc"
  res = fromBytes Utf8 b
  res match
    | Ok s  => assertEq s "abc"
    | Err _ => assert False
}

@test "char"
char_functional = do Effect {
  assertEq (1 + 1) 2
}

@test "float"
float_functional = do Effect {
  assert (1.0 + 2.0 == 3.0)
  assert (2.0 * 3.0 == 6.0)
  assert (4.0 / 2.0 == 2.0)
  assert (1.0 < 2.0)
  assert (2.0 > 1.0)
  assert (1.0 <= 1.0)
  assert (1.0 >= 1.0)
}

@test "int"
int_functional = do Effect {
  assertEq (1 + 2) 3
  assertEq (2 * 3) 6
  assertEq (4 / 2) 2
  assert (1 < 2)
  assert (2 > 1)
  assert (1 <= 1)
  assert (1 >= 1)
  minInt = a b => if a < b then a else b
  maxInt = a b => if a > b then a else b
  assert (minInt 1 2 == 1)
  assert (maxInt 1 2 == 2)
}

len = xs => xs match
  | []           => 0
  | [_, ...rest] => 1 + len rest

map = f xs => xs match
  | []           => []
  | [x, ...rest] => [f x, ...(map f rest)]

@test "list"
list_functional = do Effect {
  l = [1, 2, 3]
  assertEq (len l) 3
  assertEq (map (x => x + 1) l)[2, 3, 4]
}

@test "option"
option_functional = do Effect {
  some = Some 1
  some match
    | Some n => assertEq n 1
    | None   => assert False

    none = None
    assertEq none None
}

@test "patch"
patch_functional = do Effect {
  user = { name: "A", age: 30 }
  older = user <| { age: _ + 1 }
  assertEq older.age 31
}

@test "result"
result_functional = do Effect {
  ok = Ok 1
  ok match
    | Ok n  => assertEq n 1
    | Err _ => assert False

    err = Err "nope"
    err match
      | Ok _  => assert False
      | Err e => assertEq e "nope"
}

@test "attempt"
attempt_functional = do Effect {
  ok <- attempt (pure 42)
  ok match
    | Ok n  => assertEq n 42
    | Err _ => assert False

    bad <- attempt (fail "boom")
    bad match
      | Ok _  => assert False
      | Err e => assertEq e "boom"
}

@test "text"
text_functional = do Effect {
  t = "Hello"
  assertEq (length t) 5
  assertEq (toUpper t) "HELLO"
  assertEq (toLower t) "hello"
  assert (isEmpty "" == True)
  assert (isEmpty t == False)
}

@test "to text"
toText_functional = do Effect {
  assertEq (toText "abc") "abc"
  assertEq (toText 123) "123"
}

@test "tuple"
tuple_functional = do Effect {
  t = (1, "two")
  res = t match
    | (a, b) => if a == 1 && b == "two" then True else False
    | _      => False
    assert (res == True)
}

@test "to text 2"
toText_functional_2 = do Effect {
  assertEq (toText 0) "0"
}
