@no_prelude
module integrationTests.stdlib.aivi.graph.tests

use aivi
use aivi.testing
use aivi.graph

edge_touch : Edge -> Unit
edge_touch = _ => Unit

@test
edge_smoke = effect {
  _ <- pure edge_touch
  _ <- assertEq (1 + 1) 2
}

nodeId_touch : NodeId -> Unit
nodeId_touch = _ => Unit

@test
nodeId_smoke = effect {
  _ <- pure nodeId_touch
  _ <- assertEq (1 + 1) 2
}

@test
addEdge_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  // addEdge ensures nodes exist and connectivity updates.
  _ <- assert (neighbors g 1 == [2])
  _ <- assert (degreeIn g 2 == 1)
}

@test
addNode_smoke = effect {
  g = addNode empty 1
  _ <- assert (List.length g.nodes == 1)
}

@test
bfs_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  path = bfs g { start: 1, end: 2 }
  _ <- assert (path == [1, 2])
}

@test
dedupEdges_smoke = effect {
  _ <- pure dedupEdges
  _ <- assert True
}

@test
degreeIn_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addEdge 1 2
  _ <- assert (degreeIn g 2 == 1)
}

@test
degreeOut_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addNode 3 |> addEdge 1 2 |> addEdge 1 3
  _ <- assert (degreeOut g 1 == 2)
}

@test
dfs_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addNode 3 |> addEdge 1 2 |> addEdge 2 3
  _ <- assert (List.length (dfs g 1) == 3)
}

@test
edgesFrom_smoke = effect {
  _ <- pure edgesFrom
  _ <- assert True
}

@test
edgesTo_smoke = effect {
  _ <- pure edgesTo
  _ <- assert True
}

@test
empty_smoke = effect {
  g = empty
  _ <- assert (List.length g.nodes == 0)
}

@test
fromEdges_smoke = effect {
  _ <- pure fromEdges
  _ <- assert True
}

@test
fromWeightedEdges_smoke = effect {
  _ <- pure fromWeightedEdges
  _ <- assert True
}

@test
hasCycle_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addEdge 1 2 |> addEdge 2 1
  _ <- assert (hasCycle g == True)
}

@test
inNeighbors_smoke = effect {
  _ <- pure inNeighbors
  _ <- assert True
}

@test
isValid_smoke = effect {
  _ <- pure isValid
  _ <- assert True
}

@test
neighbors_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  ns = neighbors g 1
  _ <- assert (ns == [2])
}

@test
normalize_smoke = effect {
  _ <- pure normalize
  _ <- assert True
}

@test
removeEdge_smoke = effect {
  _ <- pure removeEdge
  _ <- assert True
}

@test
removeNode_smoke = effect {
  _ <- pure removeNode
  _ <- assert True
}

@test
shortestPath_smoke = effect {
  _ <- pure shortestPath
  _ <- assert True
}

@test
shortestPathUnweighted_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addNode 3 |> addEdge 1 2 |> addEdge 2 3
  _ <- assert (shortestPathUnweighted g 1 3 == Ok [1, 2, 3])
}

@test
topoSort_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addNode 3 |> addEdge 1 2 |> addEdge 2 3
  _ <- assert (topoSort g == Ok [1, 2, 3])
}
