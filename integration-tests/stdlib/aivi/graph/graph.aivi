@no_prelude
module integrationTests.stdlib.aivi.graph.tests

use aivi
use aivi.testing
use aivi.graph

edge_touch : Edge -> Unit
edge_touch = _ => Unit

@test
edge_smoke = effect {
  pure edge_touch
  assertEq (1 + 1) 2
}

nodeId_touch : NodeId -> Unit
nodeId_touch = _ => Unit

@test
nodeId_smoke = effect {
  pure nodeId_touch
  assertEq (1 + 1) 2
}

@test
addEdge_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  // addEdge ensures nodes exist and connectivity updates.
  assert (neighbors g 1 == [2])
  assert (degreeIn g 2 == 1)
}

@test
addNode_smoke = effect {
  g = addNode empty 1
  assert (List.length g.nodes == 1)
}

@test
bfs_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  path = bfs g { start: 1, end: 2 }
  assert (path == [1, 2])
}

@test
dedupEdges_smoke = effect {
  pure dedupEdges
  assert True
}

@test
degreeIn_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addEdge 1 2
  assert (degreeIn g 2 == 1)
}

@test
degreeOut_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addNode 3 |> addEdge 1 2 |> addEdge 1 3
  assert (degreeOut g 1 == 2)
}

@test
dfs_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addNode 3 |> addEdge 1 2 |> addEdge 2 3
  assert (List.length (dfs g 1) == 3)
}

@test
edgesFrom_smoke = effect {
  pure edgesFrom
  assert True
}

@test
edgesTo_smoke = effect {
  pure edgesTo
  assert True
}

@test
empty_smoke = effect {
  g = empty
  assert (List.length g.nodes == 0)
}

@test
fromEdges_smoke = effect {
  pure fromEdges
  assert True
}

@test
fromWeightedEdges_smoke = effect {
  pure fromWeightedEdges
  assert True
}

@test
hasCycle_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addEdge 1 2 |> addEdge 2 1
  assert (hasCycle g == True)
}

@test
inNeighbors_smoke = effect {
  pure inNeighbors
  assert True
}

@test
isValid_smoke = effect {
  pure isValid
  assert True
}

@test
neighbors_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  ns = neighbors g 1
  assert (ns == [2])
}

@test
normalize_smoke = effect {
  pure normalize
  assert True
}

@test
removeEdge_smoke = effect {
  pure removeEdge
  assert True
}

@test
removeNode_smoke = effect {
  pure removeNode
  assert True
}

@test
shortestPath_smoke = effect {
  pure shortestPath
  assert True
}

@test
shortestPathUnweighted_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addNode 3 |> addEdge 1 2 |> addEdge 2 3
  assert (shortestPathUnweighted g 1 3 == Ok [1, 2, 3])
}

@test
topoSort_smoke = effect {
  g = empty |> addNode 1 |> addNode 2 |> addNode 3 |> addEdge 1 2 |> addEdge 2 3
  assert (topoSort g == Ok [1, 2, 3])
}
