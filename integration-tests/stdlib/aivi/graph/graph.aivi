@no_prelude
module integrationTests.stdlib.aivi.graph.tests

use aivi
use aivi.testing
use aivi.graph

edge_touch : Edge -> Unit
edge_touch = _ => Unit

@test
edge_smoke = effect {
  pure edge_touch
  assertEq (1 + 1) 2
}

nodeId_touch : NodeId -> Unit
nodeId_touch = _ => Unit

@test
nodeId_smoke = effect {
  pure nodeId_touch
  assertEq (1 + 1) 2
}

@test
addEdge_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  // addEdge ensures nodes exist and connectivity updates.
  assert (neighbors g 1 == [2])
  assert (degreeIn g 2 == 1)
}

@test
addNode_smoke = effect {
  g = addNode empty 1
  assert (List.length g.nodes == 1)
}

@test
bfs_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  path = bfs g { start: 1, end: 2 }
  assert (path == [1, 2])
}

@test
dedupEdges_smoke = effect {
  g0 =
    addEdge
    (addEdge (addEdge empty { from: 1, to: 2, weight: 1.0 }) { from: 1, to: 2, weight: 1.0 })
    { from: 2, to: 3, weight: 1.0 }
  g1 = dedupEdges g0
  assert (List.length g1.edges == 2)
}

@test
degreeIn_smoke = effect {
  g = addEdge (addNode (addNode empty 1) 2) { from: 1, to: 2, weight: 1.0 }
  assert (degreeIn g 2 == 1)
}

@test
degreeOut_smoke = effect {
  g0 = addNode (addNode (addNode empty 1) 2) 3
  g = addEdge (addEdge g0 { from: 1, to: 2, weight: 1.0 }) { from: 1, to: 3, weight: 1.0 }
  assert (degreeOut g 1 == 2)
}

@test
dfs_smoke = effect {
  g0 = addNode (addNode (addNode empty 1) 2) 3
  g = addEdge (addEdge g0 { from: 1, to: 2, weight: 1.0 }) { from: 2, to: 3, weight: 1.0 }
  assert (List.length (dfs g 1) == 3)
}

@test
edgesFrom_smoke = effect {
  g =
    addEdge
    (addEdge (addEdge empty { from: 1, to: 2, weight: 1.0 }) { from: 1, to: 3, weight: 2.0 })
    { from: 2, to: 3, weight: 3.0 }
  es = edgesFrom g 1
  assert (List.length es == 2)
  assert (neighbors g 1 == [2, 3])
}

@test
edgesTo_smoke = effect {
  g = addEdge (addEdge empty { from: 1, to: 2, weight: 1.0 }) { from: 3, to: 2, weight: 2.0 }
  es = edgesTo g 2
  assert (List.length es == 2)
  assert (inNeighbors g 2 == [1, 3])
}

@test
empty_smoke = effect {
  g = empty
  assert (List.length g.nodes == 0)
}

@test
fromEdges_smoke = effect {
  g = fromEdges [(1, 2), (2, 3)]
  assert (neighbors g 1 == [2])
  assert (neighbors g 2 == [3])
}

@test
fromWeightedEdges_smoke = effect {
  g = fromWeightedEdges [(1, 2, 10.0), (1, 3, 1.0), (3, 2, 1.0)]
  p = shortestPath g 1 2
  assert (p == [1, 3, 2])
}

@test
hasCycle_smoke = effect {
  g0 = addNode (addNode empty 1) 2
  g = addEdge (addEdge g0 { from: 1, to: 2, weight: 1.0 }) { from: 2, to: 1, weight: 1.0 }
  assert (hasCycle g == True)
}

@test
inNeighbors_smoke = effect {
  g = addEdge (addEdge empty { from: 1, to: 2, weight: 1.0 }) { from: 3, to: 2, weight: 1.0 }
  assert (inNeighbors g 2 == [1, 3])
}

@test
isValid_smoke = effect {
  gBad = { nodes: [1], edges: [{ from: 1, to: 2, weight: 1.0 }] }
  assert (isValid gBad == False)
  assert (isValid (normalize gBad) == True)
}

@test
neighbors_smoke = effect {
  g = addEdge empty { from: 1, to: 2, weight: 1.0 }
  ns = neighbors g 1
  assert (ns == [2])
}

@test
normalize_smoke = effect {
  g0 = { nodes: [], edges: [{ from: 1, to: 2, weight: 1.0 }] }
  g1 = normalize g0
  assert (List.length g1.nodes == 2)
  assert (isValid g1 == True)
}

@test
removeEdge_smoke = effect {
  e = { from: 1, to: 2, weight: 1.0 }
  g0 = addEdge empty e
  g1 = removeEdge g0 e
  assert (neighbors g1 1 == [])
}

@test
removeNode_smoke = effect {
  g0 = addEdge (addEdge empty { from: 1, to: 2, weight: 1.0 }) { from: 2, to: 3, weight: 1.0 }
  g1 = removeNode g0 2
  assert (neighbors g1 1 == [])
  assert (inNeighbors g1 3 == [])
}

@test
shortestPath_smoke = effect {
  g = fromWeightedEdges [(1, 2, 10.0), (1, 3, 1.0), (3, 2, 1.0)]
  assert (shortestPath g 1 2 == [1, 3, 2])
}

@test
shortestPathUnweighted_smoke = effect {
  g0 = addNode (addNode (addNode empty 1) 2) 3
  g = addEdge (addEdge g0 { from: 1, to: 2, weight: 1.0 }) { from: 2, to: 3, weight: 1.0 }
  assert (shortestPathUnweighted g 1 3 == [1, 2, 3])
}

@test
topoSort_smoke = effect {
  g0 = addNode (addNode (addNode empty 1) 2) 3
  g = addEdge (addEdge g0 { from: 1, to: 2, weight: 1.0 }) { from: 2, to: 3, weight: 1.0 }
  assert (topoSort g == [1, 2, 3])
}
