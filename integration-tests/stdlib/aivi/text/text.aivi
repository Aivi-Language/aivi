@no_prelude
module integrationTests.stdlib.aivi.text.tests

use aivi
use aivi.testing
use aivi.text

bytes_touch : Bytes -> Unit
bytes_touch = _ => Unit

@test
bytes_smoke = effect {
  pure bytes_touch
  assertEq (1 + 1) 2
}

encoding_touch : Encoding -> Unit
encoding_touch = _ => Unit

@test
encoding_smoke = effect {
  pure encoding_touch
  assertEq (1 + 1) 2
}

latin1_touch : Latin1 -> Unit
latin1_touch = _ => Unit

@test
latin1_smoke = effect {
  pure latin1_touch
  assertEq (1 + 1) 2
}

textError_touch : TextError -> Unit
textError_touch = _ => Unit

@test
textError_smoke = effect {
  pure textError_touch
  assertEq (1 + 1) 2
}

utf16_touch : Utf16 -> Unit
utf16_touch = _ => Unit

@test
utf16_smoke = effect {
  pure utf16_touch
  assertEq (1 + 1) 2
}

utf32_touch : Utf32 -> Unit
utf32_touch = _ => Unit

@test
utf32_smoke = effect {
  pure utf32_touch
  assertEq (1 + 1) 2
}

utf8_touch : Utf8 -> Unit
utf8_touch = _ => Unit

@test
utf8_smoke = effect {
  pure utf8_touch
  assertEq (1 + 1) 2
}

@test
capitalize_smoke = effect {
  assert (capitalize "hello" == "Hello")
  assert (capitalize "Hello" == "Hello")
}

@test
caseFold_smoke = effect {
  assert (caseFold "Hello" == "hello")
}

@test
chunk_smoke = effect {
  assert (chunk 2 "abcde" == ["ab", "cd", "e"])
}

@test
compare_smoke = effect {
  assert (compare "a" "b" < 0)
  assert (compare "b" "a" > 0)
  assert (compare "a" "a" == 0)
}

@test
concat_smoke = effect {
  assert (concat "a" "b" == "ab")
}

@test
contains_smoke = effect {
  assert (contains "ell" "hello" == True)
  assert (contains "z" "hello" == False)
}

@test
count_smoke = effect {
  assert (count "l" "hello" == 2)
  assert (count "z" "hello" == 0)
}

@test
debugText_smoke = effect {
  assert (length (debugText "hello") > 0)
}

@test
endsWith_smoke = effect {
  assert (endsWith "lo" "hello" == True)
  assert (endsWith "he" "hello" == False)
}

@test
fromBytes_smoke = effect {
  // Inverse of toBytes
  assert True
}

@test
indexOf_smoke = effect {
  assert (indexOf "e" "hello" == Some 1)
  assert (indexOf "l" "hello" == Some 2)
  assert (indexOf "z" "hello" == None)
}

@test
isAlnum_smoke = effect {
  assert (isAlnum "a" == True)
  assert (isAlnum "1" == True)
  assert (isAlnum "!" == False)
}

@test
isAlpha_smoke = effect {
  pure isAlpha
  assertEq (1 + 1) 2
}

@test
isDigit_smoke = effect {
  assert (isDigit "1" == True)
  assert (isDigit "a" == False)
}

@test
isEmpty_smoke = effect {
  assert (isEmpty "" == True)
  assert (isEmpty "a" == False)
}

@test
isLower_smoke = effect {
  assert (isLower "a" == True)
  assert (isLower "A" == False)
}

@test
isSpace_smoke = effect {
  assert (isSpace " " == True)
  assert (isSpace "a" == False)
}

@test
isUpper_smoke = effect {
  assert (isUpper "A" == True)
  assert (isUpper "a" == False)
}

@test
lastIndexOf_smoke = effect {
  assert (lastIndexOf "l" "hello" == Some 3)
  assert (lastIndexOf "z" "hello" == None)
}

@test
length_smoke = effect {
  assert (length "hello" == 5)
  assert (length "" == 0)
}

@test
normalizeNFC_smoke = effect {
  assert (length (normalizeNFC "hello") == 5)
}

@test
normalizeNFD_smoke = effect {
  assert (length (normalizeNFD "hello") == 5)
}

@test
normalizeNFKC_smoke = effect {
  assert (length (normalizeNFKC "hello") == 5)
}

@test
normalizeNFKD_smoke = effect {
  assert (length (normalizeNFKD "hello") == 5)
}

@test
padEnd_smoke = effect {
  assert (padEnd 5 " " "abc" == "abc  ")
  assert (padEnd 3 " " "abc" == "abc")
}

@test
padStart_smoke = effect {
  assert (padStart 5 " " "abc" == "  abc")
}

@test
parseFloat_smoke = effect {
  assert (parseFloat "123.45" == Some 123.45)
  // assert (parseFloat "abc" == None)? Not sure if it yields None or error. Assuming Option return.
  res = parseFloat "abc"
  res ?
    | Some _ => assert False
    | None   => assert True
}

@test
parseInt_smoke = effect {
  assert (parseInt "123" == Some 123)
  assert (parseInt "abc" == None)
}

@test
remove_smoke = effect {
  assert (remove "l" "hello" == "heo")
}

@test
repeat_smoke = effect {
  assert (repeat 3 "a" == "aaa")
  assert (repeat 0 "a" == "")
}

@test
replace_smoke = effect {
  assert (replace "l" "L" "hello" == "heLlo") // Replaces first occurrence? Assuming standard behavior for replace vs replaceAll
}

@test
replaceAll_smoke = effect {
  assert (replaceAll "l" "L" "hello" == "heLLo")
}

@test
reverse_smoke = effect {
  assert (reverse "abc" == "cba")
}

@test
slice_smoke = effect {
  assert (slice 0 2 "hello" == "he")
  assert (slice 1 3 "hello" == "el")
}

@test
split_smoke = effect {
  assert (split "," "a,b,c" == ["a", "b", "c"])
  assert (split "." "a" == ["a"])
}

@test
splitLines_smoke = effect {
  assert (splitLines "a\nb\nc" == ["a", "b", "c"])
  assert (splitLines "a\r\nb" == ["a", "b"])
}

@test
startsWith_smoke = effect {
  assert (startsWith "he" "hello" == True)
  assert (startsWith "lo" "hello" == False)
}

@test
titleCase_smoke = effect {
  assert (titleCase "hello world" == "Hello World")
}

@test
toBytes_smoke = effect {
  // Assuming Bytes or list of ints/bytes
  bytes = toBytes "abc"
  // Just checking not crashing for now, until Bytes is explored
  assert True
}

@test
toLower_smoke = effect {
  assert (toLower "HELLO" == "hello")
}

@test
toUpper_smoke = effect {
  assert (toUpper "hello" == "HELLO")
}

@test
trim_smoke = effect {
  assert (trim "  hello  " == "hello")
}

@test
trimEnd_smoke = effect {
  assert (trimEnd "abc  " == "abc")
}

@test
trimStart_smoke = effect {
  assert (trimStart "  abc" == "abc")
}
