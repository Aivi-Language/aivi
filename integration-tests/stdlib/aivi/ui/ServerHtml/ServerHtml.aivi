@no_prelude
module aivi.ui.ServerHtml

use aivi
use aivi.collections
use aivi.crypto (randomUuid)
use aivi.json
use aivi.net.httpServer
use aivi.ui (VNode, Attr, Element, TextNode, renderHtml, diff, patchToJson)
use aivi.ui.serverHtml.Protocol
use aivi.ui.serverHtml.Runtime
use aivi.ui.serverHtml.ClientAsset (clientJs)

export
App, InitContext, AppEffect
ClipboardError, PlatformEvent, ViewId, UrlInfo
serveHttp, serveWs

// ---------------------------------------------------------------------------
// 4a. App record
// ---------------------------------------------------------------------------

InitContext = { viewId: ViewId, url: UrlInfo, online: Bool }

AppEffect model msg =
  | ReadClipboard (Result ClipboardError Text -> msg)
  | WriteClipboard Text (Result ClipboardError Unit -> msg)
  | SubIntersect SubscriptionId IntersectionOptions (List IntersectionTarget)
  | UnsubIntersect SubscriptionId

App model msg = {
  init: InitContext -> model
  update: msg -> model -> (model, List (AppEffect model msg))
  view: model -> VNode msg
  onPlatform: PlatformEvent -> Option msg
}

// ---------------------------------------------------------------------------
// Internal: convert AppEffects to ServerEffects + pending entries
// ---------------------------------------------------------------------------

ConvertedEffects msg = {
  serverEffects: List (ServerEffect msg)
  nextRid: RequestId
  pendingTable: Map RequestId (PendingEntry msg)
}

convertAppEffects
: List (AppEffect model msg)
-> RequestId
-> Map RequestId (PendingEntry msg)
-> ConvertedEffects msg
convertAppEffects = effects rid pending => effects match
| []                 => { serverEffects: [], nextRid: rid, pendingTable: pending }
| [eff, ...rest]     => eff match
| ReadClipboard cont => {
  result = convertAppEffects rest (rid + 1)
  (Map.insert rid (ReadPending cont) pending)
  { serverEffects: [RequestClipboard rid ReadText, ...result.serverEffects]
    nextRid: result.nextRid
    pendingTable: result.pendingTable
}
}
| WriteClipboard text cont => {
    result = convertAppEffects rest (rid + 1)
    (Map.insert rid (WritePending cont) pending)
    { serverEffects: [RequestClipboard rid (WriteText { text }), ...result.serverEffects]
      nextRid: result.nextRid
      pendingTable: result.pendingTable
}
  }
| SubIntersect sid options targets => {
    result = convertAppEffects rest rid pending
    { serverEffects: [SubscribeIntersectEff sid options targets, ...result.serverEffects]
      nextRid: result.nextRid
      pendingTable: result.pendingTable
}
  }
| UnsubIntersect sid => {
    result = convertAppEffects rest rid pending
    { serverEffects: [UnsubscribeIntersectEff sid, ...result.serverEffects]
      nextRid: result.nextRid
      pendingTable: result.pendingTable
}
  }

// Adapter: wraps app.update to produce ServerEffects instead of AppEffects
  makeUpdateAdapter
  : App model msg
  -> { update: msg -> model -> (model, List (ServerEffect msg))
    view: model -> VNode msg
  }
  makeUpdateAdapter = app => {
    update: msg model => {
      (newModel, appEffects) = app.update msg model
      converted = convertAppEffects appEffects 0 Map.empty
      (newModel, converted.serverEffects)
    }
    view: app.view
  }

// ---------------------------------------------------------------------------
// Internal: parse UrlInfo from a URL text
// ---------------------------------------------------------------------------

  parseUrlInfo : Text -> UrlInfo
  parseUrlInfo = urlText => {
  // Minimal parser: extract path, query, hash from URL text.
  // A full URL parser would live in aivi.url; this is a best-effort split.
    href = urlText
    pathAndRest = stripSchemeHost urlText
    (pathAndQuery, hash) = splitOnce "#" pathAndRest
    (path, query) = splitOnce "?" pathAndQuery
    { href, path, query: query ? | "" => "" | q => "?{ q }", hash: hash ? | "" => "" | h => "#{ h }" }
  }

// Strip scheme + authority from a URL, returning path onward.
  stripSchemeHost : Text -> Text
  stripSchemeHost = url => {
    afterScheme = text.contains "://" url match
    | True  => text.splitOnce "://" url |> sndOf |> dropUntilSlash
    | False => url
    afterScheme
  }

  dropUntilSlash : Text -> Text
  dropUntilSlash = t => text.contains "/" t match
| True  => "/" ++ (text.splitOnce "/" t |> sndOf)
| False => "/"

// Split a text on the first occurrence of sep. Returns (before, after).
// If sep is not found, returns (text, "").
  splitOnce : Text -> Text -> (Text, Text)
  splitOnce = sep t => text.contains sep t match
| True  => text.splitOnce sep t
| False => (t, "")

  sndOf : (A, B) -> B
  sndOf = (_, b) => b

// ---------------------------------------------------------------------------
// 4b. serveHttp
// ---------------------------------------------------------------------------

  serveHttp : App model msg -> Request -> Effect HttpError Response
  serveHttp = app req => do Effect {
    viewId <- randomUuid
    url = parseUrlInfo req.path
    initCtx = { viewId, url, online: True }
    model = app.init initCtx
    vdom0 = app.view model
    (vdom, _, _) = assignHandlers vdom0 0
    html = renderHtml vdom
    bootData = [
      ("viewId", encodeText viewId)
      ("wsUrl", encodeText "/aivi/live")
    ]
    bootJson = jsonToText (encodeObject bootData)
    fullHtml = "<!doctype html><html><head><meta charset=\"utf-8\"><script type=\"application/json\" id=\"aivi-server-html-boot\">{ bootJson }</script></head><body>{ html }<script>{ clientJs }</script></body></html>"
    pure { status: 200
      headers: [{ name: "Content-Type", value: "text/html; charset=utf-8" }]
      body: text.toBytes fullHtml } -- DOCS: verify text.toBytes
  }

// ---------------------------------------------------------------------------
// 4c. serveWs
// ---------------------------------------------------------------------------

  serveWs : App model msg -> WebSocket -> Effect WsError Unit
  serveWs = app ws => do Effect {
  // 1. Receive first message; expect Hello.
    firstRaw <- wsRecv ws
    firstText = firstRaw match
    | TextMsg t => t
    | _         => ""
    decoded = decodeClientMsg firstText
    decoded match
    | Err _ => do Effect {
      _ <- wsSend ws (TextMsg (encodeServerMsg (Error { code: "PROTO", detail: "expected hello" })))
      wsClose ws
    }
    | Ok clientMsg => clientMsg match
    | Hello hello  => do Effect {
    // v1: always create a new view per connection.
    // Reconnection policy v1: treat every Hello as a new view.
      viewId <- randomUuid
      url = parseUrlInfo hello.url
      initCtx = { viewId, url, online: hello.online }
      model = app.init initCtx
      vdom0 = app.view model
      (vdom, handlers, nextHid) = assignHandlers vdom0 0
    // Send initial full render as a diff from empty vdom.
      emptyVdom = Element "div" [] []
      initialOps = diff emptyVdom vdom
      _ <- wsSend ws (TextMsg (encodeServerMsg (Patch { ops: patchToJson initialOps })))
      initialState = {
        viewId: viewId
        model: model
        lastVdom: vdom
        handlerTable: handlers
        nextHid: nextHid
        nextRid: 0
        pendingTable: Map.empty
        intersections: Map.empty
      }
      recvLoop app ws initialState
    }
    | _ => do Effect {
      _ <- wsSend ws (TextMsg (encodeServerMsg (Error { code: "PROTO", detail: "first message must be hello" })))
      wsClose ws
    }
  }

// ---------------------------------------------------------------------------
// Internal: tail-recursive message loop
// ---------------------------------------------------------------------------

  recvLoop
  : App model msg
  -> WebSocket
  -> ViewState model msg
  -> Effect WsError Unit
  recvLoop = app ws state => do Effect {
    rawMsg <- wsRecv ws
    msgText = rawMsg match
    | TextMsg t => t
    | _         => ""
    decoded = decodeClientMsg msgText
    newState <- decoded match
    | Err _ => do Effect {
      _ <- wsSend ws (TextMsg (encodeServerMsg (Error { code: "DECODE", detail: "invalid message" })))
      pure state
    }
    | Ok clientMsg => dispatchMsg app ws state clientMsg
    recvLoop app ws newState
  }

  dispatchMsg
  : App model msg
  -> WebSocket
  -> ViewState model msg
  -> ClientMsg
  -> Effect WsError (ViewState model msg)
  dispatchMsg = app ws state clientMsg => clientMsg match
| Hello _ =>
// Already initialized; ignore duplicate hello.
  pure state
| Event e => {
    handlerOpt = Map.get e.hid state.handlerTable
    handlerOpt match
  | None => do Effect {
      _ <- wsSend ws (TextMsg (encodeServerMsg
          (Error { code: "HID", detail: "unknown handler id" })
        )
      )
      pure state
  }
  | Some handler => {
      payloadResult = decodeEventPayload e.kind e.p
      payloadResult match
    | Err _ => do Effect {
        _ <- wsSend ws (TextMsg (encodeServerMsg
            (Error { code: "PAYLOAD", detail: "invalid event payload" })
          )
        )
        pure state
    }
    | Ok payload => {
        msgOpt = handler payload
        msgOpt match
      | None     => pure state
      | Some msg =>
          runUpdate msg state (makeUpdateAdapter app) ws
    }
  }
}
| Platform p => {
    platformResult = decodePlatformEvent p.kind (jsonToText p.p)
    platformResult match
  | Err _ => do Effect {
      _ <- wsSend ws (TextMsg (encodeServerMsg
          (Error { code: "PLATFORM", detail: "invalid platform event" })
        )
      )
      pure state
  }
  | Ok platformEvt => {
      msgOpt = app.onPlatform platformEvt
      msgOpt match
    | None     => pure state
    | Some msg => runUpdate msg state (makeUpdateAdapter app) ws
  }
}
| EffectResult er => {
    pendingOpt = Map.get er.rid state.pendingTable
    pendingOpt match
  | None => do Effect {
      _ <- wsSend ws (TextMsg (encodeServerMsg
          (Error { code: "RID", detail: "unknown request id" })
        )
      )
      pure state
  }
  | Some entry => {
      newPending = Map.delete er.rid state.pendingTable
      stateWithoutPending = state <| { pendingTable: newPending }
      resolveResult = resolveEffectResult er entry
      resolveResult match
    | None     => pure stateWithoutPending
    | Some msg => runUpdate msg stateWithoutPending (makeUpdateAdapter app) ws
  }
}

// Resolve an EffectResult against a PendingEntry, producing an optional msg.
  resolveEffectResult
  : { viewId: ViewId, rid: RequestId, kind: Text, ok: Bool, p: JsonValue }
  -> PendingEntry msg
  -> Option msg
  resolveEffectResult = er entry => entry match
| ReadPending cont => er.ok match
| True             => {
    textResult = decodeField "text" er.p |> bind decodeText
    textResult match
  | Ok t  => Some (cont (Ok t))
  | Err _ => Some (cont (Err (Other "decode error")))
}
| False             => Some (cont (Err (classifyClipboardError er)))
| WritePending cont => er.ok match
| True              => Some (cont (Ok Unit))
| False             => Some (cont (Err (classifyClipboardError er)))

// Classify a clipboard error from the error string in the EffectResult.
  classifyClipboardError
  : { viewId: ViewId, rid: RequestId, kind: Text, ok: Bool, p: JsonValue }
  -> ClipboardError
  classifyClipboardError = er => {
    errorField = decodeField "error" er.p |> bind decodeText
    errorField match
    | Ok "NotAllowedError" => PermissionDenied
    | Ok "Unavailable"     => Unavailable
    | Ok other             => Other other
    | Err _                => Other "unknown error"
  }
