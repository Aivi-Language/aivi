@no_prelude
module aivi.ui.serverHtml.Protocol

use aivi
use aivi.prelude
use aivi.testing
use aivi.json

export
ViewId, HandlerId, SubscriptionId, RequestId
UrlInfo
ClickPayload, InputPayload, KeyPayload, PointerPayload, EventPayload
IntersectionEntry, PlatformEvent
ClientMsg, ServerMsg
IntersectionTarget, IntersectionOptions, ClipboardOp
encodeClientMsg, decodeClientMsg
encodeServerMsg, decodeServerMsg
decodePlatformEvent, decodeEventPayload
encodeUrlInfo, decodeUrlInfo
encodeEventPayload, encodeClipboardOp, decodeClipboardOp

// ---------------------------------------------------------------------------
// 1a. Scalar aliases
// ---------------------------------------------------------------------------

ViewId = Text
HandlerId = Int
SubscriptionId = Int
RequestId = Int

// ---------------------------------------------------------------------------
// 1b. UrlInfo
// ---------------------------------------------------------------------------

UrlInfo = { href: Text, path: Text, query: Text, hash: Text }

// ---------------------------------------------------------------------------
// 1c. Typed event payloads
// ---------------------------------------------------------------------------

ClickPayload = { button: Int, alt: Bool, ctrl: Bool, shift: Bool, meta: Bool }

InputPayload = { value: Text }

KeyPayload = { key: Text, code: Text, alt: Bool, ctrl: Bool
  shift: Bool, meta: Bool, repeat: Bool, isComposing: Bool
}

PointerPayload = { pointerId: Int, pointerType: Text, button: Int, buttons: Int
  clientX: Int, clientY: Int
  alt: Bool, ctrl: Bool, shift: Bool, meta: Bool
}

EventPayload =
  | ClickEvt ClickPayload
  | InputEvt InputPayload
  | KeyDownEvt KeyPayload
  | KeyUpEvt KeyPayload
  | PtrDownEvt PointerPayload
  | PtrUpEvt PointerPayload
  | PtrMoveEvt PointerPayload

// ---------------------------------------------------------------------------
// 1d. Platform event ADT
// ---------------------------------------------------------------------------

IntersectionEntry = { tid: Int, isIntersecting: Bool, ratio: Float }

PlatformEvent =
  | PopState UrlInfo
  | HashChange { url: UrlInfo, oldURL: Text, newURL: Text, hash: Text }
  | Visibility { state: Text }
  | WindowFocus { focused: Bool }
  | Online { online: Bool }
  | Intersection { sid: SubscriptionId, entries: List IntersectionEntry }

// ---------------------------------------------------------------------------
// 1e. Client → Server messages
// ---------------------------------------------------------------------------

ClientMsg =
  | Hello { viewId: ViewId, url: Text, online: Bool }
  | Event { viewId: ViewId, hid: HandlerId, kind: Text, p: JsonValue }
  | Platform { viewId: ViewId, kind: Text, p: JsonValue }
  | EffectResult { viewId: ViewId, rid: RequestId, kind: Text, ok: Bool, p: JsonValue }

// ---------------------------------------------------------------------------
// 1f. Server → Client messages
// ---------------------------------------------------------------------------

IntersectionTarget = { tid: Int, nodeId: Text }
IntersectionOptions = { rootMargin: Text, threshold: List Float }

ClipboardOp =
  | ReadText
  | WriteText { text: Text }

ServerMsg =
  | Patch { ops: Text }
  | Error { code: Text, detail: Text }
  | SubscribeIntersect { sid: SubscriptionId
      options: IntersectionOptions
      targets: List IntersectionTarget
    }
  | UnsubscribeIntersect { sid: SubscriptionId }
  | EffectReq { rid: RequestId, op: ClipboardOp }

// ---------------------------------------------------------------------------
// JSON helpers
// ---------------------------------------------------------------------------

// Decode a required field then apply a decoder
field : Text -> (JsonValue -> Result JsonError A) -> JsonValue -> Result JsonError A
field = name decoder obj =>
  decodeField name obj |> bind decoder

// Encode a list of key-value pairs as a JSON object text
toJsonText : List (Text, JsonValue) -> Text
toJsonText = pairs => jsonToText (encodeObject pairs)

// ---------------------------------------------------------------------------
// 1g. UrlInfo encode / decode
// ---------------------------------------------------------------------------

encodeUrlInfo : UrlInfo -> JsonValue
encodeUrlInfo = u => encodeObject [
  ("href", encodeText u.href)
  ("path", encodeText u.path)
  ("query", encodeText u.query)
  ("hash", encodeText u.hash)
]

decodeUrlInfo : JsonValue -> Result JsonError UrlInfo
decodeUrlInfo = json =>
  field "href" decodeText json |> bind (href =>
    field "path" decodeText json |> bind (path =>
      field "query" decodeText json |> bind (query =>
        field "hash" decodeText json |> bind (hash =>
          Ok { href, path, query, hash }
        )
      )
    )
  )

// ---------------------------------------------------------------------------
// EventPayload encode / decode
// ---------------------------------------------------------------------------

encodeClickPayload : ClickPayload -> JsonValue
encodeClickPayload = p => encodeObject [
  ("button", encodeInt p.button)
  ("alt", encodeBool p.alt)
  ("ctrl", encodeBool p.ctrl)
  ("shift", encodeBool p.shift)
  ("meta", encodeBool p.meta)
]

decodeClickPayload : JsonValue -> Result JsonError ClickPayload
decodeClickPayload = json =>
  field "button" decodeInt json |> bind (button =>
    field "alt" decodeBool json |> bind (alt =>
      field "ctrl" decodeBool json |> bind (ctrl =>
        field "shift" decodeBool json |> bind (shift =>
          field "meta" decodeBool json |> bind (meta =>
            Ok { button, alt, ctrl, shift, meta }
          )
        )
      )
    )
  )

encodeInputPayload : InputPayload -> JsonValue
encodeInputPayload = p => encodeObject [("value", encodeText p.value)]

decodeInputPayload : JsonValue -> Result JsonError InputPayload
decodeInputPayload = json =>
  field "value" decodeText json |> bind (value =>
    Ok { value }
  )

encodeKeyPayload : KeyPayload -> JsonValue
encodeKeyPayload = p => encodeObject [
  ("key", encodeText p.key)
  ("code", encodeText p.code)
  ("alt", encodeBool p.alt)
  ("ctrl", encodeBool p.ctrl)
  ("shift", encodeBool p.shift)
  ("meta", encodeBool p.meta)
  ("repeat", encodeBool p.repeat)
  ("isComposing", encodeBool p.isComposing)
]

decodeKeyPayload : JsonValue -> Result JsonError KeyPayload
decodeKeyPayload = json =>
  field "key" decodeText json |> bind (key =>
    field "code" decodeText json |> bind (code =>
      field "alt" decodeBool json |> bind (alt =>
        field "ctrl" decodeBool json |> bind (ctrl =>
          field "shift" decodeBool json |> bind (shift =>
            field "meta" decodeBool json |> bind (meta =>
              field "repeat" decodeBool json |> bind (repeat =>
                field "isComposing" decodeBool json |> bind (isComposing =>
                  Ok { key, code, alt, ctrl, shift, meta, repeat, isComposing }
                )
              )
            )
          )
        )
      )
    )
  )

encodePointerPayload : PointerPayload -> JsonValue
encodePointerPayload = p => encodeObject [
  ("pointerId", encodeInt p.pointerId)
  ("pointerType", encodeText p.pointerType)
  ("button", encodeInt p.button)
  ("buttons", encodeInt p.buttons)
  ("clientX", encodeInt p.clientX)
  ("clientY", encodeInt p.clientY)
  ("alt", encodeBool p.alt)
  ("ctrl", encodeBool p.ctrl)
  ("shift", encodeBool p.shift)
  ("meta", encodeBool p.meta)
]

decodePointerPayload : JsonValue -> Result JsonError PointerPayload
decodePointerPayload = json =>
  field "pointerId" decodeInt json |> bind (pointerId =>
    field "pointerType" decodeText json |> bind (pointerType =>
      field "button" decodeInt json |> bind (button =>
        field "buttons" decodeInt json |> bind (buttons =>
          field "clientX" decodeInt json |> bind (clientX =>
            field "clientY" decodeInt json |> bind (clientY =>
              field "alt" decodeBool json |> bind (alt =>
                field "ctrl" decodeBool json |> bind (ctrl =>
                  field "shift" decodeBool json |> bind (shift =>
                    field "meta" decodeBool json |> bind (meta =>
                      Ok { pointerId, pointerType, button, buttons, clientX, clientY,
                        alt, ctrl, shift, meta
                      }
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )

encodeEventPayload : EventPayload -> (Text, JsonValue)
encodeEventPayload = payload => payload match
  | ClickEvt p   => ("click", encodeClickPayload p)
  | InputEvt p   => ("input", encodeInputPayload p)
  | KeyDownEvt p => ("keydown", encodeKeyPayload p)
  | KeyUpEvt p   => ("keyup", encodeKeyPayload p)
  | PtrDownEvt p => ("pointerdown", encodePointerPayload p)
  | PtrUpEvt p   => ("pointerup", encodePointerPayload p)
  | PtrMoveEvt p => ("pointermove", encodePointerPayload p)

decodeEventPayload : Text -> JsonValue -> Result JsonError EventPayload
decodeEventPayload = kind pJson => kind match
  | "click"       => decodeClickPayload pJson |> map ClickEvt
  | "input"       => decodeInputPayload pJson |> map InputEvt
  | "keydown"     => decodeKeyPayload pJson |> map KeyDownEvt
  | "keyup"       => decodeKeyPayload pJson |> map KeyUpEvt
  | "pointerdown" => decodePointerPayload pJson |> map PtrDownEvt
  | "pointerup"   => decodePointerPayload pJson |> map PtrUpEvt
  | "pointermove" => decodePointerPayload pJson |> map PtrMoveEvt
  | _             => Err { message: "unknown event kind: { kind }" }

// ---------------------------------------------------------------------------
// IntersectionEntry encode / decode
// ---------------------------------------------------------------------------

encodeIntersectionEntry : IntersectionEntry -> JsonValue
encodeIntersectionEntry = e => encodeObject [
  ("tid", encodeInt e.tid)
  ("isIntersecting", encodeBool e.isIntersecting)
  ("ratio", encodeFloat e.ratio)
]

decodeIntersectionEntry : JsonValue -> Result JsonError IntersectionEntry
decodeIntersectionEntry = json =>
  field "tid" decodeInt json |> bind (tid =>
    field "isIntersecting" decodeBool json |> bind (isIntersecting =>
      field "ratio" decodeFloat json |> bind (ratio =>
        Ok { tid, isIntersecting, ratio }
      )
    )
  )

// ---------------------------------------------------------------------------
// PlatformEvent decode
// ---------------------------------------------------------------------------

decodePlatformEvent : Text -> Text -> Result JsonError PlatformEvent
decodePlatformEvent = kind rawPJson => {
  parsed = decode rawPJson
  parsed |> bind (pJson => kind match
    | "popstate" =>
          decodeUrlInfo pJson |> map PopState
    | "hashchange" =>
          field "url" decodeUrlInfo pJson |> bind (url =>
            field "oldURL" decodeText pJson |> bind (oldURL =>
              field "newURL" decodeText pJson |> bind (newURL =>
                field "hash" decodeText pJson |> bind (hash =>
                  Ok (HashChange { url, oldURL, newURL, hash })
                )
              )
            )
          )
    | "visibility" =>
          field "state" decodeText pJson |> bind (state =>
            Ok (Visibility { state })
          )
    | "focus" =>
          field "focused" decodeBool pJson |> bind (focused =>
            Ok (WindowFocus { focused })
          )
    | "online" =>
          field "online" decodeBool pJson |> bind (online =>
            Ok (Online { online })
          )
    | "intersection" =>
          field "sid" decodeInt pJson |> bind (sid =>
            field "entries" (decodeList decodeIntersectionEntry) pJson |> bind (entries =>
              Ok (Intersection { sid, entries })
            )
          )
    | _ => Err { message: "unknown platform kind: { kind }" }
      )
}

// ---------------------------------------------------------------------------
// IntersectionTarget / IntersectionOptions encode / decode
// ---------------------------------------------------------------------------

encodeIntersectionTarget : IntersectionTarget -> JsonValue
encodeIntersectionTarget = t => encodeObject [
  ("tid", encodeInt t.tid)
  ("nodeId", encodeText t.nodeId)
]

decodeIntersectionTarget : JsonValue -> Result JsonError IntersectionTarget
decodeIntersectionTarget = json =>
  field "tid" decodeInt json |> bind (tid =>
    field "nodeId" decodeText json |> bind (nodeId =>
      Ok { tid, nodeId }
    )
  )

encodeIntersectionOptions : IntersectionOptions -> JsonValue
encodeIntersectionOptions = o => encodeObject [
  ("rootMargin", encodeText o.rootMargin)
  ("threshold", encodeArray (map encodeFloat o.threshold))
]

decodeIntersectionOptions : JsonValue -> Result JsonError IntersectionOptions
decodeIntersectionOptions = json =>
  field "rootMargin" decodeText json |> bind (rootMargin =>
    field "threshold" (decodeList decodeFloat) json |> bind (threshold =>
      Ok { rootMargin, threshold }
    )
  )

// ---------------------------------------------------------------------------
// ClipboardOp encode / decode
// ---------------------------------------------------------------------------

encodeClipboardOp : ClipboardOp -> JsonValue
encodeClipboardOp = op => op match
  | ReadText           => encodeObject [("kind", encodeText "clipboard.readText")]
  | WriteText { text } => encodeObject [
    ("kind", encodeText "clipboard.writeText")
    ("text", encodeText text)
  ]

decodeClipboardOp : JsonValue -> Result JsonError ClipboardOp
decodeClipboardOp = json => field "kind" decodeText json |> bind (kind => kind match
  | "clipboard.readText"  => Ok ReadText
  | "clipboard.writeText" =>
      field "text" decodeText json |> bind (text =>
        Ok (WriteText { text })
      )
  | _ => Err { message: "unknown clipboard op kind: { kind }" }
    )

// ---------------------------------------------------------------------------
// ClientMsg encode / decode
// ---------------------------------------------------------------------------

encodeClientMsg : ClientMsg -> Text
encodeClientMsg = msg => msg match
  | Hello h => toJsonText [
    ("t", encodeText "hello")
    ("viewId", encodeText h.viewId)
    ("url", encodeText h.url)
    ("online", encodeBool h.online)
  ]
  | Event e => toJsonText [
    ("t", encodeText "event")
    ("viewId", encodeText e.viewId)
    ("hid", encodeInt e.hid)
    ("kind", encodeText e.kind)
    ("p", e.p)
  ]
  | Platform p => toJsonText [
    ("t", encodeText "platform")
    ("viewId", encodeText p.viewId)
    ("kind", encodeText p.kind)
    ("p", p.p)
  ]
  | EffectResult r => toJsonText [
    ("t", encodeText "effectResult")
    ("viewId", encodeText r.viewId)
    ("rid", encodeInt r.rid)
    ("kind", encodeText r.kind)
    ("ok", encodeBool r.ok)
    ("p", r.p)
  ]

decodeClientMsg : Text -> Result JsonError ClientMsg
decodeClientMsg = raw => decode raw |> bind (json => field "t" decodeText json |> bind (t => t match
  | "hello" =>
          field "viewId" decodeText json |> bind (viewId =>
            field "url" decodeText json |> bind (url =>
              field "online" decodeBool json |> bind (online =>
                Ok (Hello { viewId, url, online })
              )
            )
          )
  | "event" =>
          field "viewId" decodeText json |> bind (viewId =>
            field "hid" decodeInt json |> bind (hid =>
              field "kind" decodeText json |> bind (kind =>
                decodeField "p" json |> bind (p =>
                  Ok (Event { viewId, hid, kind, p })
                )
              )
            )
          )
  | "platform" =>
          field "viewId" decodeText json |> bind (viewId =>
            field "kind" decodeText json |> bind (kind =>
              decodeField "p" json |> bind (p =>
                Ok (Platform { viewId, kind, p })
              )
            )
          )
  | "effectResult" =>
          field "viewId" decodeText json |> bind (viewId =>
            field "rid" decodeInt json |> bind (rid =>
              field "kind" decodeText json |> bind (kind =>
                field "ok" decodeBool json |> bind (ok =>
                  decodeField "p" json |> bind (p =>
                    Ok (EffectResult { viewId, rid, kind, ok, p })
                  )
                )
              )
            )
          )
  | _ => Err { message: "unknown ClientMsg type: { t }" }
      )
    )

// ---------------------------------------------------------------------------
// ServerMsg encode / decode
// ---------------------------------------------------------------------------

encodeServerMsg : ServerMsg -> Text
encodeServerMsg = msg => msg match
  | Patch { ops } => toJsonText [
    ("t", encodeText "patch")
    ("ops", encodeText ops)
  ]
  | Error { code, detail } => toJsonText [
    ("t", encodeText "error")
    ("code", encodeText code)
    ("detail", encodeText detail)
  ]
  | SubscribeIntersect { sid, options, targets } => toJsonText [
    ("t", encodeText "subscribeIntersect")
    ("sid", encodeInt sid)
    ("options", encodeIntersectionOptions options)
    ("targets", encodeArray (map encodeIntersectionTarget targets))
  ]
  | UnsubscribeIntersect { sid } => toJsonText [
    ("t", encodeText "unsubscribeIntersect")
    ("sid", encodeInt sid)
  ]
  | EffectReq { rid, op } => toJsonText [
    ("t", encodeText "effectReq")
    ("rid", encodeInt rid)
    ("op", encodeClipboardOp op)
  ]

decodeServerMsg : Text -> Result JsonError ServerMsg
decodeServerMsg = raw => decode raw |> bind (json => field "t" decodeText json |> bind (t => t match
  | "patch" =>
          field "ops" decodeText json |> bind (ops =>
            Ok (Patch { ops })
          )
  | "error" =>
          field "code" decodeText json |> bind (code =>
            field "detail" decodeText json |> bind (detail =>
              Ok (Error { code, detail })
            )
          )
  | "subscribeIntersect" =>
          field "sid" decodeInt json |> bind (sid =>
            field "options" decodeIntersectionOptions json |> bind (options =>
              field "targets" (decodeList decodeIntersectionTarget) json |> bind (targets =>
                Ok (SubscribeIntersect { sid, options, targets })
              )
            )
          )
  | "unsubscribeIntersect" =>
          field "sid" decodeInt json |> bind (sid =>
            Ok (UnsubscribeIntersect { sid })
          )
  | "effectReq" =>
          field "rid" decodeInt json |> bind (rid =>
            field "op" decodeClipboardOp json |> bind (op =>
              Ok (EffectReq { rid, op })
            )
          )
  | _ => Err { message: "unknown ServerMsg type: { t }" }
      )
    )

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

@test "client msg hello roundtrip"
clientMsgHelloRoundtrip = do Effect {
  orig = Hello { viewId: "abc-123", url: "https://example.com/", online: True }
  encoded = encodeClientMsg orig
  decoded = decodeClientMsg encoded
  assertEq decoded (Ok orig)
}

@test "client msg event click roundtrip"
clientMsgEventClickRoundtrip = do Effect {
  p = encodeClickPayload { button: 0, alt: False, ctrl: False, shift: False, meta: False }
  orig = Event { viewId: "v1", hid: 42, kind: "click", p: p }
  encoded = encodeClientMsg orig
  decoded = decodeClientMsg encoded
  assertEq decoded (Ok orig)
}

@test "server msg patch roundtrip"
serverMsgPatchRoundtrip = do Effect {
  orig = Patch { ops: "[\{\"op\":\"setText\",\"id\":\"n1\",\"text\":\"hi\"\}]" }
  encoded = encodeServerMsg orig
  decoded = decodeServerMsg encoded
  assertEq decoded (Ok orig)
}

@test "server msg effect req clipboard read text roundtrip"
serverMsgEffectReqClipboardReadTextRoundtrip = do Effect {
  orig = EffectReq { rid: 1, op: ReadText }
  encoded = encodeServerMsg orig
  decoded = decodeServerMsg encoded
  assertEq decoded (Ok orig)
}

@test "server msg effect req clipboard write text roundtrip"
serverMsgEffectReqClipboardWriteTextRoundtrip = do Effect {
  orig = EffectReq { rid: 2, op: WriteText { text: "copied" } }
  encoded = encodeServerMsg orig
  decoded = decodeServerMsg encoded
  assertEq decoded (Ok orig)
}

@test "platform pop state decode"
platformPopStateDecode = do Effect {
  pJson = "\{\"href\":\"https://x.com/a\",\"path\":\"/a\",\"query\":\"?q=1\",\"hash\":\"#top\"\}"
  result = decodePlatformEvent "popstate" pJson
  expected = PopState { href: "https://x.com/a", path: "/a", query: "?q=1", hash: "#top" }
  assertEq result (Ok expected)
}

@test "platform intersection decode"
platformIntersectionDecode = do Effect {
  pJson = "\{\"sid\":7,\"entries\":[\{\"tid\":1,\"isIntersecting\":true,\"ratio\":0.5\}]\}"
  result = decodePlatformEvent "intersection" pJson
  expected = Intersection {
    sid: 7
    entries: [{ tid: 1, isIntersecting: True, ratio: 0.5 }]
  }
  assertEq result (Ok expected)
}

@test "event payload click decode"
eventPayloadClickDecode = do Effect {
  pJson = decode "\{\"button\":0,\"alt\":false,\"ctrl\":true,\"shift\":false,\"meta\":false\}"
  result = pJson |> bind (decodeEventPayload "click")
  expected = ClickEvt { button: 0, alt: False, ctrl: True, shift: False, meta: False }
  assertEq result (Ok expected)
}

@test "event payload pointer decode"
eventPayloadPointerDecode = do Effect {
  raw = "\{\"pointerId\":1,\"pointerType\":\"mouse\",\"button\":0,\"buttons\":1,\"clientX\":100,\"clientY\":200,\"alt\":false,\"ctrl\":false,\"shift\":false,\"meta\":false\}"
  pJson = decode raw
  result = pJson |> bind (decodeEventPayload "pointerdown")
  expected = PtrDownEvt {
    pointerId: 1, pointerType: "mouse", button: 0, buttons: 1
    clientX: 100, clientY: 200
    alt: False, ctrl: False, shift: False, meta: False
  }
  assertEq result (Ok expected)
}
