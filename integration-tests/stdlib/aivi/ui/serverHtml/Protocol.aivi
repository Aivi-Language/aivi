@no_prelude
module aivi.ui.serverHtml.Protocol

use aivi
use aivi.prelude
use aivi.testing
use aivi.json

export
ViewId, HandlerId, SubscriptionId, RequestId
UrlInfo
ClickPayload, InputPayload, KeyPayload, PointerPayload, EventPayload
IntersectionEntry, PlatformEvent
ClientMsg, ServerMsg
IntersectionTarget, IntersectionOptions, ClipboardOp
encodeClientMsg, decodeClientMsg
encodeServerMsg, decodeServerMsg
decodePlatformEvent, decodeEventPayload
encodeUrlInfo, decodeUrlInfo
encodeEventPayload, encodeClipboardOp, decodeClipboardOp
encodeIntersectionEntry

// ---------------------------------------------------------------------------
// 1a. Scalar aliases
// ---------------------------------------------------------------------------

ViewId = Text
HandlerId = Int
SubscriptionId = Int
RequestId = Int

// ---------------------------------------------------------------------------
// 1b. UrlInfo
// ---------------------------------------------------------------------------

UrlInfo = { href: Text, path: Text, query: Text, hash: Text }

// ---------------------------------------------------------------------------
// 1c. Typed event payloads
// ---------------------------------------------------------------------------

ClickPayload = { button: Int, alt: Bool, ctrl: Bool, shift: Bool, meta: Bool }

InputPayload = { value: Text }

KeyPayload = { key: Text, code: Text, alt: Bool, ctrl: Bool
  shift: Bool, meta: Bool, repeat: Bool, isComposing: Bool
}

PointerPayload = { pointerId: Int, pointerType: Text, button: Int, buttons: Int
  clientX: Int, clientY: Int
  alt: Bool, ctrl: Bool, shift: Bool, meta: Bool
}

EventPayload =
  | ClickEvt ClickPayload
  | InputEvt InputPayload
  | KeyDownEvt KeyPayload
  | KeyUpEvt KeyPayload
  | PtrDownEvt PointerPayload
  | PtrUpEvt PointerPayload
  | PtrMoveEvt PointerPayload

// ---------------------------------------------------------------------------
// 1d. Platform event ADT
// ---------------------------------------------------------------------------

IntersectionEntry = { tid: Int, isIntersecting: Bool, ratio: Float }

PlatformEvent =
  | PopState UrlInfo
  | HashChange { url: UrlInfo, oldURL: Text, newURL: Text, hash: Text }
  | Visibility { state: Text }
  | WindowFocus { focused: Bool }
  | Online { online: Bool }
  | Intersection { sid: SubscriptionId, entries: List IntersectionEntry }

// ---------------------------------------------------------------------------
// 1e. Client → Server messages
// ---------------------------------------------------------------------------

ClientMsg =
  | Hello { viewId: ViewId, url: Text, online: Bool }
  | Event { viewId: ViewId, hid: HandlerId, kind: Text, p: JsonValue }
  | Platform { viewId: ViewId, kind: Text, p: JsonValue }
  | EffectResult { viewId: ViewId, rid: RequestId, kind: Text, ok: Bool, p: JsonValue }

// ---------------------------------------------------------------------------
// 1f. Server → Client messages
// ---------------------------------------------------------------------------

IntersectionTarget = { tid: Int, nodeId: Text }
IntersectionOptions = { rootMargin: Text, threshold: List Float }

ClipboardOp =
  | ReadText
  | WriteText { text: Text }

ServerMsg =
  | Patch { ops: Text }
  | Error { code: Text, detail: Text }
  | SubscribeIntersect { sid: SubscriptionId
      options: IntersectionOptions
      targets: List IntersectionTarget
    }
  | UnsubscribeIntersect { sid: SubscriptionId }
  | EffectReq { rid: RequestId, op: ClipboardOp }

// ---------------------------------------------------------------------------
// JSON helpers
// ---------------------------------------------------------------------------

// Note: field helper removed due to typechecker polymorphism limitation;
// decodeField + decoder are inlined as two <- binds in each decoder.

// Encode a list of key-value pairs as a JSON object text
toJsonText : List (Text, JsonValue) -> Text
toJsonText = pairs => jsonToText (encodeObject pairs)

// ---------------------------------------------------------------------------
// 1g. UrlInfo encode / decode
// ---------------------------------------------------------------------------

encodeUrlInfo : UrlInfo -> JsonValue
encodeUrlInfo = u => encodeObject [
  ("href", encodeText u.href)
  ("path", encodeText u.path)
  ("query", encodeText u.query)
  ("hash", encodeText u.hash)
]

decodeUrlInfo = json => do Result {
  hrefRaw  <- decodeField "href" json
  href     <- decodeText hrefRaw
  pathRaw  <- decodeField "path" json
  path     <- decodeText pathRaw
  queryRaw <- decodeField "query" json
  query    <- decodeText queryRaw
  hashRaw  <- decodeField "hash" json
  hash     <- decodeText hashRaw
  Ok { href, path, query, hash }
}

// ---------------------------------------------------------------------------
// EventPayload encode / decode
// ---------------------------------------------------------------------------

encodeClickPayload : ClickPayload -> JsonValue
encodeClickPayload = p => encodeObject [
  ("button", encodeInt p.button)
  ("alt", encodeBool p.alt)
  ("ctrl", encodeBool p.ctrl)
  ("shift", encodeBool p.shift)
  ("meta", encodeBool p.meta)
]

decodeClickPayload = json => do Result {
  buttonRaw <- decodeField "button" json
  button    <- decodeInt buttonRaw
  altRaw    <- decodeField "alt" json
  alt       <- decodeBool altRaw
  ctrlRaw   <- decodeField "ctrl" json
  ctrl      <- decodeBool ctrlRaw
  shiftRaw  <- decodeField "shift" json
  shift     <- decodeBool shiftRaw
  metaRaw   <- decodeField "meta" json
  meta      <- decodeBool metaRaw
  Ok { button, alt, ctrl, shift, meta }
}

encodeInputPayload : InputPayload -> JsonValue
encodeInputPayload = p => encodeObject [("value", encodeText p.value)]

decodeInputPayload = json => do Result {
  valueRaw <- decodeField "value" json
  value    <- decodeText valueRaw
  Ok { value }
}

encodeKeyPayload : KeyPayload -> JsonValue
encodeKeyPayload = p => encodeObject [
  ("key", encodeText p.key)
  ("code", encodeText p.code)
  ("alt", encodeBool p.alt)
  ("ctrl", encodeBool p.ctrl)
  ("shift", encodeBool p.shift)
  ("meta", encodeBool p.meta)
  ("repeat", encodeBool p.repeat)
  ("isComposing", encodeBool p.isComposing)
]

decodeKeyPayload = json => do Result {
  keyRaw         <- decodeField "key" json
  key            <- decodeText keyRaw
  codeRaw        <- decodeField "code" json
  code           <- decodeText codeRaw
  altRaw         <- decodeField "alt" json
  alt            <- decodeBool altRaw
  ctrlRaw        <- decodeField "ctrl" json
  ctrl           <- decodeBool ctrlRaw
  shiftRaw       <- decodeField "shift" json
  shift          <- decodeBool shiftRaw
  metaRaw        <- decodeField "meta" json
  meta           <- decodeBool metaRaw
  repeatRaw      <- decodeField "repeat" json
  repeat         <- decodeBool repeatRaw
  isComposingRaw <- decodeField "isComposing" json
  isComposing    <- decodeBool isComposingRaw
  Ok { key, code, alt, ctrl, shift, meta, repeat, isComposing }
}

encodePointerPayload : PointerPayload -> JsonValue
encodePointerPayload = p => encodeObject [
  ("pointerId", encodeInt p.pointerId)
  ("pointerType", encodeText p.pointerType)
  ("button", encodeInt p.button)
  ("buttons", encodeInt p.buttons)
  ("clientX", encodeInt p.clientX)
  ("clientY", encodeInt p.clientY)
  ("alt", encodeBool p.alt)
  ("ctrl", encodeBool p.ctrl)
  ("shift", encodeBool p.shift)
  ("meta", encodeBool p.meta)
]

decodePointerPayload = json => do Result {
  pointerIdRaw   <- decodeField "pointerId" json
  pointerId      <- decodeInt pointerIdRaw
  pointerTypeRaw <- decodeField "pointerType" json
  pointerType    <- decodeText pointerTypeRaw
  buttonRaw      <- decodeField "button" json
  button         <- decodeInt buttonRaw
  buttonsRaw     <- decodeField "buttons" json
  buttons        <- decodeInt buttonsRaw
  clientXRaw     <- decodeField "clientX" json
  clientX        <- decodeInt clientXRaw
  clientYRaw     <- decodeField "clientY" json
  clientY        <- decodeInt clientYRaw
  altRaw         <- decodeField "alt" json
  alt            <- decodeBool altRaw
  ctrlRaw        <- decodeField "ctrl" json
  ctrl           <- decodeBool ctrlRaw
  shiftRaw       <- decodeField "shift" json
  shift          <- decodeBool shiftRaw
  metaRaw        <- decodeField "meta" json
  meta           <- decodeBool metaRaw
  Ok { pointerId, pointerType, button, buttons, clientX, clientY
    alt, ctrl, shift, meta
}
}

encodeEventPayload : EventPayload -> (Text, JsonValue)
encodeEventPayload = payload => payload match
  | ClickEvt p   => ("click", encodeClickPayload p)
  | InputEvt p   => ("input", encodeInputPayload p)
  | KeyDownEvt p => ("keydown", encodeKeyPayload p)
  | KeyUpEvt p   => ("keyup", encodeKeyPayload p)
  | PtrDownEvt p => ("pointerdown", encodePointerPayload p)
  | PtrUpEvt p   => ("pointerup", encodePointerPayload p)
  | PtrMoveEvt p => ("pointermove", encodePointerPayload p)

decodeEventPayload = kind pJson => kind match
  | "click" => do Result {
      p <- decodeClickPayload pJson
      Ok (ClickEvt p)
    }
  | "input" => do Result {
      p <- decodeInputPayload pJson
      Ok (InputEvt p)
    }
  | "keydown" => do Result {
      p <- decodeKeyPayload pJson
      Ok (KeyDownEvt p)
    }
  | "keyup" => do Result {
      p <- decodeKeyPayload pJson
      Ok (KeyUpEvt p)
    }
  | "pointerdown" => do Result {
      p <- decodePointerPayload pJson
      Ok (PtrDownEvt p)
    }
  | "pointerup" => do Result {
      p <- decodePointerPayload pJson
      Ok (PtrUpEvt p)
    }
  | "pointermove" => do Result {
      p <- decodePointerPayload pJson
      Ok (PtrMoveEvt p)
    }
  | _ => Err { message: "unknown event kind: { kind }" }

// ---------------------------------------------------------------------------
// IntersectionEntry encode / decode
// ---------------------------------------------------------------------------

encodeIntersectionEntry : IntersectionEntry -> JsonValue
encodeIntersectionEntry = e => encodeObject [
  ("tid", encodeInt e.tid)
  ("isIntersecting", encodeBool e.isIntersecting)
  ("ratio", encodeFloat e.ratio)
]

decodeIntersectionEntry = json => do Result {
  tidRaw            <- decodeField "tid" json
  tid               <- decodeInt tidRaw
  isIntersectingRaw <- decodeField "isIntersecting" json
  isIntersecting    <- decodeBool isIntersectingRaw
  ratioRaw          <- decodeField "ratio" json
  ratio             <- decodeFloat ratioRaw
  Ok { tid: tid, isIntersecting: isIntersecting, ratio: ratio }
}

// ---------------------------------------------------------------------------
// PlatformEvent decode
// ---------------------------------------------------------------------------

decodePlatformEventInner = kind pJson => kind match
  | "popstate" => do Result {
      url <- decodeUrlInfo pJson
      Ok (PopState url)
    }
  | "hashchange" => do Result {
      urlRaw    <- decodeField "url" pJson
      url       <- decodeUrlInfo urlRaw
      oldURLRaw <- decodeField "oldURL" pJson
      oldURL    <- decodeText oldURLRaw
      newURLRaw <- decodeField "newURL" pJson
      newURL    <- decodeText newURLRaw
      hashRaw   <- decodeField "hash" pJson
      hash      <- decodeText hashRaw
      Ok (HashChange { url: url, oldURL: oldURL, newURL: newURL, hash: hash })
    }
  | "visibility" => do Result {
      stateRaw <- decodeField "state" pJson
      state    <- decodeText stateRaw
      Ok (Visibility { state: state })
    }
  | "focus" => do Result {
      focusedRaw <- decodeField "focused" pJson
      focused    <- decodeBool focusedRaw
      Ok (WindowFocus { focused: focused })
    }
  | "online" => do Result {
      onlineRaw <- decodeField "online" pJson
      online    <- decodeBool onlineRaw
      Ok (Online { online: online })
    }
  | "intersection" => do Result {
      sidRaw     <- decodeField "sid" pJson
      sid        <- decodeInt sidRaw
      entriesRaw <- decodeField "entries" pJson
      entries    <- decodeList decodeIntersectionEntry entriesRaw
      Ok (Intersection { sid: sid, entries: entries })
    }
  | _ => Err { message: "unknown platform kind: { kind }" }

decodePlatformEvent = kind rawPJson => do Result {
  pJson <- decode rawPJson
  decodePlatformEventInner kind pJson
}

// ---------------------------------------------------------------------------
// IntersectionTarget / IntersectionOptions encode / decode
// ---------------------------------------------------------------------------

encodeIntersectionTarget : IntersectionTarget -> JsonValue
encodeIntersectionTarget = t => encodeObject [
  ("tid", encodeInt t.tid)
  ("nodeId", encodeText t.nodeId)
]

decodeIntersectionTarget = json => do Result {
  tidRaw    <- decodeField "tid" json
  tid       <- decodeInt tidRaw
  nodeIdRaw <- decodeField "nodeId" json
  nodeId    <- decodeText nodeIdRaw
  Ok { tid, nodeId }
}

encodeIntersectionOptions : IntersectionOptions -> JsonValue
encodeIntersectionOptions = o => encodeObject [
  ("rootMargin", encodeText o.rootMargin)
  ("threshold", encodeArray (each encodeFloat o.threshold))
]

decodeIntersectionOptions = json => do Result {
  rootMarginRaw <- decodeField "rootMargin" json
  rootMargin    <- decodeText rootMarginRaw
  thresholdRaw  <- decodeField "threshold" json
  threshold     <- decodeList decodeFloat thresholdRaw
  Ok { rootMargin, threshold }
}

// ---------------------------------------------------------------------------
// ClipboardOp encode / decode
// ---------------------------------------------------------------------------

encodeClipboardOp : ClipboardOp -> JsonValue
encodeClipboardOp = op => op match
  | ReadText           => encodeObject [("kind", encodeText "clipboard.readText")]
  | WriteText { text } => encodeObject [
    ("kind", encodeText "clipboard.writeText")
    ("text", encodeText text)
  ]

decodeClipboardOp = json => do Result {
  kindRaw <- decodeField "kind" json
  kind    <- decodeText kindRaw
  kind match
    | "clipboard.readText"  => Ok ReadText
    | "clipboard.writeText" => decodeField "text" json match
      | Err e                 => Err e
      | Ok textRaw            => decodeText textRaw match
        | Err e                 => Err e
        | Ok text               => Ok (WriteText { text: text })
        | _                     => Err { message: "unknown clipboard op kind: { kind }" }
}

// ---------------------------------------------------------------------------
// ClientMsg encode / decode
// ---------------------------------------------------------------------------

encodeClientMsg : ClientMsg -> Text
encodeClientMsg = msg => msg match
  | Hello h => toJsonText [
    ("t", encodeText "hello")
    ("viewId", encodeText h.viewId)
    ("url", encodeText h.url)
    ("online", encodeBool h.online)
  ]
  | Event e => toJsonText [
    ("t", encodeText "event")
    ("viewId", encodeText e.viewId)
    ("hid", encodeInt e.hid)
    ("kind", encodeText e.kind)
    ("p", e.p)
  ]
  | Platform p => toJsonText [
    ("t", encodeText "platform")
    ("viewId", encodeText p.viewId)
    ("kind", encodeText p.kind)
    ("p", p.p)
  ]
  | EffectResult r => toJsonText [
    ("t", encodeText "effectResult")
    ("viewId", encodeText r.viewId)
    ("rid", encodeInt r.rid)
    ("kind", encodeText r.kind)
    ("ok", encodeBool r.ok)
    ("p", r.p)
  ]

decodeClientMsgInner = t json => t match
  | "hello" => do Result {
      viewIdRaw <- decodeField "viewId" json
      viewId    <- decodeText viewIdRaw
      urlRaw    <- decodeField "url" json
      url       <- decodeText urlRaw
      onlineRaw <- decodeField "online" json
      online    <- decodeBool onlineRaw
      Ok (Hello { viewId: viewId, url: url, online: online })
    }
  | "event" => do Result {
      viewIdRaw <- decodeField "viewId" json
      viewId    <- decodeText viewIdRaw
      hidRaw    <- decodeField "hid" json
      hid       <- decodeInt hidRaw
      kindRaw   <- decodeField "kind" json
      kind      <- decodeText kindRaw
      p         <- decodeField "p" json
      Ok (Event { viewId: viewId, hid: hid, kind: kind, p: p })
    }
  | "platform" => do Result {
      viewIdRaw <- decodeField "viewId" json
      viewId    <- decodeText viewIdRaw
      kindRaw   <- decodeField "kind" json
      kind      <- decodeText kindRaw
      p         <- decodeField "p" json
      Ok (Platform { viewId: viewId, kind: kind, p: p })
    }
  | "effectResult" => do Result {
      viewIdRaw <- decodeField "viewId" json
      viewId    <- decodeText viewIdRaw
      ridRaw    <- decodeField "rid" json
      rid       <- decodeInt ridRaw
      kindRaw   <- decodeField "kind" json
      kind      <- decodeText kindRaw
      okRaw     <- decodeField "ok" json
      ok        <- decodeBool okRaw
      p         <- decodeField "p" json
      Ok (EffectResult { viewId: viewId, rid: rid, kind: kind, ok: ok, p: p })
    }
  | _ => Err { message: "unknown ClientMsg type: { t }" }

decodeClientMsg = raw => do Result {
  json <- decode raw
  tRaw <- decodeField "t" json
  t    <- decodeText tRaw
  decodeClientMsgInner t json
}

// ---------------------------------------------------------------------------
// ServerMsg encode / decode
// ---------------------------------------------------------------------------

encodeServerMsg : ServerMsg -> Text
encodeServerMsg = msg => msg match
  | Patch { ops } => toJsonText [
    ("t", encodeText "patch")
    ("ops", encodeText ops)
  ]
  | Error { code, detail } => toJsonText [
    ("t", encodeText "error")
    ("code", encodeText code)
    ("detail", encodeText detail)
  ]
  | SubscribeIntersect { sid, options, targets } => toJsonText [
    ("t", encodeText "subscribeIntersect")
    ("sid", encodeInt sid)
    ("options", encodeIntersectionOptions options)
    ("targets", encodeArray (each encodeIntersectionTarget targets))
  ]
  | UnsubscribeIntersect { sid } => toJsonText [
    ("t", encodeText "unsubscribeIntersect")
    ("sid", encodeInt sid)
  ]
  | EffectReq { rid, op } => toJsonText [
    ("t", encodeText "effectReq")
    ("rid", encodeInt rid)
    ("op", encodeClipboardOp op)
  ]

decodeServerMsgInner = t json => t match
  | "patch" => do Result {
      opsRaw <- decodeField "ops" json
      ops    <- decodeText opsRaw
      Ok (Patch { ops: ops })
    }
  | "error" => do Result {
      codeRaw   <- decodeField "code" json
      code      <- decodeText codeRaw
      detailRaw <- decodeField "detail" json
      detail    <- decodeText detailRaw
      Ok (Error { code: code, detail: detail })
    }
  | "subscribeIntersect" => do Result {
      sidRaw     <- decodeField "sid" json
      sid        <- decodeInt sidRaw
      optionsRaw <- decodeField "options" json
      targetsRaw <- decodeField "targets" json
      decodeIntersectionOptions optionsRaw match
        | Err e      => Err e
        | Ok options => decodeList decodeIntersectionTarget targetsRaw match
          | Err e      => Err e
          | Ok targets => Ok (SubscribeIntersect { sid: sid, options: options, targets: targets })
    }
  | "unsubscribeIntersect" => do Result {
      sidRaw <- decodeField "sid" json
      sid    <- decodeInt sidRaw
      Ok (UnsubscribeIntersect { sid: sid })
    }
  | "effectReq" => do Result {
      ridRaw <- decodeField "rid" json
      rid    <- decodeInt ridRaw
      opRaw  <- decodeField "op" json
      decodeClipboardOp opRaw match
        | Err e => Err e
        | Ok op => Ok (EffectReq { rid: rid, op: op })
    }
  | _ => Err { message: "unknown ServerMsg type: { t }" }

decodeServerMsg = raw => do Result {
  json <- decode raw
  tRaw <- decodeField "t" json
  t    <- decodeText tRaw
  decodeServerMsgInner t json
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

@test "client msg hello roundtrip"
clientMsgHelloRoundtrip = do Effect {
  orig = Hello { viewId: "abc-123", url: "https://example.com/", online: True }
  encoded = encodeClientMsg orig
  decoded = decodeClientMsg encoded
  assertEq decoded (Ok orig)
}

@test "client msg event click roundtrip"
clientMsgEventClickRoundtrip = do Effect {
  p = encodeClickPayload { button: 0, alt: False, ctrl: False, shift: False, meta: False }
  orig = Event { viewId: "v1", hid: 42, kind: "click", p: p }
  encoded = encodeClientMsg orig
  decoded = decodeClientMsg encoded
  assertEq decoded (Ok orig)
}

@test "server msg patch roundtrip"
serverMsgPatchRoundtrip = do Effect {
  orig = Patch { ops: "[\{\"op\":\"setText\",\"id\":\"n1\",\"text\":\"hi\"\}]" }
  encoded = encodeServerMsg orig
  decoded = decodeServerMsg encoded
  assertEq decoded (Ok orig)
}

@test "server msg effect req clipboard read text roundtrip"
serverMsgEffectReqClipboardReadTextRoundtrip = do Effect {
  orig = EffectReq { rid: 1, op: ReadText }
  encoded = encodeServerMsg orig
  decoded = decodeServerMsg encoded
  assertEq decoded (Ok orig)
}

@test "server msg effect req clipboard write text roundtrip"
serverMsgEffectReqClipboardWriteTextRoundtrip = do Effect {
  orig = EffectReq { rid: 2, op: WriteText { text: "copied" } }
  encoded = encodeServerMsg orig
  decoded = decodeServerMsg encoded
  assertEq decoded (Ok orig)
}

@test "platform pop state decode"
platformPopStateDecode = do Effect {
  pJson = "\{\"href\":\"https://x.com/a\",\"path\":\"/a\",\"query\":\"?q=1\",\"hash\":\"#top\"\}"
  result = decodePlatformEvent "popstate" pJson
  expected = PopState { href: "https://x.com/a", path: "/a", query: "?q=1", hash: "#top" }
  assertEq result (Ok expected)
}

@test "platform intersection decode"
platformIntersectionDecode = do Effect {
  pJson = "\{\"sid\":7,\"entries\":[\{\"tid\":1,\"isIntersecting\":true,\"ratio\":0.5\}]\}"
  result = decodePlatformEvent "intersection" pJson
  expected = Intersection {
    sid: 7
    entries: [{ tid: 1, isIntersecting: True, ratio: 0.5 }]
  }
  assertEq result (Ok expected)
}

@test "event payload click decode"
eventPayloadClickDecode = do Effect {
  pJson = decode "\{\"button\":0,\"alt\":false,\"ctrl\":true,\"shift\":false,\"meta\":false\}"
  result = do Result {
    json <- pJson
    decodeEventPayload "click" json
  }
  expected = ClickEvt { button: 0, alt: False, ctrl: True, shift: False, meta: False }
  assertEq result (Ok expected)
}

@test "event payload pointer decode"
eventPayloadPointerDecode = do Effect {
  raw = "\{\"pointerId\":1,\"pointerType\":\"mouse\",\"button\":0,\"buttons\":1,\"clientX\":100,\"clientY\":200,\"alt\":false,\"ctrl\":false,\"shift\":false,\"meta\":false\}"
  pJson = decode raw
  result = do Result {
    json <- pJson
    decodeEventPayload "pointerdown" json
  }
  expected = PtrDownEvt {
    pointerId: 1, pointerType: "mouse", button: 0, buttons: 1
    clientX: 100, clientY: 200
    alt: False, ctrl: False, shift: False, meta: False
  }
  assertEq result (Ok expected)
}
