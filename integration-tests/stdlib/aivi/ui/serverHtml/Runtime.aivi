@no_prelude
module aivi.ui.serverHtml.Runtime

use aivi
use aivi.testing
use aivi.collections
use aivi.json (JsonValue, jsonToText)
use aivi.ui
use aivi.ui.serverHtml.Protocol
use aivi.net.httpServer (WsError, WebSocket, wsSend, TextMsg) // -- DOCS: verify names

export
ClipboardError, PendingEntry, ServerEffect, ViewState
assignHandlers, runUpdate

// ---------------------------------------------------------------------------
// 2a. ClipboardError
// ---------------------------------------------------------------------------

ClipboardError =
  | PermissionDenied
  | Unavailable
  | Other Text

// ---------------------------------------------------------------------------
// 2b. PendingEntry
// ---------------------------------------------------------------------------

PendingEntry msg =
  | ReadPending (Result ClipboardError Text -> msg)
  | WritePending (Result ClipboardError Unit -> msg)

// ---------------------------------------------------------------------------
// 2c. ServerEffect
// ---------------------------------------------------------------------------

ServerEffect msg =
  | SubscribeIntersectEff SubscriptionId IntersectionOptions (List IntersectionTarget)
  | UnsubscribeIntersectEff SubscriptionId
  | RequestClipboard RequestId ClipboardOp

// ---------------------------------------------------------------------------
// 2d. ViewState
// ---------------------------------------------------------------------------

ViewState model msg = {
  viewId: ViewId
  model: model
  lastVdom: VNode msg
  handlerTable: Map HandlerId (EventPayload -> Option msg)
  nextHid: HandlerId
  nextRid: RequestId
  pendingTable: Map RequestId (PendingEntry msg)
  intersections: Map SubscriptionId {
    options: IntersectionOptions
    targets: List IntersectionTarget
  }
}

// ---------------------------------------------------------------------------
// 2e. Handler assignment
// ---------------------------------------------------------------------------

// Convert an event-handler Attr to a (kind, handler-fn) pair, if applicable.
extractHandler
: Attr msg
-> Option (Text, EventPayload -> Option msg)
extractHandler = attr => attr match
  | OnClickE f      => Some ("click", ep => ep ? | ClickEvt p => Some (f p) | _ => None)
  | OnInputE f      => Some ("input", ep => ep ? | InputEvt p => Some (f p) | _ => None)
  | OnKeyDown f     => Some ("keydown", ep => ep ? | KeyDownEvt p => Some (f p) | _ => None)
  | OnKeyUp f       => Some ("keyup", ep => ep ? | KeyUpEvt p => Some (f p) | _ => None)
  | OnPointerDown f => Some ("pointerdown", ep => ep ? | PtrDownEvt p => Some (f p) | _ => None)
  | OnPointerUp f   => Some ("pointerup", ep => ep ? | PtrUpEvt p => Some (f p) | _ => None)
  | OnPointerMove f => Some ("pointermove", ep => ep ? | PtrMoveEvt p => Some (f p) | _ => None)
  | OnFocus m       => Some ("focus", _ => Some m)
  | OnBlur m        => Some ("blur", _ => Some m)
  | _               => None

// Partition attrs into (non-handler attrs, list of (kind, handler-fn))
partitionAttrs
: List (Attr msg)
-> HandlerId
-> (List (Attr msg), Map HandlerId (EventPayload -> Option msg), HandlerId)
partitionAttrs = attrs startHid =>
  partitionAttrsGo attrs startHid [] Map.empty

partitionAttrsGo = attrs hid accAttrs accMap => attrs match
  | []                   => (reverseList accAttrs, accMap, hid)
  | [a, ...rest]         => extractHandler a match
    | Some (kind, handler) => {
      hidAttr = Attr ("data-aivi-hid-{ kind }") (toText hid) // -- DOCS: verify Attr constructor
      partitionAttrsGo rest (hid + 1)
      [hidAttr, ...accAttrs]
      (Map.insert hid handler accMap)
    }
    | None => partitionAttrsGo rest hid [a, ...accAttrs] accMap

// Assign a stable data-aivi-node attribute based on depth-first index.
// Also assigns handler ids to event attributes.
assignHandlers
: VNode msg
-> HandlerId
-> (VNode msg, Map HandlerId (EventPayload -> Option msg), HandlerId)
assignHandlers = node startHid =>
  assignWalk node startHid 0 |> (result => (result.node, result.handlers, result.nextHid))

AssignResult msg = {
  node: VNode msg
  handlers: Map HandlerId (EventPayload -> Option msg)
  nextHid: HandlerId
  nextIdx: Int
}

assignWalk : VNode msg -> HandlerId -> Int -> AssignResult msg
assignWalk = node hid idx => node match
  | TextNode t    => { node: TextNode t, handlers: Map.empty, nextHid: hid, nextIdx: idx }
  | Keyed k inner => {
    result = assignWalk inner hid idx
    { node: Keyed k result.node
    handlers: result.handlers
    nextHid: result.nextHid
    nextIdx: result.nextIdx
  }
  }
  | Element tag attrs children => {
    nodeId = toText idx
    (cleanAttrs, attrHandlers, hid2) = partitionAttrs attrs hid
    nodeAttr = Attr "data-aivi-node" nodeId
    allAttrs = [nodeAttr, ...cleanAttrs]
    childResult = assignChildrenWalk children hid2 (idx + 1)[] Map.empty
    mergedHandlers = mergeMaps attrHandlers childResult.handlers
    { node: Element tag allAttrs childResult.children
    handlers: mergedHandlers
    nextHid: childResult.nextHid
    nextIdx: childResult.nextIdx
  }
  }

AssignChildrenResult msg = {
  children: List (VNode msg)
  handlers: Map HandlerId (EventPayload -> Option msg)
  nextHid: HandlerId
  nextIdx: Int
}

assignChildrenWalk
: List (VNode msg) -> HandlerId -> Int -> List (VNode msg)
-> Map HandlerId (EventPayload -> Option msg)
-> AssignChildrenResult msg
assignChildrenWalk = nodes hid idx accChildren accHandlers => nodes match
  | [] => { children: reverseList accChildren, handlers: accHandlers
      nextHid: hid, nextIdx: idx
    }
  | [n, ...rest] => {
    result = assignWalk n hid idx
    assignChildrenWalk rest result.nextHid result.nextIdx
    [result.node, ...accChildren]
    (mergeMaps accHandlers result.handlers)
  }

// Merge two maps (second wins on conflict)
mergeMaps : Map K V -> Map K V -> Map K V
mergeMaps = base overlay =>
  mergeGo (Map.toList overlay) base

mergeGo = pairs acc => pairs match
  | []                => acc
  | [(k, v), ...rest] => mergeGo rest (Map.insert k v acc)

// Reverse a list (helper)
reverseList = xs => reverseListGo xs []

reverseListGo = xs acc => xs match
  | []        => acc
  | [h, ...t] => reverseListGo t [h, ...acc]

// ---------------------------------------------------------------------------
// 2f. Update helper
// ---------------------------------------------------------------------------

// Send a ServerMsg as JSON text over the WebSocket.
sendServerMsg : WebSocket -> ServerMsg -> Effect WsError Unit
sendServerMsg = ws msg => wsSend ws (TextMsg (encodeServerMsg msg))

// Process a list of ServerEffects, producing ServerMsgs and updating state.
processEffects
: List (ServerEffect msg)
-> WebSocket
-> Effect WsError Unit
processEffects = effects ws => effects match
  | []             => pure Unit
  | [eff, ...rest] => do Effect {
    _ <- eff match
      | SubscribeIntersectEff sid options targets =>
    sendServerMsg ws (SubscribeIntersect { sid, options, targets })
      | UnsubscribeIntersectEff sid =>
    sendServerMsg ws (UnsubscribeIntersect { sid })
      | RequestClipboard rid op =>
    sendServerMsg ws (EffectReq { rid, op })
    processEffects rest ws
  }

// The App record type is imported from ServerHtml; to avoid circular deps
// we parameterise runUpdate over the needed callbacks.
runUpdate
: msg
-> ViewState model msg
-> { update: msg -> model -> (model, List (ServerEffect msg))
  view: model -> VNode msg
}
-> WebSocket
-> Effect WsError (ViewState model msg)
runUpdate = msg state app ws => do Effect {
  (newModel, effects) = app.update msg state.model
  _ <- processEffects effects ws
  newVdom0 = app.view newModel
  (newVdom, newHandlers, nextHid) = assignHandlers newVdom0 state.nextHid
  ops = diff state.lastVdom newVdom
  _ <- ops match
    | [] => pure Unit
    | _  => sendServerMsg ws (Patch { ops: patchToJson ops })
  pure {
    viewId: state.viewId
    model: newModel
    lastVdom: newVdom
    handlerTable: newHandlers
    nextHid: nextHid
    nextRid: state.nextRid
    pendingTable: state.pendingTable
    intersections: state.intersections
  }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

@test "pending table resolve read pending ok"
pendingTableResolveReadPendingOk = do Effect {
  handler = result => result match
    | Ok t  => t
    | Err _ => "fail"
  entry = ReadPending handler
  result = entry match
    | ReadPending f  => f (Ok "clipboard text")
    | WritePending _ => "wrong branch"
  assertEq result "clipboard text"
}

@test "pending table resolve read pending err permission denied"
pendingTableResolveReadPendingErrPermissionDenied = do Effect {
  handler = result => result match
    | Ok _                 => "unexpected ok"
    | Err PermissionDenied => "denied"
    | Err _                => "other error"
  entry = ReadPending handler
  result = entry match
    | ReadPending f  => f (Err PermissionDenied)
    | WritePending _ => "wrong branch"
  assertEq result "denied"
}

@test "pending table resolve write pending ok"
pendingTableResolveWritePendingOk = do Effect {
  handler = result => result match
    | Ok Unit => "write ok"
    | Err _   => "write fail"
  entry = WritePending handler
  result = entry match
    | ReadPending _  => "wrong branch"
    | WritePending f => f (Ok Unit)
  assertEq result "write ok"
}

@test "assign handlers click emits hid attribute"
assignHandlersClickEmitsHidAttribute = do Effect {
  clickMsg = 99
  node = Element "button" [OnClickE (_ => clickMsg)] [TextNode "Click"]
  (assigned, handlers, _) = assignHandlers node 0
// The assigned node should contain a data-aivi-hid-click attribute
  assigned match
    | Element _ attrs _ => {
      hasHid = attrs |> any (a => a match
        | Attr name _ when text.startsWith "data-aivi-hid-click" name => True
        | _                                                           => False
      )
      assert hasHid
    }
    | _ => assert False
}

@test "assign handlers multiple handlers get distinct hids"
assignHandlersMultipleHandlersGetDistinctHids = do Effect {
  node = Element "div" [
    OnClickE (_ => "clicked")
    OnInputE (p => p.value)
  ] [TextNode "x"]
  (_, handlers, nextHid) = assignHandlers node 0
// Two handlers should have been assigned with distinct hids (0 and 1)
  assertEq nextHid 2
  assert (Map.get 0 handlers != None)
  assert (Map.get 1 handlers != None)
}

@test "assign handlers assigns data aivi node"
assignHandlersAssignsDataAiviNode = do Effect {
  node = Element "div" [] [
    Element "span" [] [TextNode "a"]
    Element "span" [] [TextNode "b"]
  ]
  (assigned, _, _) = assignHandlers node 0
  assigned match
    | Element _ attrs children => {
      hasNode = attrs |> any (a => a match
        | Attr "data-aivi-node" _ => True
        | _                       => False
      )
      assert hasNode
  // Each child element should also have data-aivi-node
      children |> each (child => child match
        | Element _ cAttrs _ => {
          childHasNode = cAttrs |> any (a => a match
            | Attr "data-aivi-node" _ => True
            | _                       => False
          )
          assert childHasNode
        }
        | _ => pure Unit
      )
    }
  | _ => assert False
}

@test "diff patch to json produces non empty for changed text"
diffPatchToJsonProducesNonEmptyForChangedText = do Effect {
  old = Element "p" [] [TextNode "hello"]
  neu = Element "p" [] [TextNode "world"]
  ops = diff old neu
  json = patchToJson ops
  assert (text.length json > 2) // not empty "[]"
}
