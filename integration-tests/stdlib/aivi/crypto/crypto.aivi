@no_prelude
module integrationTests.stdlib.aivi.crypto.tests

use aivi
use aivi.prelude
use aivi.testing
use aivi.crypto
use aivi.text

// -- Hashing --

@test "sha256 hello"
sha256_hello = do Effect {
  s = sha256 "hello"
  assert (s == "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824")
}

@test "sha384 hello"
sha384_hello = do Effect {
  s = sha384 "hello"
  assert (length s == 96)
}

@test "sha512 hello"
sha512_hello = do Effect {
  s = sha512 "hello"
  assert (length s == 128)
}

@test "sha256 empty"
sha256_empty = do Effect {
  s = sha256 ""
  assert (s == "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
}

// -- HMAC --

@test "hmac sha256"
hmacSha256_functional = do Effect {
  key = fromHex "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b" match
    | Ok b  => b
    | Err _ => panic "bad hex"
    msg = fromHex "4869205468657265" match
      | Ok b  => b
      | Err _ => panic "bad hex"
    tag = hmacSha256 key msg
    assert (length tag > 0)
}

@test "hmac sha512"
hmacSha512_functional = do Effect {
  key = fromHex "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b" match
    | Ok b  => b
    | Err _ => panic "bad hex"
    msg = fromHex "4869205468657265" match
      | Ok b  => b
      | Err _ => panic "bad hex"
    tag = hmacSha512 key msg
    assert (length tag > 0)
}

@test "hmac verify roundtrip"
hmacVerify_roundtrip = do Effect {
  key = fromHex "aabbccdd" match
    | Ok b  => b
    | Err _ => panic "bad hex"
    msg = fromHex "deadbeef" match
      | Ok b  => b
      | Err _ => panic "bad hex"
    tag = hmacSha256 key msg
    valid = hmacVerify key msg tag
    assert valid
}

// -- Password Hashing --

@test "hash password and verify"
hashPassword_and_verify = do Effect {
  hashed <- hashPassword "myS3cret!"
  ok     <- verifyPassword "myS3cret!" hashed
  assert ok
}

@test "verify password wrong"
verifyPassword_wrong = do Effect {
  hashed <- hashPassword "correct"
  ok     <- verifyPassword "wrong" hashed
  assert (not ok)
}

// -- Random --

@test "random bytes length"
randomBytes_length = do Effect {
  b <- randomBytes 32
  assert (length b == 32)
}

@test "random uuid format"
randomUuid_format = do Effect {
  u <- randomUuid
  assert (length u == 36)
}

// -- Utilities --

@test "to hex from hex roundtrip"
toHex_fromHex_roundtrip = do Effect {
  original <- randomBytes 16
  hex = toHex original
  decoded = fromHex hex match
    | Ok b  => b
    | Err _ => panic "fromHex failed"
    assert (secureEquals original decoded)
}

@test "secure equals same"
secureEquals_same = do Effect {
  a <- randomBytes 8
  assert (secureEquals a a)
}

@test "secure equals different"
secureEquals_different = do Effect {
  a <- randomBytes 8
  b <- randomBytes 8
  assert (not (secureEquals a b))
}
