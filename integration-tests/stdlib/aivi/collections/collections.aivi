@no_prelude
module integrationTests.stdlib.aivi.collections.tests

use aivi
use aivi.testing
use aivi.collections

@test "deque"
deque_functional = do Effect {
  d0 = Deque.empty
  d1 = Deque.pushBack 1 d0
  d2 = Deque.pushFront 0 d1

  assert (Deque.peekFront d2 == Some 0)
  assert (Deque.peekBack d2 == Some 1)

  res = Deque.popFront d2
  res match
    | Some (val, d3) => do Effect {
      assert (val == 0)
      assert (Deque.peekFront d3 == Some 1)
    }
    | None => assert False
}

@test "heap"
  heap_functional = do Effect {
    h0 = Heap.empty
    h1 = Heap.push 3 h0
    h2 = Heap.push 1 h1
    h3 = Heap.push 2 h2

    assert (Heap.peekMin h3 == Some 1)

    res = Heap.popMin h3
    res match
      | Some (val, h4) => do Effect {
        assert (val == 1)
        assert (Heap.peekMin h4 == Some 2)
      }
      | None => assert False
  }

@test "heap size"
  heapSize = do Effect {
    h0 = Heap.empty
    h1 = Heap.push 3 h0
    h2 = Heap.push 1 h1
    h3 = Heap.push 2 h2
    assert (Heap.size h3 == 3)
    assert (Heap.size h0 == 0)
  }

@test "heap from list"
  heapFromList = do Effect {
    h <- Heap.fromList [5, 1, 3, 2, 4]
    assert (Heap.size h == 5)
    assert (Heap.peekMin h == Some 1)
  }

@test "heap tuple priority"
  heapTuplePriority = do Effect {
    h0 = Heap.empty
    h1 = Heap.push (3, "c") h0
    h2 = Heap.push (1, "a") h1
    h3 = Heap.push (2, "b") h2
    res = Heap.popMin h3
    res match
      | Some ((w, n), _rest) => do Effect {
        assert (w == 1)
        assert (n == "a")
      }
      | None => assert False
  }

@test "map"
  map_functional = do Effect {
    m0 = Map.empty
    m1 = Map.insert 1 "one" m0

    assert (Map.size m0 == 0)
    assert (Map.size m1 == 1)
    assert (Map.get 1 m1 == Some "one")
    assert (Map.get 2 m1 == None)

    m2 = Map.remove 1 m1
    assert (Map.size m2 == 0)
    assert (Map.get 1 m2 == None)
  }

@test "queue"
  queue_functional = do Effect {
    q0 = Queue.empty
    q1 = Queue.enqueue 1 q0
    q2 = Queue.enqueue 2 q1

    assert (Queue.peek q2 == Some 1)

    res = Queue.dequeue q2
    res match
      | Some (val, q3) => do Effect {
        assert (val == 1)
        assert (Queue.peek q3 == Some 2)
      }
      | None => assert False
  }

@test "set"
  set_functional = do Effect {
    s0 = Set.empty
    s1 = Set.insert 1 s0
    assert (Set.size s0 == 0)
    assert (Set.size s1 == 1)
    assert (Set.has 1 s1 == True)
  }
