@no_prelude
module integrationTests.stdlib.aivi.concurrency.tests

use aivi
use aivi.testing
use aivi.concurrency

channelError_touch : ChannelError -> Unit
channelError_touch = _ => Unit

@test
channelError_smoke = effect {
  pure channelError_touch
  assertEq (1 + 1) 2
}

scope_touch : Scope -> Unit
scope_touch = _ => Unit

@test
scope_smoke = effect {
  pure scope_touch
  assertEq (1 + 1) 2
}

@test
close_smoke = effect {
  (tx, rx) <- make Unit
  send tx Unit
  res      <- recv rx
  res ?
    | Ok _  => assert True
    | Err _ => assert False
    close tx
}

@test
make_smoke = effect {
  (tx, rx) <- make Unit
  send tx Unit
  res      <- recv rx
  res ?
    | Ok _  => assert True
    | Err _ => assert False
    close tx
}

@test
par_smoke = effect {
  // Just ensure both branches run without throwing.
  par (pure 1) (pure 2)
  assert True
}

@test
recv_smoke = effect {
  (tx, rx) <- make Unit
  send tx Unit
  res      <- recv rx
  res ?
    | Ok _  => assert True
    | Err _ => assert False
    close tx
}

@test
scope_smoke_2 = effect {
  // Scope should run the callback and return its result.
  x <- scope (_ => pure 123)
  assert (x == 123)
}

@test
send_smoke = effect {
  (tx, rx) <- make Unit
  send tx Unit
  res      <- recv rx
  res ?
    | Ok _  => assert True
    | Err _ => assert False
    close tx
}
