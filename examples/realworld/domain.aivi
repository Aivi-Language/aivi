module RealWorld.Domains = {
  
  // ------------------------------------------------------------------
  // 1. Tagging Domain
  // Allows concise tag manipulation: `tags + "new-tag"` or `tags - "old-tag"`
  // ------------------------------------------------------------------
  
  domain Tagging over List Text = {
    // The "change" is a single tag
    type Delta = Tag Text

    // Add a tag (idempotent)
    (+) : List Text -> Delta -> List Text
    (+) list (Tag t) = 
      if List.contains t list then list else list ++ [t]

    // Remove a tag
    (-) : List Text -> Delta -> List Text
    (-) list (Tag t) = 
      list |> List.filter (x => x != t)
    
    // We can't define global literals easily without sugar, 
    // but we can rely on implicit conversion if the language supported it.
    // For now, we'll expose a helper or expect `Tag "foo"`.
  }

  // ------------------------------------------------------------------
  // 2. Auth Domain (Permissions)
  // ------------------------------------------------------------------
  // Use a domain to handle "Can this user do X?"
  // Carrier is the User. Delta is the "Action". 
  // Result could be... a modified User? Or maybe this fits Predicates better.
  // Let's stick to simple arithmetic-like domains.
  
  // ------------------------------------------------------------------
  // 3. Content Metrics Domain
  // ------------------------------------------------------------------
  
  ReadingTime = { minutes: Int }

  domain Metrology over Text = {
    type Delta = Words Int

    // "Text / Words" concept -> Reading Time? 
    // This is valid if we define (/) to return a different type.
    // The spec says `(+) : Carrier -> Delta -> Carrier`. 
    // It does NOT strictly say it MUST return Carrier in all cases, 
    // but usually operators do. Let's stick to standard ops.
  }

  // ------------------------------------------------------------------
  // 4. Favorites Domain
  // ------------------------------------------------------------------
  
  domain Favorites over Int = {
    type Delta = Up | Down

    (+) : Int -> Delta -> Int
    (+) n Up = n + 1
    (+) n Down = if n > 0 then n - 1 else 0
    
    // Literals
    up = Up
    down = Down
  }

}
