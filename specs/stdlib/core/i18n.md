# I18n (Localization)

<!-- quick-info: {"kind":"module","name":"aivi.i18n"} -->
This module provides a small, typed localization surface that fits AIVI's existing primitives:

- `Effect E A` for explicit failure/cancellation.
- Sigils for compile-time validation of structured literals.
- Multiple catalog formats: `.properties`, JSON, and YAML.

This is intentionally a minimal v0.1 foundation: key validation, message template validation, bundle loading, lookup, and rendering.

<!-- /quick-info -->
<div class="import-badge">use aivi.i18n</div>


## Module

<<< ../../snippets/from_md/stdlib/core/i18n/tooling_aivi_i18n_gen.aivi{aivi}


## Types

<<< ../../snippets/from_md/stdlib/core/i18n/types.aivi{aivi}

Notes:

- `Key` and `Message` are implemented as record-shaped sigil values. They are open records in practice (tooling may attach extra fields).
- `Bundle.entries` is keyed by the key text (`Text`). `Key` is a typed wrapper for that text.


## Sigils

### `~k"..."` (keys)

<<< ../../snippets/from_md/stdlib/core/i18n/k_keys.aivi{aivi}

`~k` is validated at parse time:

- non-empty
- dot-separated segments (`a.b.c`)
- no empty segments (`"a..b"`, `".a"`, `"a."` are rejected)
- each segment must start with `[A-Za-z_]` and contain only `[A-Za-z0-9_-]`

### `~m"..."` (messages)

<<< ../../snippets/from_md/stdlib/core/i18n/m_messages.aivi{aivi}

`~m` is validated at parse time using a small template language:

- literal text
- escaped braces: <code v-pre>{{</code> renders `{`, <code v-pre>}}</code> renders `}`
- placeholders: `{name}` or `{name:Type}`

### Placeholder syntax

Placeholders use curly braces inside `~m"..."` messages:

| Form | Meaning |
| --- | --- |
| `{name}` | Named placeholder, any type accepted at render time |
| `{name:Type}` | Named + typed placeholder, checked at render time |

**Why `:Type` and not a `ToText` constraint?** In v0.1, placeholders use a closed allowlist of renderable types rather than relying on typeclass resolution. This keeps the i18n runtime simple and avoids coupling message rendering to the full typeclass machinery. Supported types:

- `Text`, `Int`, `Float`, `Bool`, `Decimal`, `DateTime`

Future versions may generalize to `{name:A}` where `A : ToText`.

### Escaping braces in Text literals vs `~m` sigils

AIVI `Text` literals use `{ Expr }` for interpolation. If you need to build a message template **as a plain Text value** (rather than a `~m` sigil), you must escape the braces so the AIVI parser does not treat them as interpolation:

| Context | Literal brace | Example |
| --- | --- | --- |
| Inside `~m"..."` sigil | <code v-pre>{{</code> and <code v-pre>}}</code> | <code v-pre>~m"Price: {{free}}"</code> renders `Price: {free}` |
| Inside `"..."` Text literal | `\{` and `\}` | `"Hello, \{name\}"` is the Text value `Hello, {name}` |
| Source code of `\{` | `\\{` | because `\` itself is escaped in AIVI source |

So when writing a message template as a raw `Text` value:

<<< ../../snippets/from_md/stdlib/core/i18n/escaping_braces_in_text_literals_vs_m_sigils.aivi{aivi}

The double backslash `\\{` in source becomes the single-character sequence `\{` at runtime, which `message` then interprets as a literal brace rather than a placeholder delimiter.


## API

<<< ../../snippets/from_md/stdlib/core/i18n/api.aivi{aivi}

### Catalog formats

AIVI supports three catalog formats out of the box:

#### Properties (`.properties`)

```text
app.welcome = Hello, {name:Text}!
app.cartItems = You have {count:Int} items.
```

Lines starting with `#` and blank lines are ignored.

#### JSON (`.json`)

```json
{
  "app.welcome": "Hello, {name:Text}!",
  "app.cartItems": "You have {count:Int} items."
}
```

Flat key-value structure. Nested objects are not supported in v0.1.

#### YAML (`.yaml` / `.yml`)

```yaml
app.welcome: "Hello, {name:Text}!"
app.cartItems: "You have {count:Int} items."
```

Flat key-value structure. Nested maps are not supported in v0.1.


## Simplified usage with `localize`

For the common case where you just want translated strings without manual bundle wiring, AIVI provides a `localize` helper that loads a bundle from a file and returns a ready-to-use lookup function:

<<< ../../snippets/from_md/stdlib/core/i18n/simplified_usage_with_localize.aivi{aivi}

This is equivalent to loading, parsing, and partially applying `t`   but in one step.


## Tooling: `aivi i18n gen`

The compiler ships a small code generator that reads a catalog file and emits a type-safe AIVI module:

```text
aivi i18n gen <catalog-file> --locale <tag> --module <name> --out <file>
```

**What it does:** Reads a `.properties`, `.json`, or `.yaml` catalog and emits an AIVI module containing:

- `KeyId`   a generated sum type with one constructor per key (typo-proof at compile time)
- `keyText : KeyId -> Text`   converts a `KeyId` back to its string key
- `bundle`   a pre-compiled `Map` of `~m"..."` messages
- `t : KeyId -> {} -> Text`   shorthand for type-safe lookup + render

**Why use it?** Without codegen, you reference keys as `~k"app.welcome"` (stringly-typed). With codegen, you get `AppWelcome` as a constructor   the compiler catches typos and renames propagate automatically. Analogous to Android's `R.string.*` or iOS `NSLocalizedString` codegen.

**Example:** Given `messages_en.properties`:

```text
app.welcome = Hello, {name:Text}!
app.goodbye = See you later!
```

Running `aivi i18n gen messages_en.properties --locale en --module MyApp.I18n --out src/i18n.aivi` produces:

<<< ../../snippets/from_md/stdlib/core/i18n/tooling_aivi_i18n_gen.aivi{aivi}



## Common Patterns

### 1) Determine the user's locale (system best-effort)

Use `aivi.system.localeTag` to fetch a best-effort locale tag from the host system, then parse it with `parseLocale` and fall back to a known default.

<<< ../../snippets/from_md/stdlib/core/i18n/1_determine_the_user_s_locale_system_best_effort.aivi{aivi}

Notes:

- `localeTag` is host-dependent; on Unix-like systems it uses `LC_ALL`, `LC_MESSAGES`, `LANG` (in that order) and strips suffixes like `.UTF-8` and `@modifier`.
- `parseLocale` accepts `-` or `_` separated tags (e.g. `en-US`, `en_US`).

### 2) Load a bundle from disk

Load a catalog from any supported format using `bundleFromFile` (auto-detects by extension):

<<< ../../snippets/from_md/stdlib/core/i18n/2_load_a_bundle_from_disk_01.aivi{aivi}

For explicit format control or reusing an already-open handle, use the format-specific parsers:

<<< ../../snippets/from_md/stdlib/core/i18n/2_load_a_bundle_from_disk_02.aivi{aivi}

### 3) Translate a message with placeholders

<<< ../../snippets/from_md/stdlib/core/i18n/3_translate_a_message_with_placeholders.aivi{aivi}

Formatting note (v0.1):

- `DateTime` placeholders are currently rendered using the runtime's default `DateTime -> Text` formatting (locale-neutral; typically ISO-8601-ish).
- If you need locale-specific date formatting today, pre-format the date into a `Text` value at the boundary (host runtime / external source), and use `{when:Text}` in your message template.

### 4) Bundles and fallbacks

Use `tWithFallback` when you have multiple bundles (e.g. app bundle + shared bundle, or user locale + default locale):

<<< ../../snippets/from_md/stdlib/core/i18n/4_bundles_and_fallbacks.aivi{aivi}

### 5) Locale fallback and catalogs

When you have multiple locale bundles available at once, use a `Catalog` (`Map Text Bundle`) keyed by locale tag:

<<< ../../snippets/from_md/stdlib/core/i18n/5_locale_fallback_and_catalogs.aivi{aivi}
