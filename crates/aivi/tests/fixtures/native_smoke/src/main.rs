use std::collections::HashMap;
use std::sync::{Arc, Mutex};

use aivi_native_runtime::{get_builtin, ok as aivi_ok, BuiltinImpl, BuiltinValue, EffectValue, KeyValue, ResourceValue, Runtime, RuntimeError, R, Value};

fn __builtin(name: &str) -> Value {
    get_builtin(name).unwrap_or_else(|| panic!("missing builtin {name}"))
}

#[derive(Clone)]
enum PathSeg {
    Field(String),
    IndexValue(Value),
    IndexFieldBool(String),
    IndexPredicate(Value),
    IndexAll,
}

fn patch_apply(rt: &mut Runtime, old: Value, updater: Value) -> R {
    match updater {
        Value::Closure(_) | Value::Builtin(_) | Value::MultiClause(_) => rt.apply(updater, old),
        other => aivi_ok(other),
    }
}

fn patch_path(rt: &mut Runtime, target: Value, path: &[PathSeg], updater: Value) -> R {
    if path.is_empty() {
        return patch_apply(rt, target, updater);
    }
    match &path[0] {
        PathSeg::Field(name) => match target {
            Value::Record(map) => {
                let mut map = map.as_ref().clone();
                let old = map.remove(name).unwrap_or(Value::Unit);
                let new_val = patch_path(rt, old, &path[1..], updater)?;
                map.insert(name.clone(), new_val);
                aivi_ok(Value::Record(Arc::new(map)))
            }
            other => Err(RuntimeError::Message(format!("expected Record for field patch, got {}", aivi_native_runtime::format_value(&other)))),
        },
        PathSeg::IndexAll => match target {
            Value::List(items) => {
                let mut out_items = Vec::with_capacity(items.len());
                for item in items.iter().cloned() {
                    out_items.push(patch_path(rt, item, &path[1..], updater.clone())?);
                }
                aivi_ok(Value::List(Arc::new(out_items)))
            }
            Value::Map(entries) => {
                let mut out_entries = entries.as_ref().clone();
                for (k, v) in entries.iter() {
                    let new_val = patch_path(rt, v.clone(), &path[1..], updater.clone())?;
                    out_entries.insert(k.clone(), new_val);
                }
                aivi_ok(Value::Map(Arc::new(out_entries)))
            }
            other => Err(RuntimeError::Message(format!("expected List/Map for traversal patch, got {}", aivi_native_runtime::format_value(&other)))),
        },
        PathSeg::IndexValue(idx) => match (target, idx.clone()) {
            (Value::List(items), Value::Int(i)) => {
                let i = i as usize;
                if i >= items.len() { return Err(RuntimeError::Message("index out of bounds".to_string())); }
                let mut out = items.as_ref().clone();
                let old = out[i].clone();
                out[i] = patch_path(rt, old, &path[1..], updater)?;
                aivi_ok(Value::List(Arc::new(out)))
            }
            (Value::Tuple(mut items), Value::Int(i)) => {
                let i = i as usize;
                if i >= items.len() { return Err(RuntimeError::Message("index out of bounds".to_string())); }
                let old = items[i].clone();
                items[i] = patch_path(rt, old, &path[1..], updater)?;
                aivi_ok(Value::Tuple(items))
            }
            (Value::Map(entries), idx) => {
                let Some(key) = KeyValue::try_from_value(&idx) else {
                    return Err(RuntimeError::Message(format!("map key is not a valid key type: {}", aivi_native_runtime::format_value(&idx))));
                };
                let mut out_entries = entries.as_ref().clone();
                let old = out_entries.get(&key).cloned().unwrap_or(Value::Unit);
                let new_val = patch_path(rt, old, &path[1..], updater)?;
                out_entries.insert(key, new_val);
                aivi_ok(Value::Map(Arc::new(out_entries)))
            }
            (other, _) => Err(RuntimeError::Message(format!("expected List/Tuple + Int for index patch, got {}", aivi_native_runtime::format_value(&other)))),
        },
        PathSeg::IndexFieldBool(field) => match target {
            Value::List(items) => {
                let mut out_items = Vec::with_capacity(items.len());
                for item in items.iter().cloned() {
                    let should_patch = match &item {
                        Value::Record(map) => matches!(map.get(field), Some(Value::Bool(true))),
                        _ => false,
                    };
                    if should_patch {
                        out_items.push(patch_path(rt, item, &path[1..], updater.clone())?);
                    } else {
                        out_items.push(item);
                    }
                }
                aivi_ok(Value::List(Arc::new(out_items)))
            }
            other => Err(RuntimeError::Message(format!("expected List for traversal patch, got {}", aivi_native_runtime::format_value(&other)))),
        },
        PathSeg::IndexPredicate(pred) => match target {
            Value::List(items) => {
                let mut out_items = Vec::with_capacity(items.len());
                for item in items.iter().cloned() {
                    let keep = match rt.apply(pred.clone(), item.clone())? {
                        Value::Bool(true) => true,
                        Value::Bool(false) => false,
                        other => return Err(RuntimeError::Message(format!("expected Bool predicate, got {}", aivi_native_runtime::format_value(&other)))),
                    };
                    if keep {
                        out_items.push(patch_path(rt, item, &path[1..], updater.clone())?);
                    } else {
                        out_items.push(item);
                    }
                }
                aivi_ok(Value::List(Arc::new(out_items)))
            }
            Value::Map(entries) => {
                let mut out_entries = entries.as_ref().clone();
                for (k, v) in entries.iter() {
                    let mut rec = HashMap::new();
                    rec.insert("key".to_string(), k.to_value());
                    rec.insert("value".to_string(), v.clone());
                    let entry = Value::Record(Arc::new(rec));
                    let keep = match rt.apply(pred.clone(), entry)? {
                        Value::Bool(true) => true,
                        Value::Bool(false) => false,
                        other => return Err(RuntimeError::Message(format!("expected Bool predicate, got {}", aivi_native_runtime::format_value(&other)))),
                    };
                    if keep {
                        let new_val = patch_path(rt, v.clone(), &path[1..], updater.clone())?;
                        out_entries.insert(k.clone(), new_val);
                    }
                }
                aivi_ok(Value::Map(Arc::new(out_entries)))
            }
            other => Err(RuntimeError::Message(format!("expected List/Map for predicate traversal patch, got {}", aivi_native_runtime::format_value(&other)))),
        },
    }
}

fn patch(rt: &mut Runtime, target: Value, fields: Vec<(Vec<PathSeg>, Value)>) -> R {
    let mut acc = target;
    for (path, updater) in fields {
        acc = patch_path(rt, acc, &path, updater)?;
    }
    aivi_ok(acc)
}

#[derive(Clone, Debug, PartialEq)]
pub enum __Adt_AnsiColor_8712be8f0868bd73 {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    Default,
}

#[derive(Clone, Debug, PartialEq)]
pub enum __Adt_Delta_7f4e7cb1eb0307d7 {
    Millisecond(i64),
    Second(i64),
    Minute(i64),
    Hour(i64),
}

#[derive(Clone, Debug, PartialEq)]
pub enum __Adt_Delta_f01cbd377882356b {
    Lightness(i64),
    Saturation(i64),
    Hue(i64),
}

#[derive(Clone, Debug, PartialEq)]
pub enum __Adt_Length_d183a035e390377e {
    Px(i64),
    Em(i64),
    Rem(i64),
    Vh(i64),
    Vw(i64),
}

#[derive(Clone, Debug, PartialEq)]
pub enum __Adt_PatchOp_ff4bb1258a8bfbc {
    Replace(String, String),
    SetText(String, String),
    SetAttr(String, String, String),
    RemoveAttr(String, String),
}

#[derive(Clone, Debug, PartialEq)]
pub enum __Adt_Percentage_abe5954f4ef635aa {
    Pct(i64),
}

fn def_toText__5fad2d02358c08f3_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toText").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toText__5fad2d02358c08f3_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        (aivi_ok(value.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Record(_) => {
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return {
                        let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toText").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(value.clone()))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_toText__5fad2d02358c08f3(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_toText__5fad2d02358c08f3_clause_0(rt))?,
        (def_toText__5fad2d02358c08f3_clause_1(rt))?,
    ]))
}

fn def_aivi_prelude_toText__c4b377e2c7fe3ae3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toText").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_toText__6ed865886e4820ed(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        (aivi_ok(value.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Record(_) => {
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return {
                        let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toText").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(value.clone()))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_length__ea11573f1af59eb5_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("length").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_length__ea11573f1af59eb5_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        (aivi_ok(xs.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::Int(0));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("_x", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let _x = __b.remove("_x").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return (aivi_ok(Value::Int(1))).and_then(|l| ({
                        let f = (def_length__ea11573f1af59eb5(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_length__ea11573f1af59eb5(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_length__ea11573f1af59eb5_clause_0(rt))?,
        (def_length__ea11573f1af59eb5_clause_1(rt))?,
    ]))
}

fn def_aivi_text_length__81025366d2c2d24b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("length").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isEmpty__f74d14521ba2de7e_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isEmpty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isEmpty__f74d14521ba2de7e_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        (aivi_ok(xs.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::Bool(true));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    true
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    return aivi_ok(Value::Bool(false));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_isEmpty__f74d14521ba2de7e(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_isEmpty__f74d14521ba2de7e_clause_0(rt))?,
        (def_isEmpty__f74d14521ba2de7e_clause_1(rt))?,
    ]))
}

fn def_aivi_text_isEmpty__48929ac36fe5e944(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isEmpty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isDigit__1035ab1b627a1286(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isDigit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_isDigit__754d654f29d2b050(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isDigit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isAlpha__4d2f61feb35b747b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isAlpha").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_isAlpha__84b6ffbad9ba5549(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isAlpha").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isAlnum__51a52bff470dfc70(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isAlnum").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_isAlnum__c59485ba6d4ead42(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isAlnum").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isSpace__ad0d2eb5ef177d95(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isSpace").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_isSpace__20ba75a21e6b7f93(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isSpace").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isUpper__9faef4d5c493f297(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isUpper").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_isUpper__8625ff8e166bcb01(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isUpper").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isLower__4fe125fa5cb8fd8a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isLower").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_isLower__7d498b97b08583dc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isLower").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_contains__4e585eeea351a038(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |haystack: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("contains").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_contains__4e585eeea351a038_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |needle: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError> {
            Ok({
            let needle = needle.clone();
            Box::new(move |haystack: String, rt: &mut aivi_native_runtime::Runtime| -> Result<bool, RuntimeError> {
                Ok((match ({
                let haystack = Value::Text(haystack.clone());
                let needle = Value::Text(needle.clone());
                ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("contains").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                    __aivi_call_args.push((aivi_ok(needle.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_text_contains__640aa679b9fbdc8a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |haystack: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("contains").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_startsWith__1f210ddc31cb3abc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |prefix: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let prefix = prefix.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("startsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(prefix.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_startsWith__1f210ddc31cb3abc_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |prefix: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError> {
            Ok({
            let prefix = prefix.clone();
            Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<bool, RuntimeError> {
                Ok((match ({
                let prefix = Value::Text(prefix.clone());
                let value = Value::Text(value.clone());
                ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("startsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(prefix.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_text_startsWith__d8753d9139e456a2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |prefix: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let prefix = prefix.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("startsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(prefix.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_endsWith__93d75d9ba2bb44e3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |suffix: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let suffix = suffix.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("endsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(suffix.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_endsWith__93d75d9ba2bb44e3_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |suffix: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError> {
            Ok({
            let suffix = suffix.clone();
            Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<bool, RuntimeError> {
                Ok((match ({
                let suffix = Value::Text(suffix.clone());
                let value = Value::Text(value.clone());
                ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("endsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(suffix.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_text_endsWith__094984beeb9289cd(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |suffix: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let suffix = suffix.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("endsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(suffix.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_indexOf__9b44b92353fcc11e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |haystack: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("indexOf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_text_indexOf__09f7da91650a10ac(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |haystack: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("indexOf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_lastIndexOf__06287a3d99185df2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |haystack: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("lastIndexOf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_text_lastIndexOf__38ecc80f075081ac(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |haystack: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("lastIndexOf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_count__b1e5e28e4479a274(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |haystack: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("count").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_count__b1e5e28e4479a274_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |needle: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError> {
            Ok({
            let needle = needle.clone();
            Box::new(move |haystack: String, rt: &mut aivi_native_runtime::Runtime| -> Result<i64, RuntimeError> {
                Ok((match ({
                let haystack = Value::Text(haystack.clone());
                let needle = Value::Text(needle.clone());
                ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("count").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                    __aivi_call_args.push((aivi_ok(needle.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_text_count__4b53cf9cee2fbbc2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |haystack: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("count").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(haystack.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_compare__56d12ea086274034(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_compare__56d12ea086274034_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |left: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError> {
            Ok({
            let left = left.clone();
            Box::new(move |right: String, rt: &mut aivi_native_runtime::Runtime| -> Result<i64, RuntimeError> {
                Ok((match ({
                let left = Value::Text(left.clone());
                let right = Value::Text(right.clone());
                ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(left.clone()))?);
                    __aivi_call_args.push((aivi_ok(right.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_text_compare__8f6a1481acf9b002(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_slice__d4a6e26ba7a1d8b1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |end: Value, rt: &mut Runtime| {
            let start = start.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let end = end.clone();
                let start = start.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                    __aivi_call_args.push((aivi_ok(end.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_slice__d4a6e26ba7a1d8b1_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |start: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError> {
            Ok({
            let start = start.clone();
            Box::new(move |end: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
                Ok({
                let end = end.clone();
                let start = start.clone();
                Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
                    Ok((match ({
                    let end = Value::Int(end.clone());
                    let start = Value::Int(start.clone());
                    let value = Value::Text(value.clone());
                    ({
                        let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(start.clone()))?);
                        __aivi_call_args.push((aivi_ok(end.clone()))?);
                        __aivi_call_args.push((aivi_ok(value.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?
                }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
                })
            })
            })
        })
        })
    })
}

fn def_aivi_text_slice__e6c2a9145243ed0b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |end: Value, rt: &mut Runtime| {
            let start = start.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let end = end.clone();
                let start = start.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                    __aivi_call_args.push((aivi_ok(end.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_split__5fdb7a8ac3147783_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sep: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let sep = sep.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("split").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(sep.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_split__5fdb7a8ac3147783_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("split").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_split__5fdb7a8ac3147783(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_split__5fdb7a8ac3147783_clause_0(rt))?,
        (def_split__5fdb7a8ac3147783_clause_1(rt))?,
    ]))
}

fn def_aivi_text_split__80a3c02af28574b9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sep: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let sep = sep.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("split").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(sep.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_splitLines__ec9a84f720c6236e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("splitLines").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_splitLines__ec9a84f720c6236e_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Vec<String>, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("splitLines").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::List(xs) => { let mut out = Vec::new(); for e in xs.iter().cloned() { out.push((match e { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?); } Ok(out) }, other => Err(RuntimeError::Message(format!("expected List, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_splitLines__e51ba52ffe6cf470(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("splitLines").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_chunk__0f838176873c8e22(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |size: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let size = size.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("chunk").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(size.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_chunk__0f838176873c8e22_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |size: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError> {
            Ok({
            let size = size.clone();
            Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Vec<String>, RuntimeError> {
                Ok((match ({
                let size = Value::Int(size.clone());
                let value = Value::Text(value.clone());
                ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("chunk").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(size.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::List(xs) => { let mut out = Vec::new(); for e in xs.iter().cloned() { out.push((match e { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?); } Ok(out) }, other => Err(RuntimeError::Message(format!("expected List, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_text_chunk__16ece2618919fcb0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |size: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let size = size.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("chunk").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(size.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_trim__5b33c0ef512afe89(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_trim__5b33c0ef512afe89_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_trim__21fdfded7480890b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_trimStart__986d7ce5a0e6d40b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trimStart").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_trimStart__986d7ce5a0e6d40b_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trimStart").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_trimStart__c98edb03520feda9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trimStart").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_trimEnd__57cf802afb0881ee(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trimEnd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_trimEnd__57cf802afb0881ee_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trimEnd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_trimEnd__65584b55787c4d98(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trimEnd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_padStart__327376c3f4b203b2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |width: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |fill: Value, rt: &mut Runtime| {
            let width = width.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let fill = fill.clone();
                let width = width.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("padStart").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(width.clone()))?);
                    __aivi_call_args.push((aivi_ok(fill.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_padStart__327376c3f4b203b2_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |width: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError> {
            Ok({
            let width = width.clone();
            Box::new(move |fill: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
                Ok({
                let fill = fill.clone();
                let width = width.clone();
                Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
                    Ok((match ({
                    let fill = Value::Text(fill.clone());
                    let value = Value::Text(value.clone());
                    let width = Value::Int(width.clone());
                    ({
                        let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("padStart").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(width.clone()))?);
                        __aivi_call_args.push((aivi_ok(fill.clone()))?);
                        __aivi_call_args.push((aivi_ok(value.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?
                }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
                })
            })
            })
        })
        })
    })
}

fn def_aivi_text_padStart__a00237c043c90ab8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |width: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |fill: Value, rt: &mut Runtime| {
            let width = width.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let fill = fill.clone();
                let width = width.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("padStart").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(width.clone()))?);
                    __aivi_call_args.push((aivi_ok(fill.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_padEnd__3d3af185317a0417(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |width: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |fill: Value, rt: &mut Runtime| {
            let width = width.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let fill = fill.clone();
                let width = width.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("padEnd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(width.clone()))?);
                    __aivi_call_args.push((aivi_ok(fill.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_padEnd__3d3af185317a0417_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |width: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError> {
            Ok({
            let width = width.clone();
            Box::new(move |fill: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
                Ok({
                let fill = fill.clone();
                let width = width.clone();
                Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
                    Ok((match ({
                    let fill = Value::Text(fill.clone());
                    let value = Value::Text(value.clone());
                    let width = Value::Int(width.clone());
                    ({
                        let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("padEnd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(width.clone()))?);
                        __aivi_call_args.push((aivi_ok(fill.clone()))?);
                        __aivi_call_args.push((aivi_ok(value.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?
                }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
                })
            })
            })
        })
        })
    })
}

fn def_aivi_text_padEnd__428ac571b37cdd89(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |width: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |fill: Value, rt: &mut Runtime| {
            let width = width.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let fill = fill.clone();
                let width = width.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("padEnd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(width.clone()))?);
                    __aivi_call_args.push((aivi_ok(fill.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_replace__b3e29472ea3def43_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |replacement: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let needle = needle.clone();
                let replacement = replacement.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("replace").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(needle.clone()))?);
                    __aivi_call_args.push((aivi_ok(replacement.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_replace__b3e29472ea3def43_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |replacement: Value, rt: &mut Runtime| {
                let r = r.clone();
                let value = value.clone();
                {
                    let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("replace").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(r.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(replacement.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_replace__b3e29472ea3def43(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_replace__b3e29472ea3def43_clause_0(rt))?,
        (def_replace__b3e29472ea3def43_clause_1(rt))?,
    ]))
}

fn def_aivi_text_replace__5220f5a47ca7d3fd(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |replacement: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let needle = needle.clone();
                let replacement = replacement.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("replace").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(needle.clone()))?);
                    __aivi_call_args.push((aivi_ok(replacement.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_replaceAll__4fec64ca9c464816_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |replacement: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let needle = needle.clone();
                let replacement = replacement.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("replaceAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(needle.clone()))?);
                    __aivi_call_args.push((aivi_ok(replacement.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_replaceAll__4fec64ca9c464816_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |replacement: Value, rt: &mut Runtime| {
                let r = r.clone();
                let value = value.clone();
                {
                    let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("replaceAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(r.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(replacement.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_replaceAll__4fec64ca9c464816(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_replaceAll__4fec64ca9c464816_clause_0(rt))?,
        (def_replaceAll__4fec64ca9c464816_clause_1(rt))?,
    ]))
}

fn def_aivi_text_replaceAll__11baeb4cc5c916ac(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |replacement: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let needle = needle.clone();
                let replacement = replacement.clone();
                {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("replaceAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(needle.clone()))?);
                    __aivi_call_args.push((aivi_ok(replacement.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_remove__fff83d536a1d457d_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("remove").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_remove__fff83d536a1d457d_clause_1(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("remove").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_remove__fff83d536a1d457d(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_remove__fff83d536a1d457d_clause_0(rt))?,
        (def_remove__fff83d536a1d457d_clause_1(rt))?,
    ]))
}

fn def_aivi_text_remove__b1a142b42b2ba00f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |needle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let needle = needle.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("remove").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(needle.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_repeat__573bb1642d08280a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |count: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let count = count.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("repeat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(count.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_repeat__573bb1642d08280a_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |count: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
            Ok({
            let count = count.clone();
            Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
                Ok((match ({
                let count = Value::Int(count.clone());
                let value = Value::Text(value.clone());
                ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("repeat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(count.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_text_repeat__80184ac0180bdb74(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |count: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let count = count.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("repeat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(count.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_reverse__c95b3c1f3263ab65_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("reverse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_reverse__c95b3c1f3263ab65_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        {
            let f = (def_revAppend__c7fdbeeb6c8d8a56(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(xs.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_reverse__c95b3c1f3263ab65_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        {
            let f = (def_reverseHelp__37beb7365c1327da(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(xs.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_reverse__c95b3c1f3263ab65_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        {
            let f = (def_reverseGo__55c01e74c8f95d2b(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(xs.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_reverse__c95b3c1f3263ab65_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        {
            let f = (def_revAppend__c7fdbeeb6c8d8a56(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(xs.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_reverse__c95b3c1f3263ab65(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_reverse__c95b3c1f3263ab65_clause_0(rt))?,
        (def_reverse__c95b3c1f3263ab65_clause_1(rt))?,
        (def_reverse__c95b3c1f3263ab65_clause_2(rt))?,
        (def_reverse__c95b3c1f3263ab65_clause_3(rt))?,
        (def_reverse__c95b3c1f3263ab65_clause_4(rt))?,
    ]))
}

fn def_aivi_text_reverse__cf6450d75ccc0387(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("reverse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_concat__4c9fba75ae0b9f5d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_concat__4c9fba75ae0b9f5d_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |values: Vec<String>, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let values = Value::List(Arc::new(values.clone().into_iter().map(|e| Value::Text(e)).collect()));
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(values.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_concat__7f173906f35d0cdb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toLower__b962ad4da1a4f9b1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toLower").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_toLower__b962ad4da1a4f9b1_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toLower").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_toLower__35be32e0432e5443(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toLower").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toUpper__cde1096ec1810998(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toUpper").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_toUpper__cde1096ec1810998_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toUpper").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_toUpper__60730b71a28d32a2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toUpper").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_capitalize__ce5bc8f6084d40e3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("capitalize").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_capitalize__ce5bc8f6084d40e3_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("capitalize").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_capitalize__ac2c86a955e49a99(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("capitalize").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_titleCase__9ade447763fd758d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("titleCase").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_titleCase__9ade447763fd758d_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("titleCase").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_titleCase__ac1a9881c4b0c04f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("titleCase").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_caseFold__47b5509a2ee209c6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("caseFold").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_caseFold__47b5509a2ee209c6_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("caseFold").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_caseFold__20a2a636761979fc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("caseFold").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_normalizeNFC__0c3248a405a6eff9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFC").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_normalizeNFC__0c3248a405a6eff9_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFC").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_normalizeNFC__48bd3f0d17450123(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFC").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_normalizeNFD__0c3249a405a6f1ac(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFD").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_normalizeNFD__0c3249a405a6f1ac_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFD").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_normalizeNFD__48bd440d174509a2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFD").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_normalizeNFKC__607cd8b59ac14bd6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFKC").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_normalizeNFKC__607cd8b59ac14bd6_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFKC").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_normalizeNFKC__deaeb33e8a586f68(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFKC").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_normalizeNFKD__607cdbb59ac150ef(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFKD").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_normalizeNFKD__607cdbb59ac150ef_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFKD").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_text_normalizeNFKD__deaeba3e8a587b4d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("normalizeNFKD").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toBytes__74864ab3ac184da7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |encoding: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let encoding = encoding.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toBytes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(encoding.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_text_toBytes__4a965d4079e280b5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |encoding: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let encoding = encoding.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toBytes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(encoding.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_fromBytes__e2b3d4abc3e628d4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |encoding: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let encoding = encoding.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("fromBytes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(encoding.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_text_fromBytes__2b27cb1036438a4a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |encoding: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let encoding = encoding.clone();
            {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("fromBytes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(encoding.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_debugText__70a36f8d7f36cfdf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toText").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_debugText__a0fc0d66b69d3dc1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("toText").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_parseInt__850ff88250bc49d5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("parseInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_parseInt__cdc5fc2b1589f977(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("parseInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_parseFloat__0e28fcd2087c1a4e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("parseFloat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_text_parseFloat__06df544e2c0a8efc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("parseFloat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_append__3e7fe942f71f1e61_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(left.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(right.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            __aivi_call_args.push((aivi_ok(right.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_append__3e7fe942f71f1e61_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(left.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(right.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            __aivi_call_args.push((aivi_ok(right.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_append__3e7fe942f71f1e61_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ys: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(ys.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("h", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("t", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let h = __b.remove("h").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(h.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(ys.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_append__3e7fe942f71f1e61_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(left.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(right.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            __aivi_call_args.push((aivi_ok(right.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_append__3e7fe942f71f1e61_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(left.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(right.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            __aivi_call_args.push((aivi_ok(right.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_append__3e7fe942f71f1e61(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_append__3e7fe942f71f1e61_clause_0(rt))?,
        (def_append__3e7fe942f71f1e61_clause_1(rt))?,
        (def_append__3e7fe942f71f1e61_clause_2(rt))?,
        (def_append__3e7fe942f71f1e61_clause_3(rt))?,
        (def_append__3e7fe942f71f1e61_clause_4(rt))?,
    ]))
}

fn def_aivi_collections_append__7f72ad060e1c2b15(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(left.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(right.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            __aivi_call_args.push((aivi_ok(right.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_______8ddc95b83e0f4d0c_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = (def_append__3e7fe942f71f1e61(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_______8ddc95b83e0f4d0c_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("union").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_______8ddc95b83e0f4d0c_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("union").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_______8ddc95b83e0f4d0c(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_______8ddc95b83e0f4d0c_clause_0(rt))?,
        (def_______8ddc95b83e0f4d0c_clause_1(rt))?,
        (def_______8ddc95b83e0f4d0c_clause_2(rt))?,
    ]))
}

fn def_aivi_collections_______6d51d91b0df30b38_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = (def_append__3e7fe942f71f1e61(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_collections_______6d51d91b0df30b38_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("union").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_collections_______6d51d91b0df30b38_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("union").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_collections_______6d51d91b0df30b38(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_collections_______6d51d91b0df30b38_clause_0(rt))?,
        (def_aivi_collections_______6d51d91b0df30b38_clause_1(rt))?,
        (def_aivi_collections_______6d51d91b0df30b38_clause_2(rt))?,
    ]))
}

fn def_empty__904fefb3d01cb2ae_clause_0(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_empty__904fefb3d01cb2ae_clause_1(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("nodes".to_string(), (aivi_ok(Value::List(Arc::new(Vec::new()))))?);
        map.insert("edges".to_string(), (aivi_ok(Value::List(Arc::new(Vec::new()))))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_empty__904fefb3d01cb2ae_clause_2(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_empty__904fefb3d01cb2ae(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_empty__904fefb3d01cb2ae_clause_0(rt))?,
        (def_empty__904fefb3d01cb2ae_clause_1(rt))?,
        (def_empty__904fefb3d01cb2ae_clause_2(rt))?,
    ]))
}

fn def_aivi_collections_empty__4c6e306e3ed3e11a(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_push__6c80030e2762459d(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("push").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_collections_push__86fa193e9aa0b281(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("push").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_popMin__f7d62dbf2e863b8c(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("popMin").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_collections_popMin__ae4b782854466840(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("popMin").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_peekMin__a0817aa6fc2d33aa(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("peekMin").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_collections_peekMin__b819c82329b4ae5e(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("peekMin").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_size__4dea9618e618ae3c_clause_0(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_size__4dea9618e618ae3c_clause_1(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_size__4dea9618e618ae3c(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_size__4dea9618e618ae3c_clause_0(rt))?,
        (def_size__4dea9618e618ae3c_clause_1(rt))?,
    ]))
}

fn def_aivi_collections_size__90b64c44e8b79ce0(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_fromList__cd4bcdbe232918f1_clause_0(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("fromList").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_fromList__cd4bcdbe232918f1_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                let k = k.clone();
                let xs = xs.clone();
                (aivi_ok(xs.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(z.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("h", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("t", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let h = __b.remove("h").expect("pattern binder");
                            let t = __b.remove("t").expect("pattern binder");
                            return {
                                let f = (def_fromList__cd4bcdbe232918f1(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(t.clone()))?);
                                __aivi_call_args.push((aivi_ok(k.clone()))?);
                                __aivi_call_args.push(({
                                    let f = (aivi_ok(k.clone()))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(z.clone()))?);
                                    __aivi_call_args.push((aivi_ok(h.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_fromList__cd4bcdbe232918f1(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_fromList__cd4bcdbe232918f1_clause_0(rt))?,
        (def_fromList__cd4bcdbe232918f1_clause_1(rt))?,
    ]))
}

fn def_aivi_collections_fromList__d268192de6381e15(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("Heap"))).and_then(|b| match b { Value::Record(map) => map.get("fromList").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_foldl__d53281afa96a41d2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |step: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |init: Value, rt: &mut Runtime| {
            let step = step.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |gen: Value, rt: &mut Runtime| {
                let init = init.clone();
                let step = step.clone();
                {
                    let f = (aivi_ok(gen.clone()))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(step.clone()))?);
                    __aivi_call_args.push((aivi_ok(init.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_generator_foldl__c0a79e437300927e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |step: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |init: Value, rt: &mut Runtime| {
            let step = step.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |gen: Value, rt: &mut Runtime| {
                let init = init.clone();
                let step = step.clone();
                {
                    let f = (aivi_ok(gen.clone()))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(step.clone()))?);
                    __aivi_call_args.push((aivi_ok(init.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_revAppend__c7fdbeeb6c8d8a56_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(acc.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("h", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("t", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let h = __b.remove("h").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let f = (def_revAppend__c7fdbeeb6c8d8a56(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(h.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_revAppend__c7fdbeeb6c8d8a56_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ys: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(ys.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (def_revAppend__c7fdbeeb6c8d8a56(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(ys.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_revAppend__c7fdbeeb6c8d8a56(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_revAppend__c7fdbeeb6c8d8a56_clause_0(rt))?,
        (def_revAppend__c7fdbeeb6c8d8a56_clause_1(rt))?,
    ]))
}

fn def_aivi_generator_revAppend__f0fde0ca8e4810d2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(acc.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("h", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("t", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let h = __b.remove("h").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let f = (def_revAppend__c7fdbeeb6c8d8a56(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(h.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_generator_reverse__69833551c10d84d9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        {
            let f = (def_revAppend__c7fdbeeb6c8d8a56(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(xs.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_consRev__10c86a7e4ae45525(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
            let acc = acc.clone();
            aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })))
        }) })))
    }) })))
}

fn def_aivi_generator_consRev__26c1aa7ca5bec2b9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
            let acc = acc.clone();
            aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })))
        }) })))
    }) })))
}

fn def_toList__217bcec08252b8cc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |gen: Value, rt: &mut Runtime| {
        {
            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (def_foldl__d53281afa96a41d2(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_consRev__10c86a7e4ae45525(rt))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                __aivi_call_args.push((aivi_ok(gen.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_generator_toList__f78bad2c0240ab18(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |gen: Value, rt: &mut Runtime| {
        {
            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (def_foldl__d53281afa96a41d2(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_consRev__10c86a7e4ae45525(rt))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                __aivi_call_args.push((aivi_ok(gen.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_generator_fromList__d6a009941976ab55(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                let k = k.clone();
                let xs = xs.clone();
                (aivi_ok(xs.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(z.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("h", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("t", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let h = __b.remove("h").expect("pattern binder");
                            let t = __b.remove("t").expect("pattern binder");
                            return {
                                let f = (def_fromList__cd4bcdbe232918f1(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(t.clone()))?);
                                __aivi_call_args.push((aivi_ok(k.clone()))?);
                                __aivi_call_args.push(({
                                    let f = (aivi_ok(k.clone()))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(z.clone()))?);
                                    __aivi_call_args.push((aivi_ok(h.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_mapStep__76769374ef166b3b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let f = f.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
                let f = f.clone();
                let k = k.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
                    let acc = acc.clone();
                    let f = f.clone();
                    let k = k.clone();
                    {
                        let f = (aivi_ok(k.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(acc.clone()))?);
                        __aivi_call_args.push(({
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(a.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_generator_mapStep__857b733dfa7ac297(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let f = f.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
                let f = f.clone();
                let k = k.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
                    let acc = acc.clone();
                    let f = f.clone();
                    let k = k.clone();
                    {
                        let f = (aivi_ok(k.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(acc.clone()))?);
                        __aivi_call_args.push(({
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(a.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_map__080f5919176d2d91_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |gen: Value, rt: &mut Runtime| {
            let f = f.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                let f = f.clone();
                let gen = gen.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                    let f = f.clone();
                    let gen = gen.clone();
                    let k = k.clone();
                    {
                        let f = (aivi_ok(gen.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_mapStep__76769374ef166b3b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(f.clone()))?);
                            __aivi_call_args.push((aivi_ok(k.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        __aivi_call_args.push((aivi_ok(z.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_map__080f5919176d2d91_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |opt: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(opt.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Some")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_map__080f5919176d2d91_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |res: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(res.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Ok")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Err")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_map__080f5919176d2d91_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(items.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?]); out.extend({ let v = ({
                            let f = (aivi_ok(__builtin("map")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(f.clone()))?);
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_map__080f5919176d2d91_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(items.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?]); out.extend({ let v = ({
                            let f = (aivi_ok(__builtin("map")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(f.clone()))?);
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_map__080f5919176d2d91(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_map__080f5919176d2d91_clause_0(rt))?,
        (def_map__080f5919176d2d91_clause_1(rt))?,
        (def_map__080f5919176d2d91_clause_2(rt))?,
        (def_map__080f5919176d2d91_clause_3(rt))?,
        (def_map__080f5919176d2d91_clause_4(rt))?,
    ]))
}

fn def_aivi_generator_map__caf8753626e6512d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |gen: Value, rt: &mut Runtime| {
            let f = f.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                let f = f.clone();
                let gen = gen.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                    let f = f.clone();
                    let gen = gen.clone();
                    let k = k.clone();
                    {
                        let f = (aivi_ok(gen.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_mapStep__76769374ef166b3b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(f.clone()))?);
                            __aivi_call_args.push((aivi_ok(k.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        __aivi_call_args.push((aivi_ok(z.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_filterStep__e4fcb8267dff60a5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pred: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let pred = pred.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
                let k = k.clone();
                let pred = pred.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
                    let acc = acc.clone();
                    let k = k.clone();
                    let pred = pred.clone();
                    ({
                        let f = (aivi_ok(pred.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(a.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|c| match c { Value::Bool(true) => {
                        let f = (aivi_ok(k.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(acc.clone()))?);
                        __aivi_call_args.push((aivi_ok(a.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }, Value::Bool(false) => aivi_ok(acc.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_generator_filterStep__8ed94b74fc3c1561(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pred: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let pred = pred.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
                let k = k.clone();
                let pred = pred.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
                    let acc = acc.clone();
                    let k = k.clone();
                    let pred = pred.clone();
                    ({
                        let f = (aivi_ok(pred.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(a.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|c| match c { Value::Bool(true) => {
                        let f = (aivi_ok(k.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(acc.clone()))?);
                        __aivi_call_args.push((aivi_ok(a.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }, Value::Bool(false) => aivi_ok(acc.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_filter__8ed8bca89377d4f7_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pred: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |gen: Value, rt: &mut Runtime| {
            let pred = pred.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                let gen = gen.clone();
                let pred = pred.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                    let gen = gen.clone();
                    let k = k.clone();
                    let pred = pred.clone();
                    {
                        let f = (aivi_ok(gen.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_filterStep__e4fcb8267dff60a5(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(pred.clone()))?);
                            __aivi_call_args.push((aivi_ok(k.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        __aivi_call_args.push((aivi_ok(z.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_filter__8ed8bca89377d4f7_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |predicate: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
            let predicate = predicate.clone();
            (aivi_ok(items.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return ({
                            let f = (aivi_ok(predicate.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_filter__8ed8bca89377d4f7(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(predicate.clone()))?);
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => {
                            let f = (def_filter__8ed8bca89377d4f7(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(predicate.clone()))?);
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_filter__8ed8bca89377d4f7(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_filter__8ed8bca89377d4f7_clause_0(rt))?,
        (def_filter__8ed8bca89377d4f7_clause_1(rt))?,
    ]))
}

fn def_aivi_generator_filter__9a7a9f8f3fc65943(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pred: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |gen: Value, rt: &mut Runtime| {
            let pred = pred.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                let gen = gen.clone();
                let pred = pred.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                    let gen = gen.clone();
                    let k = k.clone();
                    let pred = pred.clone();
                    {
                        let f = (aivi_ok(gen.clone()))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_filterStep__e4fcb8267dff60a5(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(pred.clone()))?);
                            __aivi_call_args.push((aivi_ok(k.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        __aivi_call_args.push((aivi_ok(z.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_range__526eb811b28d5cb2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |end: Value, rt: &mut Runtime| {
            let start = start.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                let end = end.clone();
                let start = start.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                    let end = end.clone();
                    let k = k.clone();
                    let start = start.clone();
                    ((aivi_ok(start.clone())).and_then(|l| (aivi_ok(end.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a >= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a >= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) >= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a >= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(z.clone()), Value::Bool(false) => {
                        let f = (def_range__526eb811b28d5cb2(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(start.clone())).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        __aivi_call_args.push((aivi_ok(end.clone()))?);
                        __aivi_call_args.push((aivi_ok(k.clone()))?);
                        __aivi_call_args.push(({
                            let f = (aivi_ok(k.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(z.clone()))?);
                            __aivi_call_args.push((aivi_ok(start.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_generator_range__d9cae5c38367019e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |end: Value, rt: &mut Runtime| {
            let start = start.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                let end = end.clone();
                let start = start.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                    let end = end.clone();
                    let k = k.clone();
                    let start = start.clone();
                    ((aivi_ok(start.clone())).and_then(|l| (aivi_ok(end.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a >= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a >= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) >= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a >= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(z.clone()), Value::Bool(false) => {
                        let f = (def_range__526eb811b28d5cb2(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(start.clone())).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        __aivi_call_args.push((aivi_ok(end.clone()))?);
                        __aivi_call_args.push((aivi_ok(k.clone()))?);
                        __aivi_call_args.push(({
                            let f = (aivi_ok(k.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(z.clone()))?);
                            __aivi_call_args.push((aivi_ok(start.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_logic_map__8d7476c13bba1b96_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |opt: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(opt.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Some")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_logic_map__8d7476c13bba1b96_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |res: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(res.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Ok")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Err")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_logic_map__8d7476c13bba1b96(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_logic_map__8d7476c13bba1b96_clause_0(rt))?,
        (def_aivi_logic_map__8d7476c13bba1b96_clause_1(rt))?,
    ]))
}

fn def_ap__089c5207b545b034_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |fOpt: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |opt: Value, rt: &mut Runtime| {
            let fOpt = fOpt.clone();
            (aivi_ok(Value::Tuple(vec![(aivi_ok(fOpt.clone()))?, (aivi_ok(opt.clone()))?]))).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !(match v0 { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("f", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let v1 = &items[1];
                            if !(match v1 { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("x", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let f = __b.remove("f").expect("pattern binder");
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Some")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        true
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_ap__089c5207b545b034_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |fRes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xRes: Value, rt: &mut Runtime| {
            let fRes = fRes.clone();
            (aivi_ok(Value::Tuple(vec![(aivi_ok(fRes.clone()))?, (aivi_ok(xRes.clone()))?]))).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !(match v0 { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("f", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let v1 = &items[1];
                            if !(match v1 { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("x", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let f = __b.remove("f").expect("pattern binder");
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Ok")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !(match v0 { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("e", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let v1 = &items[1];
                            if !(true) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Err")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !(true) { return false; }
                            let v1 = &items[1];
                            if !(match v1 { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("e", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_2(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Err")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_ap__089c5207b545b034(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_ap__089c5207b545b034_clause_0(rt))?,
        (def_ap__089c5207b545b034_clause_1(rt))?,
    ]))
}

fn def_aivi_logic_ap__48314d47107c1639_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |fOpt: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |opt: Value, rt: &mut Runtime| {
            let fOpt = fOpt.clone();
            (aivi_ok(Value::Tuple(vec![(aivi_ok(fOpt.clone()))?, (aivi_ok(opt.clone()))?]))).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !(match v0 { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("f", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let v1 = &items[1];
                            if !(match v1 { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("x", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let f = __b.remove("f").expect("pattern binder");
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Some")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        true
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_logic_ap__48314d47107c1639_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |fRes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xRes: Value, rt: &mut Runtime| {
            let fRes = fRes.clone();
            (aivi_ok(Value::Tuple(vec![(aivi_ok(fRes.clone()))?, (aivi_ok(xRes.clone()))?]))).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !(match v0 { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("f", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let v1 = &items[1];
                            if !(match v1 { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("x", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let f = __b.remove("f").expect("pattern binder");
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Ok")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !(match v0 { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("e", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let v1 = &items[1];
                            if !(true) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Err")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !(true) { return false; }
                            let v1 = &items[1];
                            if !(match v1 { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("e", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_2(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Err")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_logic_ap__48314d47107c1639(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_logic_ap__48314d47107c1639_clause_0(rt))?,
        (def_aivi_logic_ap__48314d47107c1639_clause_1(rt))?,
    ]))
}

fn def_of__08b06007b5567108_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(__builtin("Some"))
}

fn def_of__08b06007b5567108_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(__builtin("Ok"))
}

fn def_of__08b06007b5567108(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_of__08b06007b5567108_clause_0(rt))?,
        (def_of__08b06007b5567108_clause_1(rt))?,
    ]))
}

fn def_aivi_logic_of__48606f4710a3c0c1_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(__builtin("Some"))
}

fn def_aivi_logic_of__48606f4710a3c0c1_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(__builtin("Ok"))
}

fn def_aivi_logic_of__48606f4710a3c0c1(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_logic_of__48606f4710a3c0c1_clause_0(rt))?,
        (def_aivi_logic_of__48606f4710a3c0c1_clause_1(rt))?,
    ]))
}

fn def_chain__a74390764c1a3056_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |opt: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(opt.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_chain__a74390764c1a3056_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |res: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(res.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Err")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_chain__a74390764c1a3056(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_chain__a74390764c1a3056_clause_0(rt))?,
        (def_chain__a74390764c1a3056_clause_1(rt))?,
    ]))
}

fn def_aivi_logic_chain__e11dc579397a4cc9_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |opt: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(opt.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_logic_chain__e11dc579397a4cc9_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |res: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(res.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        return {
                            let f = (aivi_ok(__builtin("Err")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_logic_chain__e11dc579397a4cc9(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_logic_chain__e11dc579397a4cc9_clause_0(rt))?,
        (def_aivi_logic_chain__e11dc579397a4cc9_clause_1(rt))?,
    ]))
}

fn def_compile__1280caa05fbce71e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pattern: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("compile").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(pattern.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_regex_compile__48ef6c68a9834688(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pattern: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("compile").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(pattern.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_test__f9e6e6ef197c2b25(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("test").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_regex_test__05f1077b072ffaaf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("test").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_v_match__c3bfe3a4fe4c13f6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("match").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_regex_match__a9f56c6a8552e7dc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("match").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_matches__d266428256b0620e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("matches").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_regex_matches__6fc45eedad31d0f8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("matches").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_find__aad72478f030a91a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("find").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_regex_find__af00e5ec4b728658(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("find").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_findAll__67cdfea6f6254541(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("findAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_regex_findAll__46bb752169fb4e9b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("findAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_regex_split__74f4a57351302601(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            {
                let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("split").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(r.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_regex_replace__ec57440401734275(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |replacement: Value, rt: &mut Runtime| {
                let r = r.clone();
                let value = value.clone();
                {
                    let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("replace").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(r.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(replacement.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_regex_replaceAll__97f76426e01a7d34(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |r: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let r = r.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |replacement: Value, rt: &mut Runtime| {
                let r = r.clone();
                let value = value.clone();
                {
                    let f = ((aivi_ok(__builtin("regex"))).and_then(|b| match b { Value::Record(map) => map.get("replaceAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(r.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    __aivi_call_args.push((aivi_ok(replacement.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_assert__f89e75bdb43c5a5b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ok: Value, rt: &mut Runtime| {
        (aivi_ok(ok.clone())).and_then(|c| match c { Value::Bool(true) => {
            let f = (aivi_ok(__builtin("pure")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }, Value::Bool(false) => {
            let f = (aivi_ok(__builtin("fail")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::Text("assertion failed".to_string())))?);
            rt.call(f, __aivi_call_args)
        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_aivi_testing_assert__217605f054ac6acc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ok: Value, rt: &mut Runtime| {
        (aivi_ok(ok.clone())).and_then(|c| match c { Value::Bool(true) => {
            let f = (aivi_ok(__builtin("pure")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }, Value::Bool(false) => {
            let f = (aivi_ok(__builtin("fail")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::Text("assertion failed".to_string())))?);
            rt.call(f, __aivi_call_args)
        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_assert_eq__0b169b688ed759ee(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            ((aivi_ok(a.clone())).and_then(|a| (aivi_ok(b.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                let f = (aivi_ok(__builtin("pure")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
                rt.call(f, __aivi_call_args)
            }, Value::Bool(false) => {
                let f = (aivi_ok(__builtin("fail")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("assert_eq failed".to_string())))?);
                rt.call(f, __aivi_call_args)
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) })))
    }) })))
}

fn def_aivi_testing_assert_eq__5ac688ca173a350f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            ((aivi_ok(a.clone())).and_then(|a| (aivi_ok(b.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                let f = (aivi_ok(__builtin("pure")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
                rt.call(f, __aivi_call_args)
            }, Value::Bool(false) => {
                let f = (aivi_ok(__builtin("fail")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("assert_eq failed".to_string())))?);
                rt.call(f, __aivi_call_args)
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) })))
    }) })))
}

fn def_assertEq__5984ffac15ce4c31(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_assert_eq__0b169b688ed759ee(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_testing_assertEq__01193ceb47266e0e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_assert_eq__0b169b688ed759ee(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_defineUnit__72a55a8ea56b1174(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |name: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |factor: Value, rt: &mut Runtime| {
            let name = name.clone();
            {
                let mut map = HashMap::new();
                map.insert("name".to_string(), (aivi_ok(name.clone()))?);
                map.insert("factor".to_string(), (aivi_ok(factor.clone()))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_defineUnit__72a55a8ea56b1174_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<(), RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |name: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<(), RuntimeError>>, RuntimeError> {
            Ok({
            let name = name.clone();
            Box::new(move |factor: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<(), RuntimeError> {
                Ok((match ({
                let factor = Value::Float(factor.clone());
                let name = Value::Text(name.clone());
                ({
                    let mut map = HashMap::new();
                    map.insert("name".to_string(), (aivi_ok(name.clone()))?);
                    map.insert("factor".to_string(), (aivi_ok(factor.clone()))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?
            }) { Value::Unit => Ok(()), other => Err(RuntimeError::Message(format!("expected Unit, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_units_defineUnit__ea565d50478bcea6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |name: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |factor: Value, rt: &mut Runtime| {
            let name = name.clone();
            {
                let mut map = HashMap::new();
                map.insert("name".to_string(), (aivi_ok(name.clone()))?);
                map.insert("factor".to_string(), (aivi_ok(factor.clone()))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_convert__816995a82874c838(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |target: Value, rt: &mut Runtime| {
            let q = q.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("factor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(target.clone())).and_then(|b| match b { Value::Record(map) => map.get("factor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), (aivi_ok(target.clone()))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_units_convert__f28937cbd8b5454e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |target: Value, rt: &mut Runtime| {
            let q = q.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("factor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(target.clone())).and_then(|b| match b { Value::Record(map) => map.get("factor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), (aivi_ok(target.clone()))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_sameUnit__018b75139e1724f1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("name").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("name").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))
        }) })))
    }) })))
}

fn def_aivi_units_sameUnit__e98dd4b8b4ff4aaf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("name").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("name").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Day" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_addDays__0b29c5e57d7c2747(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(date.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Month" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_addMonths__067da8fb153b097b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(date.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Year" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_addYears__cec72d57deaa49c2(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(date.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "End" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_endOfMonth__d32ace30a85876ef(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(date.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Millisecond" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Second" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(1000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Minute" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(60000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Hour" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(3600000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s2: Value, rt: &mut Runtime| {
            let s1 = s1.clone();
            {
                let mut map = HashMap::new();
                map.insert("millis".to_string(), (((aivi_ok(s1.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(s2.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_10(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = (def_addMillis__97b531592bac19aa(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push(((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_11(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Millisecond" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_12(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Second" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(1000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_13(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Minute" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(60000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_14(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Hour" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(3600000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_15(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s2: Value, rt: &mut Runtime| {
            let s1 = s1.clone();
            {
                let mut map = HashMap::new();
                map.insert("millis".to_string(), (((aivi_ok(s1.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(s2.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_16(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |col: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let col = col.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Lightness" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_adjustLightness__cf11cff218302fe9(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(col.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_17(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |col: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let col = col.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Saturation" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_adjustSaturation__38af6189d5042f6e(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(col.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_18(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |col: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let col = col.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Hue" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_adjustHue__8d3423813282e5b0(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(col.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_19(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Record(_) => {
                            let mut cur0: &Value = v;
                            cur0 = match cur0 {
                                Value::Record(m) => match m.get("r") {
                                    Some(v) => v,
                                    None => return false,
                                },
                                _ => return false,
                            };
                            if !({ b.insert("r", cur0.clone()); true }) { return false; }
                            let mut cur1: &Value = v;
                            cur1 = match cur1 {
                                Value::Record(m) => match m.get("g") {
                                    Some(v) => v,
                                    None => return false,
                                },
                                _ => return false,
                            };
                            if !({ b.insert("g", cur1.clone()); true }) { return false; }
                            let mut cur2: &Value = v;
                            cur2 = match cur2 {
                                Value::Record(m) => match m.get("b") {
                                    Some(v) => v,
                                    None => return false,
                                },
                                _ => return false,
                            };
                            if !({ b.insert("b", cur2.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let b = __b.remove("b").expect("pattern binder");
                        let g = __b.remove("g").expect("pattern binder");
                        let r = __b.remove("r").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("r".to_string(), (((aivi_ok(left.clone())).and_then(|b| match b { Value::Record(map) => map.get("r").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(r.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            map.insert("g".to_string(), (((aivi_ok(left.clone())).and_then(|b| match b { Value::Record(map) => map.get("g").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(g.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            map.insert("b".to_string(), (((aivi_ok(left.clone())).and_then(|b| match b { Value::Record(map) => map.get("b").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_20(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_21(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_22(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_23(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_24(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_25(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m03".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m13".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m23".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m30".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m31".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m32".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m33".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_26(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("size".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("data".to_string(), ({
                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_add__e70bc3190530e654(rt))?);
                __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_27(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_28(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("samples".to_string(), ({
                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_add__e70bc3190530e654(rt))?);
                __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("samples").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("samples").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("rate".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("rate").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_29(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_30(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_31(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ({
                let f = (def_uniqueNodeIds__3c42dccc48aa0d04(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_append__3e7fe942f71f1e61(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("edges".to_string(), ({
                let f = (def_append__3e7fe942f71f1e61(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_32(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let value = value.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !({ b.insert("key", v0.clone()); true }) { return false; }
                            let v1 = &items[1];
                            if !({ b.insert("v", v1.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let key = __b.remove("key").expect("pattern binder");
                        let v = __b.remove("v").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            match (aivi_ok(value.clone()))? { Value::Record(m) => { map.extend(m.as_ref().clone()); }, _ => return Err(RuntimeError::Message("record spread expects a record".to_string())), };
                            map.insert("query".to_string(), ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(value.clone())).and_then(|b| match b { Value::Record(map) => map.get("query").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(Value::Tuple(vec![(aivi_ok(key.clone()))?, (aivi_ok(v.clone()))?])))?]))))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_33(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |table: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let table = table.clone();
            {
                let f = (def_applyDelta__8c0c40877627f01b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(table.clone()))?);
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_34(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("add").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_35(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("add").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_36(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("add").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_37(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("re".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("im".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87_clause_38(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("w".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e73117f6b9fd87(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def______09e73117f6b9fd87_clause_0(rt))?,
        (def______09e73117f6b9fd87_clause_1(rt))?,
        (def______09e73117f6b9fd87_clause_2(rt))?,
        (def______09e73117f6b9fd87_clause_3(rt))?,
        (def______09e73117f6b9fd87_clause_4(rt))?,
        (def______09e73117f6b9fd87_clause_5(rt))?,
        (def______09e73117f6b9fd87_clause_6(rt))?,
        (def______09e73117f6b9fd87_clause_7(rt))?,
        (def______09e73117f6b9fd87_clause_8(rt))?,
        (def______09e73117f6b9fd87_clause_9(rt))?,
        (def______09e73117f6b9fd87_clause_10(rt))?,
        (def______09e73117f6b9fd87_clause_11(rt))?,
        (def______09e73117f6b9fd87_clause_12(rt))?,
        (def______09e73117f6b9fd87_clause_13(rt))?,
        (def______09e73117f6b9fd87_clause_14(rt))?,
        (def______09e73117f6b9fd87_clause_15(rt))?,
        (def______09e73117f6b9fd87_clause_16(rt))?,
        (def______09e73117f6b9fd87_clause_17(rt))?,
        (def______09e73117f6b9fd87_clause_18(rt))?,
        (def______09e73117f6b9fd87_clause_19(rt))?,
        (def______09e73117f6b9fd87_clause_20(rt))?,
        (def______09e73117f6b9fd87_clause_21(rt))?,
        (def______09e73117f6b9fd87_clause_22(rt))?,
        (def______09e73117f6b9fd87_clause_23(rt))?,
        (def______09e73117f6b9fd87_clause_24(rt))?,
        (def______09e73117f6b9fd87_clause_25(rt))?,
        (def______09e73117f6b9fd87_clause_26(rt))?,
        (def______09e73117f6b9fd87_clause_27(rt))?,
        (def______09e73117f6b9fd87_clause_28(rt))?,
        (def______09e73117f6b9fd87_clause_29(rt))?,
        (def______09e73117f6b9fd87_clause_30(rt))?,
        (def______09e73117f6b9fd87_clause_31(rt))?,
        (def______09e73117f6b9fd87_clause_32(rt))?,
        (def______09e73117f6b9fd87_clause_33(rt))?,
        (def______09e73117f6b9fd87_clause_34(rt))?,
        (def______09e73117f6b9fd87_clause_35(rt))?,
        (def______09e73117f6b9fd87_clause_36(rt))?,
        (def______09e73117f6b9fd87_clause_37(rt))?,
        (def______09e73117f6b9fd87_clause_38(rt))?,
    ]))
}

fn def_aivi_units______5116460c4dd56835(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(date.clone())).and_then(|l| ({
                let f = (def_negateDelta__62390cb65750aabb(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(span.clone())).and_then(|l| ({
                let f = (def_negateDelta__62390cb65750aabb(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = (def_addMillis__97b531592bac19aa(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(span.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let mut map = HashMap::new();
                map.insert("millis".to_string(), ({
                let f = (def_diffMillis__f0cdb676a7160de4(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(span.clone())).and_then(|l| ({
                let f = (def_negateDelta__62390cb65750aabb(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |col: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let col = col.clone();
            (aivi_ok(col.clone())).and_then(|l| ({
                let f = (def_negateDelta__62390cb65750aabb(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_10(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_11(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_12(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m03".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m13".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m23".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m30".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m31".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m32".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m33".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_13(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("size".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("data".to_string(), ({
                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_sub__82719d195d0fc2f5(rt))?);
                __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_14(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_15(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_16(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_17(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let mut map = HashMap::new();
                match (aivi_ok(value.clone()))? { Value::Record(m) => { map.extend(m.as_ref().clone()); }, _ => return Err(RuntimeError::Message("record spread expects a record".to_string())), };
                map.insert("query".to_string(), ({
                let f = (def_filter__8ed8bca89377d4f7(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_filterKey__3661d05f4aa34cae(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(key.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                __aivi_call_args.push(((aivi_ok(value.clone())).and_then(|b| match b { Value::Record(map) => map.get("query").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_18(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("sub").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_19(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("sub").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_20(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("sub").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_21(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("re".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("im".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5_clause_22(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("w".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09e09517f6b488c5(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def______09e09517f6b488c5_clause_0(rt))?,
        (def______09e09517f6b488c5_clause_1(rt))?,
        (def______09e09517f6b488c5_clause_2(rt))?,
        (def______09e09517f6b488c5_clause_3(rt))?,
        (def______09e09517f6b488c5_clause_4(rt))?,
        (def______09e09517f6b488c5_clause_5(rt))?,
        (def______09e09517f6b488c5_clause_6(rt))?,
        (def______09e09517f6b488c5_clause_7(rt))?,
        (def______09e09517f6b488c5_clause_8(rt))?,
        (def______09e09517f6b488c5_clause_9(rt))?,
        (def______09e09517f6b488c5_clause_10(rt))?,
        (def______09e09517f6b488c5_clause_11(rt))?,
        (def______09e09517f6b488c5_clause_12(rt))?,
        (def______09e09517f6b488c5_clause_13(rt))?,
        (def______09e09517f6b488c5_clause_14(rt))?,
        (def______09e09517f6b488c5_clause_15(rt))?,
        (def______09e09517f6b488c5_clause_16(rt))?,
        (def______09e09517f6b488c5_clause_17(rt))?,
        (def______09e09517f6b488c5_clause_18(rt))?,
        (def______09e09517f6b488c5_clause_19(rt))?,
        (def______09e09517f6b488c5_clause_20(rt))?,
        (def______09e09517f6b488c5_clause_21(rt))?,
        (def______09e09517f6b488c5_clause_22(rt))?,
    ]))
}

fn def_aivi_units______511d220c4ddb49b7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let q = q.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m03".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m13".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m23".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m30".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m31".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m32".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m33".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("size".to_string(), ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("data".to_string(), ({
                let f = (aivi_ok(__builtin("map")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
                    let s = s.clone();
                    (aivi_ok(_arg0.clone())).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
                }) }))))?);
                __aivi_call_args.push(((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let s = s.clone();
            {
                let mut map = HashMap::new();
                map.insert("samples".to_string(), ({
                let f = (aivi_ok(__builtin("map")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
                    let k = k.clone();
                    (aivi_ok(_arg0.clone())).and_then(|l| (aivi_ok(k.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
                }) }))))?);
                __aivi_call_args.push(((aivi_ok(s.clone())).and_then(|b| match b { Value::Record(map) => map.get("samples").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("rate".to_string(), ((aivi_ok(s.clone())).and_then(|b| match b { Value::Record(map) => map.get("rate").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_10(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("mul").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_11(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("mul").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_12(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("mul").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_13(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("re".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("im".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a_clause_14(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("w".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("x".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09ea9517f6bcdd4a(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def______09ea9517f6bcdd4a_clause_0(rt))?,
        (def______09ea9517f6bcdd4a_clause_1(rt))?,
        (def______09ea9517f6bcdd4a_clause_2(rt))?,
        (def______09ea9517f6bcdd4a_clause_3(rt))?,
        (def______09ea9517f6bcdd4a_clause_4(rt))?,
        (def______09ea9517f6bcdd4a_clause_5(rt))?,
        (def______09ea9517f6bcdd4a_clause_6(rt))?,
        (def______09ea9517f6bcdd4a_clause_7(rt))?,
        (def______09ea9517f6bcdd4a_clause_8(rt))?,
        (def______09ea9517f6bcdd4a_clause_9(rt))?,
        (def______09ea9517f6bcdd4a_clause_10(rt))?,
        (def______09ea9517f6bcdd4a_clause_11(rt))?,
        (def______09ea9517f6bcdd4a_clause_12(rt))?,
        (def______09ea9517f6bcdd4a_clause_13(rt))?,
        (def______09ea9517f6bcdd4a_clause_14(rt))?,
    ]))
}

fn def_aivi_units______5119ba0c4dd86328(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let q = q.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let q = q.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |base: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |other: Value, rt: &mut Runtime| {
            let base = base.clone();
            ((aivi_ok(other.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => aivi_ok(other.clone()), Value::Bool(false) => {
                let f = (def_normalize__eabe8385437e66cc(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let mut map = HashMap::new();
                    map.insert("absolute".to_string(), ((aivi_ok(base.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    map.insert("segments".to_string(), ({
                    let f = (def_append__3e7fe942f71f1e61(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(base.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    __aivi_call_args.push(((aivi_ok(other.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                })?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?);
                rt.call(f, __aivi_call_args)
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("div").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("div").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let z = z.clone();
            {
                let mut map = HashMap::new();
                map.insert("re".to_string(), (((aivi_ok(z.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("im".to_string(), (((aivi_ok(z.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3_clause_8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let q = q.clone();
            {
                let mut map = HashMap::new();
                map.insert("w".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("x".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def______09d98917f6ae55b3(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def______09d98917f6ae55b3_clause_0(rt))?,
        (def______09d98917f6ae55b3_clause_1(rt))?,
        (def______09d98917f6ae55b3_clause_2(rt))?,
        (def______09d98917f6ae55b3_clause_3(rt))?,
        (def______09d98917f6ae55b3_clause_4(rt))?,
        (def______09d98917f6ae55b3_clause_5(rt))?,
        (def______09d98917f6ae55b3_clause_6(rt))?,
        (def______09d98917f6ae55b3_clause_7(rt))?,
        (def______09d98917f6ae55b3_clause_8(rt))?,
    ]))
}

fn def_aivi_units______51239e0c4de08819(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let q = q.clone();
            {
                let mut map = HashMap::new();
                map.insert("value".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("value").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("unit".to_string(), ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("unit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_isLeapYear__4af2ab19f6c5fb06(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("isLeapYear").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_calendar_isLeapYear__adbf8c6a8a311957(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("isLeapYear").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_daysInMonth__cad5a76cf7cde775(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("daysInMonth").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_calendar_daysInMonth__cb978b6f9b5d4e26(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("daysInMonth").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_endOfMonth__d32ace30a85876ef(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("endOfMonth").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_calendar_endOfMonth__41efb8416c0f2a66(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("endOfMonth").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_addDays__0b29c5e57d7c2747(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("addDays").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_calendar_addDays__9c3196cc64ec1b74(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("addDays").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_addMonths__067da8fb153b097b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("addMonths").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_calendar_addMonths__c30a26ae75412f1c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("addMonths").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_addYears__cec72d57deaa49c2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("addYears").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_calendar_addYears__85db103996b6e32f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("calendar"))).and_then(|b| match b { Value::Record(map) => map.get("addYears").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_negateDelta__62390cb65750aabb_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
        (aivi_ok(delta.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Day" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Day".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Month" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Month".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Year" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Year".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_3(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "End" && args.len() == 0 => {
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_3(&__scrut, &mut __b) {
                    return aivi_ok(Value::Constructor { name: "End".to_string(), args: Vec::new() });
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_negateDelta__62390cb65750aabb_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
        (aivi_ok(delta.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Millisecond" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Millisecond".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Second" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Second".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Minute" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Minute".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_3(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Hour" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_3(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Hour".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_negateDelta__62390cb65750aabb_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
        (aivi_ok(delta.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Millisecond" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Millisecond".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Second" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Second".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Minute" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Minute".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_3(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Hour" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_3(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Hour".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_negateDelta__62390cb65750aabb_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
        (aivi_ok(delta.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Lightness" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Lightness".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Saturation" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Saturation".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Hue" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Hue".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_negateDelta__62390cb65750aabb(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_negateDelta__62390cb65750aabb_clause_0(rt))?,
        (def_negateDelta__62390cb65750aabb_clause_1(rt))?,
        (def_negateDelta__62390cb65750aabb_clause_2(rt))?,
        (def_negateDelta__62390cb65750aabb_clause_3(rt))?,
    ]))
}

fn def_aivi_calendar_negateDelta__0c1d11b1dc5eeb3c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
        (aivi_ok(delta.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Day" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Day".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Month" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Month".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Year" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Year".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_3(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "End" && args.len() == 0 => {
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_3(&__scrut, &mut __b) {
                    return aivi_ok(Value::Constructor { name: "End".to_string(), args: Vec::new() });
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_now__215ad519258e9d97(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("clock"))).and_then(|b| match b { Value::Record(map) => map.get("now").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_aivi_calendar_now__a81e2f7f3ee1cdb8(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("clock"))).and_then(|b| match b { Value::Record(map) => map.get("now").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_aivi_calendar______48ec9b7de6b89f00_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Day" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_addDays__0b29c5e57d7c2747(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(date.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_calendar______48ec9b7de6b89f00_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Month" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_addMonths__067da8fb153b097b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(date.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_calendar______48ec9b7de6b89f00_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Year" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_addYears__cec72d57deaa49c2(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(date.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_calendar______48ec9b7de6b89f00_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "End" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_endOfMonth__d32ace30a85876ef(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(date.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_calendar______48ec9b7de6b89f00(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_calendar______48ec9b7de6b89f00_clause_0(rt))?,
        (def_aivi_calendar______48ec9b7de6b89f00_clause_1(rt))?,
        (def_aivi_calendar______48ec9b7de6b89f00_clause_2(rt))?,
        (def_aivi_calendar______48ec9b7de6b89f00_clause_3(rt))?,
    ]))
}

fn def_aivi_calendar______48f3a77de6bed212(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |date: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let date = date.clone();
            (aivi_ok(date.clone())).and_then(|l| ({
                let f = (def_negateDelta__62390cb65750aabb(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def__1d__07f85e07b4b9b048(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_d: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Day".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_d.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_calendar_1d__806f0ee119589765(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_d: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Day".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_d.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1m__07f85707b4b9a463(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_m: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Month".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_m.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_calendar_1m__806f15e11958a34a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_m: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Month".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_m.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1y__07f84b07b4b98fff(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_y: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Year".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_y.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_calendar_1y__806f21e11958b7ae(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_y: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Year".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_y.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_eom__c2f31818f055a990(rt: &mut Runtime) -> R {
    aivi_ok(Value::Constructor { name: "End".to_string(), args: Vec::new() })
}

fn def_aivi_calendar_eom__592cc47f11e326c7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Constructor { name: "End".to_string(), args: Vec::new() })
}

fn def_aivi_chronos_duration_negateDelta__a4479f19cfb29dec(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
        (aivi_ok(delta.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Millisecond" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Millisecond".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Second" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Second".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Minute" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Minute".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_3(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Hour" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_3(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Hour".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_chronos_duration______e6afaf7628123030_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Millisecond" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_chronos_duration______e6afaf7628123030_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Second" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(1000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_chronos_duration______e6afaf7628123030_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Minute" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(60000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_chronos_duration______e6afaf7628123030_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Hour" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(3600000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_chronos_duration______e6afaf7628123030_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s2: Value, rt: &mut Runtime| {
            let s1 = s1.clone();
            {
                let mut map = HashMap::new();
                map.insert("millis".to_string(), (((aivi_ok(s1.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(s2.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_chronos_duration______e6afaf7628123030(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_chronos_duration______e6afaf7628123030_clause_0(rt))?,
        (def_aivi_chronos_duration______e6afaf7628123030_clause_1(rt))?,
        (def_aivi_chronos_duration______e6afaf7628123030_clause_2(rt))?,
        (def_aivi_chronos_duration______e6afaf7628123030_clause_3(rt))?,
        (def_aivi_chronos_duration______e6afaf7628123030_clause_4(rt))?,
    ]))
}

fn def_aivi_chronos_duration______e6b6bb7628186342(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(span.clone())).and_then(|l| ({
                let f = (def_negateDelta__62390cb65750aabb(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def__1ms__449ff2181771c730_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_ms: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Millisecond".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_ms.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1ms__449ff2181771c730_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_ms: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Millisecond".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_ms.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1ms__449ff2181771c730(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def__1ms__449ff2181771c730_clause_0(rt))?,
        (def__1ms__449ff2181771c730_clause_1(rt))?,
    ]))
}

fn def_aivi_chronos_duration_1ms__1fac3a75b768e08b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_ms: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Millisecond".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_ms.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1s__07f85507b4b9a0fd_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_s: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Second".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_s.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1s__07f85507b4b9a0fd_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_s: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Second".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_s.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1s__07f85507b4b9a0fd_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Saturation".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(n.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1s__07f85507b4b9a0fd(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def__1s__07f85507b4b9a0fd_clause_0(rt))?,
        (def__1s__07f85507b4b9a0fd_clause_1(rt))?,
        (def__1s__07f85507b4b9a0fd_clause_2(rt))?,
    ]))
}

fn def_aivi_chronos_duration_1s__a1872bd2f4a696c0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_s: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Second".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_s.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1min__0d7abcefd64368b0_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_min: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Minute".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_min.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1min__0d7abcefd64368b0_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_min: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Minute".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_min.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1min__0d7abcefd64368b0(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def__1min__0d7abcefd64368b0_clause_0(rt))?,
        (def__1min__0d7abcefd64368b0_clause_1(rt))?,
    ]))
}

fn def_aivi_chronos_duration_1min__3aaa3b06a7530b85(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_min: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Minute".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_min.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1h__07f85a07b4b9a97c_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_h: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Hour".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_h.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1h__07f85a07b4b9a97c_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_h: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Hour".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_h.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1h__07f85a07b4b9a97c_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Hue".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(n.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1h__07f85a07b4b9a97c(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def__1h__07f85a07b4b9a97c_clause_0(rt))?,
        (def__1h__07f85a07b4b9a97c_clause_1(rt))?,
        (def__1h__07f85a07b4b9a97c_clause_2(rt))?,
    ]))
}

fn def_aivi_chronos_duration_1h__a18746d2f4a6c4a1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_h: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Hour".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_h.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_addMillis__97b531592bac19aa(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |millis: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("addMillis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(millis.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_chronos_instant_addMillis__5bfbb228db38ff94(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |millis: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("addMillis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(millis.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_diffMillis__f0cdb676a7160de4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("diffMillis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_chronos_instant_diffMillis__60816b9fec9c5ffa(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("diffMillis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______09ada917f6895128(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            ({
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_chronos_instant______5fbd2850caa823f6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            ({
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_______fb3edcb7eb3286b7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            ({
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) <= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_chronos_instant_______5666d8485b92bac1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            ({
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) <= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def______09a68d17f68302e6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            ({
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) > b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a > (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_chronos_instant______5fc40450caae0578(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            ({
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) > b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a > (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_______e94886b7e0d784f1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            ({
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a >= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a >= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) >= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a >= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_chronos_instant_______685cae4865ece307(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            ({
                let f = ((aivi_ok(__builtin("instant"))).and_then(|b| match b { Value::Record(map) => map.get("compare").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a >= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a >= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) >= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a >= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_chronos_instant______5f978850ca87f7d9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = (def_addMillis__97b531592bac19aa(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push(((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_chronos_instant______5f832450ca76a4e3_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = (def_addMillis__97b531592bac19aa(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(span.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_chronos_instant______5f832450ca76a4e3_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let mut map = HashMap::new();
                map.insert("millis".to_string(), ({
                let f = (def_diffMillis__f0cdb676a7160de4(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_chronos_instant______5f832450ca76a4e3(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_chronos_instant______5f832450ca76a4e3_clause_0(rt))?,
        (def_aivi_chronos_instant______5f832450ca76a4e3_clause_1(rt))?,
    ]))
}

fn def_timezone__5c83d5694e9ab882(rt: &mut Runtime) -> R {
    {
        aivi_ok(Value::Unit)
    }
}

#[allow(dead_code)]
fn def_timezone__5c83d5694e9ab882_typed(rt: &mut Runtime) -> Result<(), RuntimeError> {
    Ok(())
}

fn def_aivi_chronos_timezone_timezone__1e1570699bdb8c22(rt: &mut Runtime) -> R {
    {
        aivi_ok(Value::Unit)
    }
}

fn def_getOffset__ecb2000d673208cc_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |zone: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |instant: Value, rt: &mut Runtime| {
            let zone = zone.clone();
            {
                let f = ((def_timezone__5c83d5694e9ab882(rt)).and_then(|b| match b { Value::Record(map) => map.get("getOffset").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(zone.clone()))?);
                __aivi_call_args.push((aivi_ok(instant.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_getOffset__ecb2000d673208cc_clause_1(rt: &mut Runtime) -> R {
    def_getOffset__ecb2000d673208cc(rt)
}

fn def_getOffset__ecb2000d673208cc(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_getOffset__ecb2000d673208cc_clause_0(rt))?,
        (def_getOffset__ecb2000d673208cc_clause_1(rt))?,
    ]))
}

fn def_aivi_chronos_timezone_getOffset__8fcc78d43bf7e12c_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |zone: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |instant: Value, rt: &mut Runtime| {
            let zone = zone.clone();
            {
                let f = ((def_timezone__5c83d5694e9ab882(rt)).and_then(|b| match b { Value::Record(map) => map.get("getOffset").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(zone.clone()))?);
                __aivi_call_args.push((aivi_ok(instant.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_chronos_timezone_getOffset__8fcc78d43bf7e12c_clause_1(rt: &mut Runtime) -> R {
    def_getOffset__ecb2000d673208cc(rt)
}

fn def_aivi_chronos_timezone_getOffset__8fcc78d43bf7e12c(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_chronos_timezone_getOffset__8fcc78d43bf7e12c_clause_0(rt))?,
        (def_aivi_chronos_timezone_getOffset__8fcc78d43bf7e12c_clause_1(rt))?,
    ]))
}

fn def_toInstant__db9d4ab0523809f5_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |zdt: Value, rt: &mut Runtime| {
        {
            let f = ((def_timezone__5c83d5694e9ab882(rt)).and_then(|b| match b { Value::Record(map) => map.get("toInstant").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(zdt.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toInstant__db9d4ab0523809f5_clause_1(rt: &mut Runtime) -> R {
    def_toInstant__db9d4ab0523809f5(rt)
}

fn def_toInstant__db9d4ab0523809f5(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_toInstant__db9d4ab0523809f5_clause_0(rt))?,
        (def_toInstant__db9d4ab0523809f5_clause_1(rt))?,
    ]))
}

fn def_aivi_chronos_timezone_toInstant__a8a6dc825352d955_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |zdt: Value, rt: &mut Runtime| {
        {
            let f = ((def_timezone__5c83d5694e9ab882(rt)).and_then(|b| match b { Value::Record(map) => map.get("toInstant").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(zdt.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_chronos_timezone_toInstant__a8a6dc825352d955_clause_1(rt: &mut Runtime) -> R {
    def_toInstant__db9d4ab0523809f5(rt)
}

fn def_aivi_chronos_timezone_toInstant__a8a6dc825352d955(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_chronos_timezone_toInstant__a8a6dc825352d955_clause_0(rt))?,
        (def_aivi_chronos_timezone_toInstant__a8a6dc825352d955_clause_1(rt))?,
    ]))
}

fn def_atZone__0216734ddea1b4be_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |zdt: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |zone: Value, rt: &mut Runtime| {
            let zdt = zdt.clone();
            {
                let f = ((def_timezone__5c83d5694e9ab882(rt)).and_then(|b| match b { Value::Record(map) => map.get("atZone").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(zdt.clone()))?);
                __aivi_call_args.push((aivi_ok(zone.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_atZone__0216734ddea1b4be_clause_1(rt: &mut Runtime) -> R {
    def_atZone__0216734ddea1b4be(rt)
}

fn def_atZone__0216734ddea1b4be(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_atZone__0216734ddea1b4be_clause_0(rt))?,
        (def_atZone__0216734ddea1b4be_clause_1(rt))?,
    ]))
}

fn def_aivi_chronos_timezone_atZone__41a2adcaeba78e9e_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |zdt: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |zone: Value, rt: &mut Runtime| {
            let zdt = zdt.clone();
            {
                let f = ((def_timezone__5c83d5694e9ab882(rt)).and_then(|b| match b { Value::Record(map) => map.get("atZone").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(zdt.clone()))?);
                __aivi_call_args.push((aivi_ok(zone.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_chronos_timezone_atZone__41a2adcaeba78e9e_clause_1(rt: &mut Runtime) -> R {
    def_atZone__0216734ddea1b4be(rt)
}

fn def_aivi_chronos_timezone_atZone__41a2adcaeba78e9e(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_chronos_timezone_atZone__41a2adcaeba78e9e_clause_0(rt))?,
        (def_aivi_chronos_timezone_atZone__41a2adcaeba78e9e_clause_1(rt))?,
    ]))
}

fn def_aivi_duration_negateDelta__3ba9e9f027428002(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
        (aivi_ok(delta.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Millisecond" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Millisecond".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Second" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Second".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Minute" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Minute".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_3(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Hour" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_3(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Hour".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_duration______967c5eccf8123c82_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Millisecond" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_duration______967c5eccf8123c82_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Second" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(1000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_duration______967c5eccf8123c82_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Minute" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(60000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_duration______967c5eccf8123c82_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Hour" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("millis".to_string(), (((aivi_ok(span.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(3600000))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_duration______967c5eccf8123c82_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s2: Value, rt: &mut Runtime| {
            let s1 = s1.clone();
            {
                let mut map = HashMap::new();
                map.insert("millis".to_string(), (((aivi_ok(s1.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(s2.clone())).and_then(|b| match b { Value::Record(map) => map.get("millis").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_duration______967c5eccf8123c82(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_duration______967c5eccf8123c82_clause_0(rt))?,
        (def_aivi_duration______967c5eccf8123c82_clause_1(rt))?,
        (def_aivi_duration______967c5eccf8123c82_clause_2(rt))?,
        (def_aivi_duration______967c5eccf8123c82_clause_3(rt))?,
        (def_aivi_duration______967c5eccf8123c82_clause_4(rt))?,
    ]))
}

fn def_aivi_duration______967552ccf80c0970(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |span: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let span = span.clone();
            (aivi_ok(span.clone())).and_then(|l| ({
                let f = (def_negateDelta__62390cb65750aabb(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_duration_1ms__cd9c65cc85d372fd(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_ms: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Millisecond".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_ms.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_duration_1s__f87231eed0a36ffe(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_s: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Second".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_s.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_duration_1min__34486d87665dd573(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_min: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Minute".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_min.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_duration_1h__f87238eed0a37be3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_h: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Hour".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_h.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_adjustLightness__cf11cff218302fe9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |amount: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("adjustLightness").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(amount.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_color_adjustLightness__bc558269815dcadb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |amount: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("adjustLightness").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(amount.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_adjustSaturation__38af6189d5042f6e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |amount: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("adjustSaturation").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(amount.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_color_adjustSaturation__edee7facdfa4870c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |amount: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("adjustSaturation").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(amount.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_adjustHue__8d3423813282e5b0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |amount: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("adjustHue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(amount.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_color_adjustHue__719457a8a486ff2a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |amount: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("adjustHue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(amount.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_toRgb__798b1e7e10db70e7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("toRgb").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_color_toRgb__7a857ebe09aefe41(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("toRgb").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toHsl__2322767ddff94e3b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("toHsl").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_color_toHsl__d15af6be3aeda13d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("toHsl").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toHex__22d7667ddfb94791(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("toHex").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_color_toHex__d13906be3ad0d607(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("color"))).and_then(|b| match b { Value::Record(map) => map.get("toHex").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_color_negateDelta__f5918482c9c79e6d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
        (aivi_ok(delta.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Lightness" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Lightness".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Saturation" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Saturation".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Hue" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("n", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let n = __b.remove("n").expect("pattern binder");
                    return {
                        let f = (aivi_ok(Value::Constructor { name: "Hue".to_string(), args: Vec::new() }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_color______d983f33c5b63daf5_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |col: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let col = col.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Lightness" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_adjustLightness__cf11cff218302fe9(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(col.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_color______d983f33c5b63daf5_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |col: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let col = col.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Saturation" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_adjustSaturation__38af6189d5042f6e(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(col.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_color______d983f33c5b63daf5_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |col: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let col = col.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Hue" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        return {
                            let f = (def_adjustHue__8d3423813282e5b0(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(col.clone()))?);
                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_color______d983f33c5b63daf5_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Record(_) => {
                            let mut cur0: &Value = v;
                            cur0 = match cur0 {
                                Value::Record(m) => match m.get("r") {
                                    Some(v) => v,
                                    None => return false,
                                },
                                _ => return false,
                            };
                            if !({ b.insert("r", cur0.clone()); true }) { return false; }
                            let mut cur1: &Value = v;
                            cur1 = match cur1 {
                                Value::Record(m) => match m.get("g") {
                                    Some(v) => v,
                                    None => return false,
                                },
                                _ => return false,
                            };
                            if !({ b.insert("g", cur1.clone()); true }) { return false; }
                            let mut cur2: &Value = v;
                            cur2 = match cur2 {
                                Value::Record(m) => match m.get("b") {
                                    Some(v) => v,
                                    None => return false,
                                },
                                _ => return false,
                            };
                            if !({ b.insert("b", cur2.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let b = __b.remove("b").expect("pattern binder");
                        let g = __b.remove("g").expect("pattern binder");
                        let r = __b.remove("r").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            map.insert("r".to_string(), (((aivi_ok(left.clone())).and_then(|b| match b { Value::Record(map) => map.get("r").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(r.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            map.insert("g".to_string(), (((aivi_ok(left.clone())).and_then(|b| match b { Value::Record(map) => map.get("g").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(g.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            map.insert("b".to_string(), (((aivi_ok(left.clone())).and_then(|b| match b { Value::Record(map) => map.get("b").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_color______d983f33c5b63daf5(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_color______d983f33c5b63daf5_clause_0(rt))?,
        (def_aivi_color______d983f33c5b63daf5_clause_1(rt))?,
        (def_aivi_color______d983f33c5b63daf5_clause_2(rt))?,
        (def_aivi_color______d983f33c5b63daf5_clause_3(rt))?,
    ]))
}

fn def_aivi_color______d98acf3c5b69bc77(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |col: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let col = col.clone();
            (aivi_ok(col.clone())).and_then(|l| ({
                let f = (def_negateDelta__62390cb65750aabb(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def__1l__07f85607b4b9a2b0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Lightness".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(n.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def__1l__07f85607b4b9a2b0_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<__Adt_Delta_f01cbd377882356b, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |n: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<__Adt_Delta_f01cbd377882356b, RuntimeError> {
            Ok(__Adt_Delta_f01cbd377882356b::Lightness(n))
        })
    })
}

fn def_aivi_color_1l__0205d215e990285e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Lightness".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(n.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_color_1s__0205dd15e9903b0f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Saturation".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(n.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_color_1h__0205d615e9902f2a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Hue".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(n.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1r__07f85407b4b99f4a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("r".to_string(), (aivi_ok(n.clone()))?);
            map.insert("g".to_string(), (aivi_ok(Value::Int(0)))?);
            map.insert("b".to_string(), (aivi_ok(Value::Int(0)))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_color_1r__0205dc15e990395c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("r".to_string(), (aivi_ok(n.clone()))?);
            map.insert("g".to_string(), (aivi_ok(Value::Int(0)))?);
            map.insert("b".to_string(), (aivi_ok(Value::Int(0)))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def__1g__07f86107b4b9b561(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("r".to_string(), (aivi_ok(Value::Int(0)))?);
            map.insert("g".to_string(), (aivi_ok(n.clone()))?);
            map.insert("b".to_string(), (aivi_ok(Value::Int(0)))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_color_1g__0205c915e9901913(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("r".to_string(), (aivi_ok(Value::Int(0)))?);
            map.insert("g".to_string(), (aivi_ok(n.clone()))?);
            map.insert("b".to_string(), (aivi_ok(Value::Int(0)))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def__1b__07f86407b4b9ba7a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("r".to_string(), (aivi_ok(Value::Int(0)))?);
            map.insert("g".to_string(), (aivi_ok(Value::Int(0)))?);
            map.insert("b".to_string(), (aivi_ok(n.clone()))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_color_1b__0205cc15e9901e2c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("r".to_string(), (aivi_ok(Value::Int(0)))?);
            map.insert("g".to_string(), (aivi_ok(Value::Int(0)))?);
            map.insert("b".to_string(), (aivi_ok(n.clone()))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_vec2__670b9501024b9ff5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
            let x = x.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (aivi_ok(x.clone()))?);
                map.insert("y".to_string(), (aivi_ok(y.clone()))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector_vec2__b6d5d87d1438a307(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
            let x = x.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (aivi_ok(x.clone()))?);
                map.insert("y".to_string(), (aivi_ok(y.clone()))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_vec3__670b9401024b9e42(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
            let x = x.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                let x = x.clone();
                let y = y.clone();
                {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (aivi_ok(x.clone()))?);
                    map.insert("y".to_string(), (aivi_ok(y.clone()))?);
                    map.insert("z".to_string(), (aivi_ok(z.clone()))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_vector_vec3__b6d5d77d1438a154(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
            let x = x.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                let x = x.clone();
                let y = y.clone();
                {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (aivi_ok(x.clone()))?);
                    map.insert("y".to_string(), (aivi_ok(y.clone()))?);
                    map.insert("z".to_string(), (aivi_ok(z.clone()))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }) })))
        }) })))
    }) })))
}

fn def_vec4__670b8f01024b95c3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
            let x = x.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                let x = x.clone();
                let y = y.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |w: Value, rt: &mut Runtime| {
                    let x = x.clone();
                    let y = y.clone();
                    let z = z.clone();
                    {
                        let mut map = HashMap::new();
                        map.insert("x".to_string(), (aivi_ok(x.clone()))?);
                        map.insert("y".to_string(), (aivi_ok(y.clone()))?);
                        map.insert("z".to_string(), (aivi_ok(z.clone()))?);
                        map.insert("w".to_string(), (aivi_ok(w.clone()))?);
                        aivi_ok(Value::Record(Arc::new(map)))
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_vector_vec4__b6d5d67d14389fa1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
            let x = x.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
                let x = x.clone();
                let y = y.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |w: Value, rt: &mut Runtime| {
                    let x = x.clone();
                    let y = y.clone();
                    let z = z.clone();
                    {
                        let mut map = HashMap::new();
                        map.insert("x".to_string(), (aivi_ok(x.clone()))?);
                        map.insert("y".to_string(), (aivi_ok(y.clone()))?);
                        map.insert("z".to_string(), (aivi_ok(z.clone()))?);
                        map.insert("w".to_string(), (aivi_ok(w.clone()))?);
                        aivi_ok(Value::Record(Arc::new(map)))
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_magnitude__51bb22db9bbc7b95_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_magnitude__51bb22db9bbc7b95_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((((((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_magnitude__51bb22db9bbc7b95_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((((((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_magnitude__51bb22db9bbc7b95_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        {
            let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((((((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_magnitude__51bb22db9bbc7b95(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_magnitude__51bb22db9bbc7b95_clause_0(rt))?,
        (def_magnitude__51bb22db9bbc7b95_clause_1(rt))?,
        (def_magnitude__51bb22db9bbc7b95_clause_2(rt))?,
        (def_magnitude__51bb22db9bbc7b95_clause_3(rt))?,
    ]))
}

fn def_aivi_vector_magnitude__f715e41e9d4ca3d7_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_vector_magnitude__f715e41e9d4ca3d7_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((((((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_vector_magnitude__f715e41e9d4ca3d7_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((((((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_vector_magnitude__f715e41e9d4ca3d7(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector_magnitude__f715e41e9d4ca3d7_clause_0(rt))?,
        (def_aivi_vector_magnitude__f715e41e9d4ca3d7_clause_1(rt))?,
        (def_aivi_vector_magnitude__f715e41e9d4ca3d7_clause_2(rt))?,
    ]))
}

fn def_normalize__eabe8385437e66cc_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("len", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let len = __b0.remove("len").expect("pattern binder");
            ((aivi_ok(len.clone())).and_then(|a| (aivi_ok(Value::Float(0.0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(v.clone()), Value::Bool(false) => {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_normalize__eabe8385437e66cc_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("len", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let len = __b0.remove("len").expect("pattern binder");
            ((aivi_ok(len.clone())).and_then(|a| (aivi_ok(Value::Float(0.0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(v.clone()), Value::Bool(false) => {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_normalize__eabe8385437e66cc_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sig: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("signal"))).and_then(|b| match b { Value::Record(map) => map.get("normalize").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sig.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_normalize__eabe8385437e66cc_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_edgeEndpoints__4c418dd92e5e9bba(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("endpoints", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let endpoints = __b0.remove("endpoints").expect("pattern binder");
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ({
                let f = (def_uniqueNodeIds__3c42dccc48aa0d04(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_append__3e7fe942f71f1e61(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    __aivi_call_args.push((aivi_ok(endpoints.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("edges".to_string(), ((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }
    }) })))
}

fn def_normalize__eabe8385437e66cc_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            match (aivi_ok(p.clone()))? { Value::Record(m) => { map.extend(m.as_ref().clone()); }, _ => return Err(RuntimeError::Message("record spread expects a record".to_string())), };
            map.insert("segments".to_string(), ({
            let f = (def_normalizeSegments__eaaa92e4158a8d92(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        })?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_normalize__eabe8385437e66cc_clause_5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("normalize").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_normalize__eabe8385437e66cc_clause_6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(q.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("m", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let m = __b0.remove("m").expect("pattern binder");
            ((aivi_ok(m.clone())).and_then(|a| (aivi_ok(Value::Float(0.0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(q.clone()), Value::Bool(false) => (aivi_ok(q.clone())).and_then(|l| (aivi_ok(m.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_normalize__eabe8385437e66cc(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_normalize__eabe8385437e66cc_clause_0(rt))?,
        (def_normalize__eabe8385437e66cc_clause_1(rt))?,
        (def_normalize__eabe8385437e66cc_clause_2(rt))?,
        (def_normalize__eabe8385437e66cc_clause_3(rt))?,
        (def_normalize__eabe8385437e66cc_clause_4(rt))?,
        (def_normalize__eabe8385437e66cc_clause_5(rt))?,
        (def_normalize__eabe8385437e66cc_clause_6(rt))?,
    ]))
}

fn def_aivi_vector_normalize__1c28c6df260a9676_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("len", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let len = __b0.remove("len").expect("pattern binder");
            ((aivi_ok(len.clone())).and_then(|a| (aivi_ok(Value::Float(0.0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(v.clone()), Value::Bool(false) => {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_aivi_vector_normalize__1c28c6df260a9676_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("len", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let len = __b0.remove("len").expect("pattern binder");
            ((aivi_ok(len.clone())).and_then(|a| (aivi_ok(Value::Float(0.0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(v.clone()), Value::Bool(false) => {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(len.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_aivi_vector_normalize__1c28c6df260a9676(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector_normalize__1c28c6df260a9676_clause_0(rt))?,
        (def_aivi_vector_normalize__1c28c6df260a9676_clause_1(rt))?,
    ]))
}

fn def_dot__caaf2818f47458a0_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_dot__caaf2818f47458a0_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_dot__caaf2818f47458a0_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("linalg"))).and_then(|b| match b { Value::Record(map) => map.get("dot").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_dot__caaf2818f47458a0(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_dot__caaf2818f47458a0_clause_0(rt))?,
        (def_dot__caaf2818f47458a0_clause_1(rt))?,
        (def_dot__caaf2818f47458a0_clause_2(rt))?,
    ]))
}

fn def_aivi_vector_dot__2e0c5d1d77594856_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_vector_dot__2e0c5d1d77594856_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_vector_dot__2e0c5d1d77594856(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector_dot__2e0c5d1d77594856_clause_0(rt))?,
        (def_aivi_vector_dot__2e0c5d1d77594856_clause_1(rt))?,
    ]))
}

fn def_cross__0c36469f09fb69fb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector_cross__95b19ff2615c2f49(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_negate__160720ef70b2d29b_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("x".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("y".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_negate__160720ef70b2d29b_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("x".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("y".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("z".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_negate__160720ef70b2d29b_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("x".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("y".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("z".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("w".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_negate__160720ef70b2d29b(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_negate__160720ef70b2d29b_clause_0(rt))?,
        (def_negate__160720ef70b2d29b_clause_1(rt))?,
        (def_negate__160720ef70b2d29b_clause_2(rt))?,
    ]))
}

fn def_aivi_vector_negate__f29d5e3f6e015e71_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("x".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("y".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_vector_negate__f29d5e3f6e015e71_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("x".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("y".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("z".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_vector_negate__f29d5e3f6e015e71_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("x".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("y".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("z".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("w".to_string(), ((aivi_ok(Value::Float(0.0))).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_vector_negate__f29d5e3f6e015e71(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector_negate__f29d5e3f6e015e71_clause_0(rt))?,
        (def_aivi_vector_negate__f29d5e3f6e015e71_clause_1(rt))?,
        (def_aivi_vector_negate__f29d5e3f6e015e71_clause_2(rt))?,
    ]))
}

fn def_lerp__24d97cada2273628_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
                let a = a.clone();
                let b = b.clone();
                {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }) })))
        }) })))
    }) })))
}

fn def_lerp__24d97cada2273628_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
                let a = a.clone();
                let b = b.clone();
                {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }) })))
        }) })))
    }) })))
}

fn def_lerp__24d97cada2273628(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_lerp__24d97cada2273628_clause_0(rt))?,
        (def_lerp__24d97cada2273628_clause_1(rt))?,
    ]))
}

fn def_aivi_vector_lerp__f59ae4d07173b0c2_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
                let a = a.clone();
                let b = b.clone();
                {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_vector_lerp__f59ae4d07173b0c2_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
                let a = a.clone();
                let b = b.clone();
                {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(t.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_vector_lerp__f59ae4d07173b0c2(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector_lerp__f59ae4d07173b0c2_clause_0(rt))?,
        (def_aivi_vector_lerp__f59ae4d07173b0c2_clause_1(rt))?,
    ]))
}

fn def_distance__dd6fbd38986b7842_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_distance__dd6fbd38986b7842_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_distance__dd6fbd38986b7842_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let __v = (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("dx", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let dx = __b0.remove("dx").expect("pattern binder");
                let __v = (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("dy", v.clone()); true }
                        }

                })(&__v, &mut __b1);
                if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let dy = __b1.remove("dy").expect("pattern binder");
                {
                    let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((((aivi_ok(dx.clone())).and_then(|l| (aivi_ok(dx.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(dy.clone())).and_then(|l| (aivi_ok(dy.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    rt.call(f, __aivi_call_args)
                }
            }
        }) })))
    }) })))
}

fn def_distance__dd6fbd38986b7842(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_distance__dd6fbd38986b7842_clause_0(rt))?,
        (def_distance__dd6fbd38986b7842_clause_1(rt))?,
        (def_distance__dd6fbd38986b7842_clause_2(rt))?,
    ]))
}

fn def_aivi_vector_distance__e113d29cbd4d0674_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_vector_distance__e113d29cbd4d0674_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_vector_distance__e113d29cbd4d0674(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector_distance__e113d29cbd4d0674_clause_0(rt))?,
        (def_aivi_vector_distance__e113d29cbd4d0674_clause_1(rt))?,
    ]))
}

fn def_transform2__ba2a36db966df72b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), ((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), ((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector_transform2__d1119713b2be270d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), ((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), ((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_transform3__ba2a35db966df578(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector_transform3__d1119613b2be255a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_transform4__ba2a3cdb966e015d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector_transform4__d1119113b2be1cdb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_transformPoint3__7d553e839cd81550(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let __v = ((aivi_ok(Value::Float(1.0))).and_then(|l| ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("invW", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let invW = __b0.remove("invW").expect("pattern binder");
                {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(invW.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(invW.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(invW.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }
        }) })))
    }) })))
}

fn def_aivi_vector_transformPoint3__28db6a64d7dcc43e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let __v = ((aivi_ok(Value::Float(1.0))).and_then(|l| ((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("invW", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let invW = __b0.remove("invW").expect("pattern binder");
                {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(invW.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(invW.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(invW.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }
        }) })))
    }) })))
}

fn def_transformDir3__b570f3c57683c36b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |d: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector_transformDir3__7b6863078aaca15d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |d: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(d.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f086ee1e76848a9d_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f086ee1e76848a9d_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f086ee1e76848a9d_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f086ee1e76848a9d(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector______f086ee1e76848a9d_clause_0(rt))?,
        (def_aivi_vector______f086ee1e76848a9d_clause_1(rt))?,
        (def_aivi_vector______f086ee1e76848a9d_clause_2(rt))?,
    ]))
}

fn def_aivi_vector______f08d6a1e7689c8ff_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f08d6a1e7689c8ff_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f08d6a1e7689c8ff_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v1: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v2: Value, rt: &mut Runtime| {
            let v1 = v1.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), (((aivi_ok(v1.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(v2.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f08d6a1e7689c8ff(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector______f08d6a1e7689c8ff_clause_0(rt))?,
        (def_aivi_vector______f08d6a1e7689c8ff_clause_1(rt))?,
        (def_aivi_vector______f08d6a1e7689c8ff_clause_2(rt))?,
    ]))
}

fn def_aivi_vector______f08a021e7686e270_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f08a021e7686e270_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f08a021e7686e270_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f08a021e7686e270(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector______f08a021e7686e270_clause_0(rt))?,
        (def_aivi_vector______f08a021e7686e270_clause_1(rt))?,
        (def_aivi_vector______f08a021e7686e270_clause_2(rt))?,
    ]))
}

fn def_aivi_vector______f094861e76901741_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f094861e76901741_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f094861e76901741_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("w".to_string(), (((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_vector______f094861e76901741(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_vector______f094861e76901741_clause_0(rt))?,
        (def_aivi_vector______f094861e76901741_clause_1(rt))?,
        (def_aivi_vector______f094861e76901741_clause_2(rt))?,
    ]))
}

fn def_identity2__a8a5d2d934ab35cb(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("m00".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m01".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m10".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m11".to_string(), (aivi_ok(Value::Float(1.0)))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_aivi_matrix_identity2__29790d9dd5cee333(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("m00".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m01".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m10".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m11".to_string(), (aivi_ok(Value::Float(1.0)))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_identity3__a8a5d1d934ab3418(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("m00".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m01".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m02".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m10".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m11".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m12".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m20".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m21".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m22".to_string(), (aivi_ok(Value::Float(1.0)))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_aivi_matrix_identity3__29790c9dd5cee180(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("m00".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m01".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m02".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m10".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m11".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m12".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m20".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m21".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m22".to_string(), (aivi_ok(Value::Float(1.0)))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_identity4__a8a5d8d934ab3ffd(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("m00".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m01".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m02".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m03".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m10".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m11".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m12".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m13".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m20".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m21".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m22".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m23".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m30".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m31".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m32".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m33".to_string(), (aivi_ok(Value::Float(1.0)))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_aivi_matrix_identity4__2979139dd5ceed65(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("m00".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m01".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m02".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m03".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m10".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m11".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m12".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m13".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m20".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m21".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m22".to_string(), (aivi_ok(Value::Float(1.0)))?);
        map.insert("m23".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m30".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m31".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m32".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("m33".to_string(), (aivi_ok(Value::Float(1.0)))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_transpose2__37d40e401643c376(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("m00".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m01".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m10".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m11".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_matrix_transpose2__96aa061525c9254e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("m00".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m01".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m10".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m11".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_transpose3__37d40f401643c529(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("m00".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m01".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m02".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m10".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m11".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m12".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m20".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m21".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m22".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_matrix_transpose3__96aa071525c92701(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("m00".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m01".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m02".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m10".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m11".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m12".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m20".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m21".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m22".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_transpose4__37d410401643c6dc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("m00".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m01".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m02".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m03".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m10".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m11".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m12".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m13".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m20".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m21".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m22".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m23".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m30".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m31".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m32".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m33".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_matrix_transpose4__96aa081525c928b4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("m00".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m01".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m02".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m03".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m10".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m11".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m12".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m13".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m20".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m21".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m22".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m23".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m30".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m31".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m32".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("m33".to_string(), ((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_multiply2__7ab313d659909555(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix_multiply2__c2277fb8264dbfad(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_multiply3__7ab312d6599093a2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix_multiply3__c2277eb8264dbdfa(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_multiply4__7ab30dd659908b23(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m03".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m13".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m23".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m30".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m31".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m32".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m33".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix_multiply4__c22779b8264db57b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m03".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m13".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m23".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m30".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m31".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m32".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m33".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d6f2a37c119c53f_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d6f2a37c119c53f_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d6f2a37c119c53f_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m03".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m13".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m23".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m30".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m31".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m32".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m33".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d6f2a37c119c53f(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_matrix______8d6f2a37c119c53f_clause_0(rt))?,
        (def_aivi_matrix______8d6f2a37c119c53f_clause_1(rt))?,
        (def_aivi_matrix______8d6f2a37c119c53f_clause_2(rt))?,
    ]))
}

fn def_aivi_matrix______8d68ae37c11486dd_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d68ae37c11486dd_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d68ae37c11486dd_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m03".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m13".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m23".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m30".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m31".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m32".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m33".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d68ae37c11486dd(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_matrix______8d68ae37c11486dd_clause_0(rt))?,
        (def_aivi_matrix______8d68ae37c11486dd_clause_1(rt))?,
        (def_aivi_matrix______8d68ae37c11486dd_clause_2(rt))?,
    ]))
}

fn def_aivi_matrix______8d72ce37c11d11c2_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d72ce37c11d11c2_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d72ce37c11d11c2_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let mut map = HashMap::new();
                map.insert("m00".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m00").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m01".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m01").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m02".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m02").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m03".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m03").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m10".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m11".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m11").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m12".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m12").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m13".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m13").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m20".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m20").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m21".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m21").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m22".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m22").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m23".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m23").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m30".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m30").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m31".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m31").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m32".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m32").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("m33".to_string(), (((aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("m33").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______8d72ce37c11d11c2(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_matrix______8d72ce37c11d11c2_clause_0(rt))?,
        (def_aivi_matrix______8d72ce37c11d11c2_clause_1(rt))?,
        (def_aivi_matrix______8d72ce37c11d11c2_clause_2(rt))?,
    ]))
}

fn def______b43e85bb294c2ba8_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_multiply2__7ab313d659909555(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______b43e85bb294c2ba8_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let f = (def_transform2__ba2a36db966df72b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(m.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______b43e85bb294c2ba8_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_multiply3__7ab312d6599093a2(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______b43e85bb294c2ba8_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let f = (def_transform3__ba2a35db966df578(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(m.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______b43e85bb294c2ba8_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_multiply4__7ab30dd659908b23(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______b43e85bb294c2ba8_clause_5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let f = (def_transform4__ba2a3cdb966e015d(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(m.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def______b43e85bb294c2ba8(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def______b43e85bb294c2ba8_clause_0(rt))?,
        (def______b43e85bb294c2ba8_clause_1(rt))?,
        (def______b43e85bb294c2ba8_clause_2(rt))?,
        (def______b43e85bb294c2ba8_clause_3(rt))?,
        (def______b43e85bb294c2ba8_clause_4(rt))?,
        (def______b43e85bb294c2ba8_clause_5(rt))?,
    ]))
}

fn def_aivi_matrix______21148eb8fd188340_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_multiply2__7ab313d659909555(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______21148eb8fd188340_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let f = (def_transform2__ba2a36db966df72b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(m.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______21148eb8fd188340_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_multiply3__7ab312d6599093a2(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______21148eb8fd188340_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let f = (def_transform3__ba2a35db966df578(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(m.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______21148eb8fd188340_clause_4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = (def_multiply4__7ab30dd659908b23(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______21148eb8fd188340_clause_5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let f = (def_transform4__ba2a3cdb966e015d(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(m.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_matrix______21148eb8fd188340(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_matrix______21148eb8fd188340_clause_0(rt))?,
        (def_aivi_matrix______21148eb8fd188340_clause_1(rt))?,
        (def_aivi_matrix______21148eb8fd188340_clause_2(rt))?,
        (def_aivi_matrix______21148eb8fd188340_clause_3(rt))?,
        (def_aivi_matrix______21148eb8fd188340_clause_4(rt))?,
        (def_aivi_matrix______21148eb8fd188340_clause_5(rt))?,
    ]))
}

fn def_aivi_linear_algebra_map__e873ded811657ef2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(items.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?]); out.extend({ let v = ({
                            let f = (aivi_ok(__builtin("map")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(f.clone()))?);
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_zipWith__bc0e3a3a8976736c_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
            let f = f.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
                let f = f.clone();
                let left = left.clone();
                (aivi_ok(Value::Tuple(vec![(aivi_ok(left.clone()))?, (aivi_ok(right.clone()))?]))).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(match v0 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }) { return false; }
                                let v1 = &items[1];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(true) { return false; }
                                let v1 = &items[1];
                                if !(match v1 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(match v0 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("xs", (&tail).clone()); true }
                                }, _ => false }) { return false; }
                                let v1 = &items[1];
                                if !(match v1 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("y", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("ys", (&tail).clone()); true }
                                }, _ => false }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_2(&__scrut, &mut __b) {
                            let x = __b.remove("x").expect("pattern binder");
                            let xs = __b.remove("xs").expect("pattern binder");
                            let y = __b.remove("y").expect("pattern binder");
                            let ys = __b.remove("ys").expect("pattern binder");
                            return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                __aivi_call_args.push((aivi_ok(y.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?]); out.extend({ let v = ({
                                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(f.clone()))?);
                                __aivi_call_args.push((aivi_ok(xs.clone()))?);
                                __aivi_call_args.push((aivi_ok(ys.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_zipWith__bc0e3a3a8976736c_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
            let f = f.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
                let f = f.clone();
                let left = left.clone();
                (aivi_ok(Value::Tuple(vec![(aivi_ok(left.clone()))?, (aivi_ok(right.clone()))?]))).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(match v0 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }) { return false; }
                                let v1 = &items[1];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(true) { return false; }
                                let v1 = &items[1];
                                if !(match v1 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(match v0 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("xs", (&tail).clone()); true }
                                }, _ => false }) { return false; }
                                let v1 = &items[1];
                                if !(match v1 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("y", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("ys", (&tail).clone()); true }
                                }, _ => false }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_2(&__scrut, &mut __b) {
                            let x = __b.remove("x").expect("pattern binder");
                            let xs = __b.remove("xs").expect("pattern binder");
                            let y = __b.remove("y").expect("pattern binder");
                            let ys = __b.remove("ys").expect("pattern binder");
                            return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                __aivi_call_args.push((aivi_ok(y.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?]); out.extend({ let v = ({
                                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(f.clone()))?);
                                __aivi_call_args.push((aivi_ok(xs.clone()))?);
                                __aivi_call_args.push((aivi_ok(ys.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_zipWith__bc0e3a3a8976736c(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_zipWith__bc0e3a3a8976736c_clause_0(rt))?,
        (def_zipWith__bc0e3a3a8976736c_clause_1(rt))?,
    ]))
}

fn def_aivi_linear_algebra_zipWith__79f3c14bfa17b51b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
            let f = f.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
                let f = f.clone();
                let left = left.clone();
                (aivi_ok(Value::Tuple(vec![(aivi_ok(left.clone()))?, (aivi_ok(right.clone()))?]))).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(match v0 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }) { return false; }
                                let v1 = &items[1];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(true) { return false; }
                                let v1 = &items[1];
                                if !(match v1 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(match v0 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("xs", (&tail).clone()); true }
                                }, _ => false }) { return false; }
                                let v1 = &items[1];
                                if !(match v1 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("y", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("ys", (&tail).clone()); true }
                                }, _ => false }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_2(&__scrut, &mut __b) {
                            let x = __b.remove("x").expect("pattern binder");
                            let xs = __b.remove("xs").expect("pattern binder");
                            let y = __b.remove("y").expect("pattern binder");
                            let ys = __b.remove("ys").expect("pattern binder");
                            return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                __aivi_call_args.push((aivi_ok(y.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?]); out.extend({ let v = ({
                                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(f.clone()))?);
                                __aivi_call_args.push((aivi_ok(xs.clone()))?);
                                __aivi_call_args.push((aivi_ok(ys.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_add__e70bc3190530e654_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_add__e70bc3190530e654_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_add__e70bc3190530e654(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_add__e70bc3190530e654_clause_0(rt))?,
        (def_add__e70bc3190530e654_clause_1(rt))?,
    ]))
}

fn def_aivi_linear_algebra_add__4dcec4d84a121bf7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_sub__82719d195d0fc2f5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_sub__82719d195d0fc2f5_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |a: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let a = a.clone();
            Box::new(move |b: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((a - b))
            })
        })
        })
    })
}

fn def_aivi_linear_algebra_sub__ec78a2d8a4b741fe(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_linear_algebra______2b0e4ed9589fbee4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("size".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("data".to_string(), ({
                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_add__e70bc3190530e654(rt))?);
                __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_linear_algebra______2af9ead9588e6bee(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("size".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("data".to_string(), ({
                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_sub__82719d195d0fc2f5(rt))?);
                __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_linear_algebra______2b0aead9589cdf21(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let v = v.clone();
            {
                let mut map = HashMap::new();
                map.insert("size".to_string(), ((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("data".to_string(), ({
                let f = (aivi_ok(__builtin("map")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
                    let s = s.clone();
                    (aivi_ok(_arg0.clone())).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
                }) }))))?);
                __aivi_call_args.push(((aivi_ok(v.clone())).and_then(|b| match b { Value::Record(map) => map.get("data").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_linear_algebra_dot__2289f7d831937cd3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("linalg"))).and_then(|b| match b { Value::Record(map) => map.get("dot").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_matMul__5d7f0f5b3a466b09(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("linalg"))).and_then(|b| match b { Value::Record(map) => map.get("matMul").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_linear_algebra_matMul__a8a86707a04ccd40(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("linalg"))).and_then(|b| match b { Value::Record(map) => map.get("matMul").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_solve2x2__6f0c20a32d3c9e58(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let f = ((aivi_ok(__builtin("linalg"))).and_then(|b| match b { Value::Record(map) => map.get("solve2x2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(m.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_linear_algebra_solve2x2__46153fa0d22c8865(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let m = m.clone();
            {
                let f = ((aivi_ok(__builtin("linalg"))).and_then(|b| match b { Value::Record(map) => map.get("solve2x2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(m.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_probability______6cabd07ba8552175(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_probability______6cb2ac7ba85b02f7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_probability______6caf447ba8581c68(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_clamp__d10152952fb94a7c_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        ((aivi_ok(p.clone())).and_then(|l| (aivi_ok(Value::Float(0.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(0.0)), Value::Bool(false) => ((aivi_ok(p.clone())).and_then(|l| (aivi_ok(Value::Float(1.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) > b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a > (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(1.0)), Value::Bool(false) => aivi_ok(p.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_clamp__d10152952fb94a7c_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |low: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |high: Value, rt: &mut Runtime| {
            let low = low.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let high = high.clone();
                let low = low.clone();
                {
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("clamp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(low.clone()))?);
                    __aivi_call_args.push((aivi_ok(high.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_clamp__d10152952fb94a7c(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_clamp__d10152952fb94a7c_clause_0(rt))?,
        (def_clamp__d10152952fb94a7c_clause_1(rt))?,
    ]))
}

fn def_aivi_probability_clamp__24561c88cf520022(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        ((aivi_ok(p.clone())).and_then(|l| (aivi_ok(Value::Float(0.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(0.0)), Value::Bool(false) => ((aivi_ok(p.clone())).and_then(|l| (aivi_ok(Value::Float(1.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) > b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a > (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(1.0)), Value::Bool(false) => aivi_ok(p.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_bernoulli__daba7a3108a82353(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("pdf".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let p = p.clone();
            (aivi_ok(b.clone())).and_then(|c| match c { Value::Bool(true) => aivi_ok(p.clone()), Value::Bool(false) => (aivi_ok(Value::Float(1.0))).and_then(|l| (aivi_ok(p.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) }))))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_probability_bernoulli__50643ec6f6dcb825(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("pdf".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let p = p.clone();
            (aivi_ok(b.clone())).and_then(|c| match c { Value::Bool(true) => aivi_ok(p.clone()), Value::Bool(false) => (aivi_ok(Value::Float(1.0))).and_then(|l| (aivi_ok(p.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) }))))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_uniform__246ba30e3d002a93(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |lo: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |hi: Value, rt: &mut Runtime| {
            let lo = lo.clone();
            {
                let mut map = HashMap::new();
                map.insert("pdf".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
                let hi = hi.clone();
                let lo = lo.clone();
                ((aivi_ok(x.clone())).and_then(|l| (aivi_ok(lo.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(0.0)), Value::Bool(false) => ((aivi_ok(x.clone())).and_then(|l| (aivi_ok(hi.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) > b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a > (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(0.0)), Value::Bool(false) => ((aivi_ok(lo.clone())).and_then(|a| (aivi_ok(hi.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(0.0)), Value::Bool(false) => (aivi_ok(Value::Float(1.0))).and_then(|l| ((aivi_ok(hi.clone())).and_then(|l| (aivi_ok(lo.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
            }) }))))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_probability_uniform__58d7780facb9d92d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |lo: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |hi: Value, rt: &mut Runtime| {
            let lo = lo.clone();
            {
                let mut map = HashMap::new();
                map.insert("pdf".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
                let hi = hi.clone();
                let lo = lo.clone();
                ((aivi_ok(x.clone())).and_then(|l| (aivi_ok(lo.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(0.0)), Value::Bool(false) => ((aivi_ok(x.clone())).and_then(|l| (aivi_ok(hi.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a > b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) > b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a > (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for >: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(0.0)), Value::Bool(false) => ((aivi_ok(lo.clone())).and_then(|a| (aivi_ok(hi.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Float(0.0)), Value::Bool(false) => (aivi_ok(Value::Float(1.0))).and_then(|l| ((aivi_ok(hi.clone())).and_then(|l| (aivi_ok(lo.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
            }) }))))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_expectation__493c54823adf3ea5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |dist: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
            let dist = dist.clone();
            ({
                let f = ((aivi_ok(dist.clone())).and_then(|b| match b { Value::Record(map) => map.get("pdf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(x.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(x.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_probability_expectation__6e4815e0083b8cab(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |dist: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
            let dist = dist.clone();
            ({
                let f = ((aivi_ok(dist.clone())).and_then(|b| match b { Value::Record(map) => map.get("pdf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(x.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|l| (aivi_ok(x.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_signal_map__0b89023692834fb0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
            let f = f.clone();
            (aivi_ok(items.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                            let f = (aivi_ok(f.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?]); out.extend({ let v = ({
                            let f = (aivi_ok(__builtin("map")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(f.clone()))?);
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_signal_zipWith__887e58de09639089(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
            let f = f.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
                let f = f.clone();
                let left = left.clone();
                (aivi_ok(Value::Tuple(vec![(aivi_ok(left.clone()))?, (aivi_ok(right.clone()))?]))).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(match v0 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }) { return false; }
                                let v1 = &items[1];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(true) { return false; }
                                let v1 = &items[1];
                                if !(match v1 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !(match v0 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("xs", (&tail).clone()); true }
                                }, _ => false }) { return false; }
                                let v1 = &items[1];
                                if !(match v1 { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("y", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("ys", (&tail).clone()); true }
                                }, _ => false }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_2(&__scrut, &mut __b) {
                            let x = __b.remove("x").expect("pattern binder");
                            let xs = __b.remove("xs").expect("pattern binder");
                            let y = __b.remove("y").expect("pattern binder");
                            let ys = __b.remove("ys").expect("pattern binder");
                            return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                let f = (aivi_ok(f.clone()))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                __aivi_call_args.push((aivi_ok(y.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?]); out.extend({ let v = ({
                                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(f.clone()))?);
                                __aivi_call_args.push((aivi_ok(xs.clone()))?);
                                __aivi_call_args.push((aivi_ok(ys.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_signal_add__e7ff58367e21cce5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            (aivi_ok(a.clone())).and_then(|l| (aivi_ok(b.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
        }) })))
    }) })))
}

fn def_aivi_signal______50a2fa37dbdd719e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("samples".to_string(), ({
                let f = (def_zipWith__bc0e3a3a8976736c(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_add__e70bc3190530e654(rt))?);
                __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("samples").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("samples").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("rate".to_string(), ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("rate").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_signal______509f9637dbda91db(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let s = s.clone();
            {
                let mut map = HashMap::new();
                map.insert("samples".to_string(), ({
                let f = (aivi_ok(__builtin("map")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
                    let k = k.clone();
                    (aivi_ok(_arg0.clone())).and_then(|l| (aivi_ok(k.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
                }) }))))?);
                __aivi_call_args.push(((aivi_ok(s.clone())).and_then(|b| match b { Value::Record(map) => map.get("samples").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("rate".to_string(), ((aivi_ok(s.clone())).and_then(|b| match b { Value::Record(map) => map.get("rate").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_fft__dcd18c18fef4ad1b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sig: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("signal"))).and_then(|b| match b { Value::Record(map) => map.get("fft").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sig.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_signal_fft__ae0c47365e127602(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sig: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("signal"))).and_then(|b| match b { Value::Record(map) => map.get("fft").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sig.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_ifft__b08a65c55378a3dc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |spec: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("signal"))).and_then(|b| match b { Value::Record(map) => map.get("ifft").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(spec.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_signal_ifft__e9d437debda9d6b3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |spec: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("signal"))).and_then(|b| match b { Value::Record(map) => map.get("ifft").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(spec.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_windowHann__422c3f6eaf312306(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sig: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("signal"))).and_then(|b| match b { Value::Record(map) => map.get("windowHann").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sig.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_signal_windowHann__8d6ad0c585788ced(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sig: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("signal"))).and_then(|b| match b { Value::Record(map) => map.get("windowHann").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sig.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_signal_normalize__d7de4059d80301cd(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sig: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("signal"))).and_then(|b| match b { Value::Record(map) => map.get("normalize").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sig.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_geometry______28cd719c6f098452_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_geometry______28cd719c6f098452_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_geometry______28cd719c6f098452(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_geometry______28cd719c6f098452_clause_0(rt))?,
        (def_aivi_geometry______28cd719c6f098452_clause_1(rt))?,
    ]))
}

fn def_aivi_geometry______28c6659c6f035140_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_geometry______28c6659c6f035140_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_geometry______28c6659c6f035140(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_geometry______28c6659c6f035140_clause_0(rt))?,
        (def_aivi_geometry______28c6659c6f035140_clause_1(rt))?,
    ]))
}

fn def_aivi_geometry_distance__a0d39cd2cbca85a9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let __v = (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("dx", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let dx = __b0.remove("dx").expect("pattern binder");
                let __v = (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("dy", v.clone()); true }
                        }

                })(&__v, &mut __b1);
                if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let dy = __b1.remove("dy").expect("pattern binder");
                {
                    let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((((aivi_ok(dx.clone())).and_then(|l| (aivi_ok(dx.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| ((aivi_ok(dy.clone())).and_then(|l| (aivi_ok(dy.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    rt.call(f, __aivi_call_args)
                }
            }
        }) })))
    }) })))
}

fn def_midpoint__ecc67dc66550b951(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |seg: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("x".to_string(), (((((aivi_ok(seg.clone())).and_then(|b| match b { Value::Record(map) => map.get("start").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (((aivi_ok(seg.clone())).and_then(|b| match b { Value::Record(map) => map.get("end").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(Value::Float(2.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("y".to_string(), (((((aivi_ok(seg.clone())).and_then(|b| match b { Value::Record(map) => map.get("start").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (((aivi_ok(seg.clone())).and_then(|b| match b { Value::Record(map) => map.get("end").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(Value::Float(2.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_geometry_midpoint__6d7ed6dc89b267de(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |seg: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("x".to_string(), (((((aivi_ok(seg.clone())).and_then(|b| match b { Value::Record(map) => map.get("start").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (((aivi_ok(seg.clone())).and_then(|b| match b { Value::Record(map) => map.get("end").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(Value::Float(2.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            map.insert("y".to_string(), (((((aivi_ok(seg.clone())).and_then(|b| match b { Value::Record(map) => map.get("start").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (((aivi_ok(seg.clone())).and_then(|b| match b { Value::Record(map) => map.get("end").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (aivi_ok(Value::Float(2.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_areaLoop__654d168e4278337a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |first: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |prev: Value, rt: &mut Runtime| {
            let first = first.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |rest: Value, rt: &mut Runtime| {
                let first = first.clone();
                let prev = prev.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
                    let first = first.clone();
                    let prev = prev.clone();
                    let rest = rest.clone();
                    (aivi_ok(rest.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return (aivi_ok(acc.clone())).and_then(|l| ((((aivi_ok(prev.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(first.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(first.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(prev.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }));
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("p", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("ps", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let p = __b.remove("p").expect("pattern binder");
                                let ps = __b.remove("ps").expect("pattern binder");
                                return {
                                    let f = (def_areaLoop__654d168e4278337a(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(first.clone()))?);
                                    __aivi_call_args.push((aivi_ok(p.clone()))?);
                                    __aivi_call_args.push((aivi_ok(ps.clone()))?);
                                    __aivi_call_args.push(((aivi_ok(acc.clone())).and_then(|l| ((((aivi_ok(prev.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(prev.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_geometry_areaLoop__232ffcfced6135ad(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |first: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |prev: Value, rt: &mut Runtime| {
            let first = first.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |rest: Value, rt: &mut Runtime| {
                let first = first.clone();
                let prev = prev.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
                    let first = first.clone();
                    let prev = prev.clone();
                    let rest = rest.clone();
                    (aivi_ok(rest.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return (aivi_ok(acc.clone())).and_then(|l| ((((aivi_ok(prev.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(first.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(first.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(prev.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }));
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("p", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("ps", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let p = __b.remove("p").expect("pattern binder");
                                let ps = __b.remove("ps").expect("pattern binder");
                                return {
                                    let f = (def_areaLoop__654d168e4278337a(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(first.clone()))?);
                                    __aivi_call_args.push((aivi_ok(p.clone()))?);
                                    __aivi_call_args.push((aivi_ok(ps.clone()))?);
                                    __aivi_call_args.push(((aivi_ok(acc.clone())).and_then(|l| ((((aivi_ok(prev.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(prev.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_area__89502e843ec2b8c4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |poly: Value, rt: &mut Runtime| {
        ((aivi_ok(poly.clone())).and_then(|b| match b { Value::Record(map) => map.get("vertices").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::Float(0.0));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("first", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let first = __b.remove("first").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return ({
                        let f = (def_abs__e71fb2190541727b(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_areaLoop__654d168e4278337a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(first.clone()))?);
                            __aivi_call_args.push((aivi_ok(first.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::Float(0.0)))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|l| (aivi_ok(Value::Float(2.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_geometry_area__d092aeabc54b4a47(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |poly: Value, rt: &mut Runtime| {
        ((aivi_ok(poly.clone())).and_then(|b| match b { Value::Record(map) => map.get("vertices").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::Float(0.0));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("first", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let first = __b.remove("first").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return ({
                        let f = (def_abs__e71fb2190541727b(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_areaLoop__654d168e4278337a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(first.clone()))?);
                            __aivi_call_args.push((aivi_ok(first.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::Float(0.0)))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|l| (aivi_ok(Value::Float(2.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_graph_append__ef3b1128e9e0a4e2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(left.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(right.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            __aivi_call_args.push((aivi_ok(right.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_reverse__2012f552c9e2f128(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        {
            let f = (def_reverseHelp__37beb7365c1327da(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(xs.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_reverseHelp__37beb7365c1327da(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(acc.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (def_reverseHelp__37beb7365c1327da(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_reverseHelp__12a30339f16f839b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(acc.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (def_reverseHelp__37beb7365c1327da(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_length__a136255932c9b3e2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        (aivi_ok(xs.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::Int(0));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("_x", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let _x = __b.remove("_x").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return (aivi_ok(Value::Int(1))).and_then(|l| ({
                        let f = (def_length__ea11573f1af59eb5(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_uniqueNodeIds__3c42dccc48aa0d04(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
        {
            let f = (def_uniqueNodeIdsHelp__4346621ee026f987(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(items.clone()))?);
            __aivi_call_args.push(((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_graph_uniqueNodeIds__0f25e834176732ad(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
        {
            let f = (def_uniqueNodeIdsHelp__4346621ee026f987(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(items.clone()))?);
            __aivi_call_args.push(((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_uniqueNodeIdsHelp__4346621ee026f987(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |seen: Value, rt: &mut Runtime| {
            let items = items.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |accRev: Value, rt: &mut Runtime| {
                let items = items.clone();
                let seen = seen.clone();
                (aivi_ok(items.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("x", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let rest = __b.remove("rest").expect("pattern binder");
                            let x = __b.remove("x").expect("pattern binder");
                            return ({
                                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                __aivi_call_args.push((aivi_ok(seen.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }).and_then(|c| match c { Value::Bool(true) => {
                                let f = (def_uniqueNodeIdsHelp__4346621ee026f987(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push((aivi_ok(seen.clone()))?);
                                __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }, Value::Bool(false) => {
                                let f = (def_uniqueNodeIdsHelp__4346621ee026f987(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(x.clone()))?);
                                    __aivi_call_args.push((aivi_ok(seen.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                rt.call(f, __aivi_call_args)
                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_uniqueNodeIdsHelp__115ade5140356042(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |seen: Value, rt: &mut Runtime| {
            let items = items.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |accRev: Value, rt: &mut Runtime| {
                let items = items.clone();
                let seen = seen.clone();
                (aivi_ok(items.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("x", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let rest = __b.remove("rest").expect("pattern binder");
                            let x = __b.remove("x").expect("pattern binder");
                            return ({
                                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(x.clone()))?);
                                __aivi_call_args.push((aivi_ok(seen.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }).and_then(|c| match c { Value::Bool(true) => {
                                let f = (def_uniqueNodeIdsHelp__4346621ee026f987(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push((aivi_ok(seen.clone()))?);
                                __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }, Value::Bool(false) => {
                                let f = (def_uniqueNodeIdsHelp__4346621ee026f987(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(x.clone()))?);
                                    __aivi_call_args.push((aivi_ok(seen.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                rt.call(f, __aivi_call_args)
                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph______ecc5cea357e9707e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ({
                let f = (def_uniqueNodeIds__3c42dccc48aa0d04(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_append__3e7fe942f71f1e61(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("edges".to_string(), ({
                let f = (def_append__3e7fe942f71f1e61(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_graph_empty__858aa3074c4919bb(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("nodes".to_string(), (aivi_ok(Value::List(Arc::new(Vec::new()))))?);
        map.insert("edges".to_string(), (aivi_ok(Value::List(Arc::new(Vec::new()))))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_addNode__cfbcde38953e4b50(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            ({
                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("fromList").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }).and_then(|c| match c { Value::Bool(true) => aivi_ok(g.clone()), Value::Bool(false) => {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ({
                let f = (def_append__3e7fe942f71f1e61(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(node.clone()))?]))))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("edges".to_string(), ((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) })))
    }) })))
}

fn def_aivi_graph_addNode__1acab98b92e30ded(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            ({
                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("fromList").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }).and_then(|c| match c { Value::Bool(true) => aivi_ok(g.clone()), Value::Bool(false) => {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ({
                let f = (def_append__3e7fe942f71f1e61(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(node.clone()))?]))))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("edges".to_string(), ((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) })))
    }) })))
}

fn def_addEdge__6e57f4eb6cadc519(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = ((aivi_ok(__builtin("graph"))).and_then(|b| match b { Value::Record(map) => map.get("addEdge").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                __aivi_call_args.push((aivi_ok(edge.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_addEdge__15aac230eaeba2bc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = ((aivi_ok(__builtin("graph"))).and_then(|b| match b { Value::Record(map) => map.get("addEdge").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                __aivi_call_args.push((aivi_ok(edge.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_fromEdgesHelp__6e0761296956d582(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pairs: Value, rt: &mut Runtime| {
            let g = g.clone();
            (aivi_ok(pairs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(g.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !(match v0 { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !({ b.insert("from", v0.clone()); true }) { return false; }
                                let v1 = &items[1];
                                if !({ b.insert("to", v1.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let from = __b.remove("from").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        let to = __b.remove("to").expect("pattern binder");
                        return {
                            let f = (def_fromEdgesHelp__6e0761296956d582(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (def_addEdge__6e57f4eb6cadc519(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(g.clone()))?);
                                __aivi_call_args.push(({
                                    let mut map = HashMap::new();
                                    map.insert("from".to_string(), (aivi_ok(from.clone()))?);
                                    map.insert("to".to_string(), (aivi_ok(to.clone()))?);
                                    map.insert("weight".to_string(), (aivi_ok(Value::Float(1.0)))?);
                                    aivi_ok(Value::Record(Arc::new(map)))
                                })?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_fromEdgesHelp__aee370344921355b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pairs: Value, rt: &mut Runtime| {
            let g = g.clone();
            (aivi_ok(pairs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(g.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !(match v0 { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !({ b.insert("from", v0.clone()); true }) { return false; }
                                let v1 = &items[1];
                                if !({ b.insert("to", v1.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let from = __b.remove("from").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        let to = __b.remove("to").expect("pattern binder");
                        return {
                            let f = (def_fromEdgesHelp__6e0761296956d582(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (def_addEdge__6e57f4eb6cadc519(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(g.clone()))?);
                                __aivi_call_args.push(({
                                    let mut map = HashMap::new();
                                    map.insert("from".to_string(), (aivi_ok(from.clone()))?);
                                    map.insert("to".to_string(), (aivi_ok(to.clone()))?);
                                    map.insert("weight".to_string(), (aivi_ok(Value::Float(1.0)))?);
                                    aivi_ok(Value::Record(Arc::new(map)))
                                })?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_fromEdges__10d413d7b0f123ed(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pairs: Value, rt: &mut Runtime| {
        {
            let f = (def_fromEdgesHelp__6e0761296956d582(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((def_empty__904fefb3d01cb2ae(rt))?);
            __aivi_call_args.push((aivi_ok(pairs.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_graph_fromEdges__08ab42e4af3eb2e8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pairs: Value, rt: &mut Runtime| {
        {
            let f = (def_fromEdgesHelp__6e0761296956d582(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((def_empty__904fefb3d01cb2ae(rt))?);
            __aivi_call_args.push((aivi_ok(pairs.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_fromWeightedEdgesHelp__5844e68e8b1effd5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |triples: Value, rt: &mut Runtime| {
            let g = g.clone();
            (aivi_ok(triples.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(g.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !(match v0 { Value::Tuple(items) if items.len() == 3 => {
                                let v0 = &items[0];
                                if !({ b.insert("from", v0.clone()); true }) { return false; }
                                let v1 = &items[1];
                                if !({ b.insert("to", v1.clone()); true }) { return false; }
                                let v2 = &items[2];
                                if !({ b.insert("w", v2.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let from = __b.remove("from").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        let to = __b.remove("to").expect("pattern binder");
                        let w = __b.remove("w").expect("pattern binder");
                        return {
                            let f = (def_fromWeightedEdgesHelp__5844e68e8b1effd5(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (def_addEdge__6e57f4eb6cadc519(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(g.clone()))?);
                                __aivi_call_args.push(({
                                    let mut map = HashMap::new();
                                    map.insert("from".to_string(), (aivi_ok(from.clone()))?);
                                    map.insert("to".to_string(), (aivi_ok(to.clone()))?);
                                    map.insert("weight".to_string(), (aivi_ok(w.clone()))?);
                                    aivi_ok(Value::Record(Arc::new(map)))
                                })?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_fromWeightedEdgesHelp__b3e2dcc3b3bd524c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |triples: Value, rt: &mut Runtime| {
            let g = g.clone();
            (aivi_ok(triples.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(g.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !(match v0 { Value::Tuple(items) if items.len() == 3 => {
                                let v0 = &items[0];
                                if !({ b.insert("from", v0.clone()); true }) { return false; }
                                let v1 = &items[1];
                                if !({ b.insert("to", v1.clone()); true }) { return false; }
                                let v2 = &items[2];
                                if !({ b.insert("w", v2.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let from = __b.remove("from").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        let to = __b.remove("to").expect("pattern binder");
                        let w = __b.remove("w").expect("pattern binder");
                        return {
                            let f = (def_fromWeightedEdgesHelp__5844e68e8b1effd5(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (def_addEdge__6e57f4eb6cadc519(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(g.clone()))?);
                                __aivi_call_args.push(({
                                    let mut map = HashMap::new();
                                    map.insert("from".to_string(), (aivi_ok(from.clone()))?);
                                    map.insert("to".to_string(), (aivi_ok(to.clone()))?);
                                    map.insert("weight".to_string(), (aivi_ok(w.clone()))?);
                                    aivi_ok(Value::Record(Arc::new(map)))
                                })?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_fromWeightedEdges__89e909fb763b68f2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |triples: Value, rt: &mut Runtime| {
        {
            let f = (def_fromWeightedEdgesHelp__5844e68e8b1effd5(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((def_empty__904fefb3d01cb2ae(rt))?);
            __aivi_call_args.push((aivi_ok(triples.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_graph_fromWeightedEdges__69c78a77f772d85f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |triples: Value, rt: &mut Runtime| {
        {
            let f = (def_fromWeightedEdgesHelp__5844e68e8b1effd5(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((def_empty__904fefb3d01cb2ae(rt))?);
            __aivi_call_args.push((aivi_ok(triples.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_edgeEq__f185f8b434e640de(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), Value::Bool(false) => aivi_ok(Value::Bool(false)), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("weight").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("weight").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), Value::Bool(false) => aivi_ok(Value::Bool(false)), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) })))
    }) })))
}

fn def_aivi_graph_edgeEq__9d1b2c4d30bafc1d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), Value::Bool(false) => aivi_ok(Value::Bool(false)), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => ((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("weight").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("weight").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), Value::Bool(false) => aivi_ok(Value::Bool(false)), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) })))
    }) })))
}

fn def_removeEdgeHelp__94c6dc6650b5b317(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let edge = edge.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ({
                            let f = (def_edgeEq__f185f8b434e640de(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_removeEdgeHelp__94c6dc6650b5b317(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = ({
                            let f = (def_removeEdgeHelp__94c6dc6650b5b317(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_removeEdgeHelp__9d375f4883103168(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let edge = edge.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ({
                            let f = (def_edgeEq__f185f8b434e640de(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_removeEdgeHelp__94c6dc6650b5b317(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = ({
                            let f = (def_removeEdgeHelp__94c6dc6650b5b317(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_removeEdge__94e91e3d6efa7574(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("edges".to_string(), ({
                let f = (def_removeEdgeHelp__94c6dc6650b5b317(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(edge.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_graph_removeEdge__9d51aa6df14797cb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("edges".to_string(), ({
                let f = (def_removeEdgeHelp__94c6dc6650b5b317(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(edge.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_removeNodeHelp__772129ae291c665a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(nodes.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ((aivi_ok(n.clone())).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_removeNodeHelp__772129ae291c665a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(n.clone()))?]); out.extend({ let v = ({
                            let f = (def_removeNodeHelp__772129ae291c665a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_removeNodeHelp__98526d87d7b37411(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(nodes.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ((aivi_ok(n.clone())).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_removeNodeHelp__772129ae291c665a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(n.clone()))?]); out.extend({ let v = ({
                            let f = (def_removeNodeHelp__772129ae291c665a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_removeNodeEdgesHelp__47d9e90df2ff6bd2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ((((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Bool(true)), Value::Bool(false) => ((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_removeNodeEdgesHelp__47d9e90df2ff6bd2(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = ({
                            let f = (def_removeNodeEdgesHelp__47d9e90df2ff6bd2(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_removeNodeEdgesHelp__68ff4a79ab78017f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ((((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Bool(true)), Value::Bool(false) => ((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_removeNodeEdgesHelp__47d9e90df2ff6bd2(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = ({
                            let f = (def_removeNodeEdgesHelp__47d9e90df2ff6bd2(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_removeNode__36bf25139c3241e5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ({
                let f = (def_removeNodeHelp__772129ae291c665a(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("edges".to_string(), ({
                let f = (def_removeNodeEdgesHelp__47d9e90df2ff6bd2(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_graph_removeNode__1c8a3f97d656244e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ({
                let f = (def_removeNodeHelp__772129ae291c665a(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("edges".to_string(), ({
                let f = (def_removeNodeEdgesHelp__47d9e90df2ff6bd2(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_edgeEndpoints__4c418dd92e5e9bba(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
        (aivi_ok(edges.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(Vec::new())));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("e", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let e = __b.remove("e").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?]); out.extend(vec![((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?]); out.extend({ let v = ({
                        let f = (def_edgeEndpoints__4c418dd92e5e9bba(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_graph_edgeEndpoints__ccc45615186282b3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
        (aivi_ok(edges.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(Vec::new())));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("e", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let e = __b.remove("e").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?]); out.extend(vec![((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?]); out.extend({ let v = ({
                        let f = (def_edgeEndpoints__4c418dd92e5e9bba(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_graph_normalize__778c21c9358d9e2d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_edgeEndpoints__4c418dd92e5e9bba(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("endpoints", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let endpoints = __b0.remove("endpoints").expect("pattern binder");
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ({
                let f = (def_uniqueNodeIds__3c42dccc48aa0d04(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_append__3e7fe942f71f1e61(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    __aivi_call_args.push((aivi_ok(endpoints.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("edges".to_string(), ((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }
    }) })))
}

fn def_isValidEdges__8007343ec129d291(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let nodes = nodes.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::Bool(true));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (({
                            let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            __aivi_call_args.push((aivi_ok(nodes.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => {
                            let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            __aivi_call_args.push((aivi_ok(nodes.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::Bool(false)), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_isValidEdges__8007343ec129d291(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(nodes.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::Bool(false)), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_isValidEdges__50825715bda1bd66(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let nodes = nodes.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::Bool(true));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (({
                            let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            __aivi_call_args.push((aivi_ok(nodes.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => {
                            let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            __aivi_call_args.push((aivi_ok(nodes.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::Bool(false)), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_isValidEdges__8007343ec129d291(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(nodes.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => aivi_ok(Value::Bool(false)), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_isValid__645a3bc684679a41(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let f = (def_isValidEdges__8007343ec129d291(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("fromList").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
            __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_graph_isValid__9a4b55e3133ff42c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let f = (def_isValidEdges__8007343ec129d291(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("fromList").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
            __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_edgeIn__f178e3b434db92d3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let edge = edge.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::Bool(false));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ({
                            let f = (def_edgeEq__f185f8b434e640de(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Bool(true)), Value::Bool(false) => {
                            let f = (def_edgeIn__f178e3b434db92d3(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_edgeIn__9d0d2d4d30aec074(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let edge = edge.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::Bool(false));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ({
                            let f = (def_edgeEq__f185f8b434e640de(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Bool(true)), Value::Bool(false) => {
                            let f = (def_edgeIn__f178e3b434db92d3(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(edge.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_dedupEdgesHelp__fea9fc868dd35e98(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |seenRev: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let seenRev = seenRev.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(seenRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ({
                            let f = (def_edgeIn__f178e3b434db92d3(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            __aivi_call_args.push((aivi_ok(seenRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_dedupEdgesHelp__fea9fc868dd35e98(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(seenRev.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => {
                            let f = (def_dedupEdgesHelp__fea9fc868dd35e98(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = (aivi_ok(seenRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_dedupEdgesHelp__63789790d4ab546b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |seenRev: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let seenRev = seenRev.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(seenRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return ({
                            let f = (def_edgeIn__f178e3b434db92d3(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                            __aivi_call_args.push((aivi_ok(seenRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => {
                            let f = (def_dedupEdgesHelp__fea9fc868dd35e98(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(seenRev.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => {
                            let f = (def_dedupEdgesHelp__fea9fc868dd35e98(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = (aivi_ok(seenRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_dedupEdges__20b83436be9ad05b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("nodes".to_string(), ((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("edges".to_string(), ({
            let f = (def_dedupEdgesHelp__fea9fc868dd35e98(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        })?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_graph_dedupEdges__43bd76f74fbb6a58(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("nodes".to_string(), ((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("edges".to_string(), ({
            let f = (def_dedupEdgesHelp__fea9fc868dd35e98(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        })?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_neighbors__1f3122b5a30fcee8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = ((aivi_ok(__builtin("graph"))).and_then(|b| match b { Value::Record(map) => map.get("neighbors").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_neighbors__0610df167b1c8add(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = ((aivi_ok(__builtin("graph"))).and_then(|b| match b { Value::Record(map) => map.get("neighbors").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_inNeighborsHelp__6faa8eac9774b24a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?]); out.extend({ let v = ({
                            let f = (def_inNeighborsHelp__6faa8eac9774b24a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => {
                            let f = (def_inNeighborsHelp__6faa8eac9774b24a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_inNeighborsHelp__415c691f6ac5c5a7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?]); out.extend({ let v = ({
                            let f = (def_inNeighborsHelp__6faa8eac9774b24a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => {
                            let f = (def_inNeighborsHelp__6faa8eac9774b24a(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_inNeighbors__7b91f08c4cd6da35(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_inNeighborsHelp__6faa8eac9774b24a(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_inNeighbors__f03db1868bfc3464(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_inNeighborsHelp__6faa8eac9774b24a(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_edgesFromHelp__318226d62fa15d42(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = ({
                            let f = (def_edgesFromHelp__318226d62fa15d42(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => {
                            let f = (def_edgesFromHelp__318226d62fa15d42(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_edgesFromHelp__170c4166efbfd35f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = ({
                            let f = (def_edgesFromHelp__318226d62fa15d42(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => {
                            let f = (def_edgesFromHelp__318226d62fa15d42(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_edgesFrom__b32ebb1d3d85dfad(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_edgesFromHelp__318226d62fa15d42(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_edgesFrom__5789cb7827841b9c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_edgesFromHelp__318226d62fa15d42(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_edgesToHelp__cd796b11214333af(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = ({
                            let f = (def_edgesToHelp__cd796b11214333af(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => {
                            let f = (def_edgesToHelp__cd796b11214333af(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_edgesToHelp__fd550e70a4add052(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let node = node.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|a| (aivi_ok(node.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(e.clone()))?]); out.extend({ let v = ({
                            let f = (def_edgesToHelp__cd796b11214333af(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => {
                            let f = (def_edgesToHelp__cd796b11214333af(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_edgesTo__e0a1713514cb8d0c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_edgesToHelp__cd796b11214333af(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_edgesTo__34b35b29872ecb1d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_edgesToHelp__cd796b11214333af(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push(((aivi_ok(g.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_degreeOut__8b22a04d365aa263(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_length__ea11573f1af59eb5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_edgesFrom__b32ebb1d3d85dfad(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    __aivi_call_args.push((aivi_ok(node.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_degreeOut__e2dbc1589065787a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_length__ea11573f1af59eb5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_edgesFrom__b32ebb1d3d85dfad(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    __aivi_call_args.push((aivi_ok(node.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_degreeIn__6ec43a7a9620e92a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_length__ea11573f1af59eb5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_edgesTo__e0a1713514cb8d0c(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    __aivi_call_args.push((aivi_ok(node.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_degreeIn__c8a088eb9b2c6379(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_length__ea11573f1af59eb5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_edgesTo__e0a1713514cb8d0c(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    __aivi_call_args.push((aivi_ok(node.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_mapPushFront__d32f3746406475dc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
            let key = key.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
                let edge = edge.clone();
                let key = key.clone();
                ({
                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(key.clone()))?);
                    __aivi_call_args.push((aivi_ok(m.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(key.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(edge.clone()))?]))))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("xs", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let xs = __b.remove("xs").expect("pattern binder");
                            return {
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(key.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(edge.clone()))?]); out.extend({ let v = (aivi_ok(xs.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_mapPushFront__7f7e888b4e9b7b73(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
            let key = key.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
                let edge = edge.clone();
                let key = key.clone();
                ({
                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(key.clone()))?);
                    __aivi_call_args.push((aivi_ok(m.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(key.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(edge.clone()))?]))))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("xs", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let xs = __b.remove("xs").expect("pattern binder");
                            return {
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(key.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(edge.clone()))?]); out.extend({ let v = (aivi_ok(xs.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_indexEdges__7ab967ddbe9eab3f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(idx.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return {
                            let f = (def_indexEdges__7ab967ddbe9eab3f(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let mut map = HashMap::new();
                                map.insert("nodes".to_string(), ((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                map.insert("out".to_string(), ({
                                let f = (def_mapPushFront__d32f3746406475dc(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                __aivi_call_args.push((aivi_ok(e.clone()))?);
                                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("out").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                                map.insert("incoming".to_string(), ({
                                let f = (def_mapPushFront__d32f3746406475dc(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                __aivi_call_args.push((aivi_ok(e.clone()))?);
                                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("incoming").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                                aivi_ok(Value::Record(Arc::new(map)))
                            })?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_indexEdges__c587aa9e4de70e40(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            (aivi_ok(edges.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(idx.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("e", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let e = __b.remove("e").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return {
                            let f = (def_indexEdges__7ab967ddbe9eab3f(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let mut map = HashMap::new();
                                map.insert("nodes".to_string(), ((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                map.insert("out".to_string(), ({
                                let f = (def_mapPushFront__d32f3746406475dc(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("from").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                __aivi_call_args.push((aivi_ok(e.clone()))?);
                                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("out").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                                map.insert("incoming".to_string(), ({
                                let f = (def_mapPushFront__d32f3746406475dc(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                __aivi_call_args.push((aivi_ok(e.clone()))?);
                                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("incoming").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                                aivi_ok(Value::Record(Arc::new(map)))
                            })?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_index__83cf8e8f9081468b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_normalize__eabe8385437e66cc(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("g2", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let g2 = __b0.remove("g2").expect("pattern binder");
            let __v = ({
                let f = (def_indexEdges__7ab967ddbe9eab3f(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let mut map = HashMap::new();
                    map.insert("nodes".to_string(), ((aivi_ok(g2.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    map.insert("out".to_string(), ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    map.insert("incoming".to_string(), ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?);
                __aivi_call_args.push(((aivi_ok(g2.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("idxRev", v.clone()); true }
                    }

            })(&__v, &mut __b1);
            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let idxRev = __b1.remove("idxRev").expect("pattern binder");
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ((aivi_ok(g2.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("out".to_string(), ({
                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("map").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_reverse__c95b3c1f3263ab65(rt))?);
                __aivi_call_args.push(((aivi_ok(idxRev.clone())).and_then(|b| match b { Value::Record(map) => map.get("out").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("incoming".to_string(), ({
                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("map").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_reverse__c95b3c1f3263ab65(rt))?);
                __aivi_call_args.push(((aivi_ok(idxRev.clone())).and_then(|b| match b { Value::Record(map) => map.get("incoming").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }
    }) })))
}

fn def_aivi_graph_index__16a75b9e45c7207a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_normalize__eabe8385437e66cc(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("g2", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let g2 = __b0.remove("g2").expect("pattern binder");
            let __v = ({
                let f = (def_indexEdges__7ab967ddbe9eab3f(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let mut map = HashMap::new();
                    map.insert("nodes".to_string(), ((aivi_ok(g2.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    map.insert("out".to_string(), ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    map.insert("incoming".to_string(), ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?);
                __aivi_call_args.push(((aivi_ok(g2.clone())).and_then(|b| match b { Value::Record(map) => map.get("edges").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("idxRev", v.clone()); true }
                    }

            })(&__v, &mut __b1);
            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let idxRev = __b1.remove("idxRev").expect("pattern binder");
            {
                let mut map = HashMap::new();
                map.insert("nodes".to_string(), ((aivi_ok(g2.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("out".to_string(), ({
                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("map").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_reverse__c95b3c1f3263ab65(rt))?);
                __aivi_call_args.push(((aivi_ok(idxRev.clone())).and_then(|b| match b { Value::Record(map) => map.get("out").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                map.insert("incoming".to_string(), ({
                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("map").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((def_reverse__c95b3c1f3263ab65(rt))?);
                __aivi_call_args.push(((aivi_ok(idxRev.clone())).and_then(|b| match b { Value::Record(map) => map.get("incoming").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }
    }) })))
}

fn def_edgesFromI__fe47d6af8a7b706c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            {
                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("out").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_edgesFromI__4340922b257b4aef(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            {
                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("out").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_edgeTos__b9027e358f4e41d2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
        (aivi_ok(edges.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(Vec::new())));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("e", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let e = __b.remove("e").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?]); out.extend({ let v = ({
                        let f = (def_edgeTos__b9027e358f4e41d2(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_graph_edgeTos__43c8662a21729d7b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
        (aivi_ok(edges.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(Vec::new())));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("e", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let e = __b.remove("e").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?]); out.extend({ let v = ({
                        let f = (def_edgeTos__b9027e358f4e41d2(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_neighborsI__104c9ba413dc1b93(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            {
                let f = (def_edgeTos__b9027e358f4e41d2(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_edgesFromI__fe47d6af8a7b706c(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(idx.clone()))?);
                    __aivi_call_args.push((aivi_ok(node.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_neighborsI__6b35a733317f797c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            {
                let f = (def_edgeTos__b9027e358f4e41d2(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_edgesFromI__fe47d6af8a7b706c(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(idx.clone()))?);
                    __aivi_call_args.push((aivi_ok(node.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_reconstructHelp__d25389cd01a7023a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |current: Value, rt: &mut Runtime| {
            let start = start.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parents: Value, rt: &mut Runtime| {
                let current = current.clone();
                let start = start.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |accRev: Value, rt: &mut Runtime| {
                    let current = current.clone();
                    let parents = parents.clone();
                    let start = start.clone();
                    ((aivi_ok(current.clone())).and_then(|a| (aivi_ok(start.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(start.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => ({
                        let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(current.clone()))?);
                        __aivi_call_args.push((aivi_ok(parents.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(Value::List(Arc::new(Vec::new())));
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                    let v0 = &args[0];
                                    if !({ b.insert("p", v0.clone()); true }) { return false; }
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let p = __b.remove("p").expect("pattern binder");
                                return {
                                    let f = (def_reconstructHelp__d25389cd01a7023a(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                                    __aivi_call_args.push((aivi_ok(p.clone()))?);
                                    __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(current.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_reconstructHelp__492030e83d3e4647(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |current: Value, rt: &mut Runtime| {
            let start = start.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parents: Value, rt: &mut Runtime| {
                let current = current.clone();
                let start = start.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |accRev: Value, rt: &mut Runtime| {
                    let current = current.clone();
                    let parents = parents.clone();
                    let start = start.clone();
                    ((aivi_ok(current.clone())).and_then(|a| (aivi_ok(start.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(start.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => ({
                        let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(current.clone()))?);
                        __aivi_call_args.push((aivi_ok(parents.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(Value::List(Arc::new(Vec::new())));
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                    let v0 = &args[0];
                                    if !({ b.insert("p", v0.clone()); true }) { return false; }
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let p = __b.remove("p").expect("pattern binder");
                                return {
                                    let f = (def_reconstructHelp__d25389cd01a7023a(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                                    __aivi_call_args.push((aivi_ok(p.clone()))?);
                                    __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(current.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_pathFromParents__993b1dbfceb9ecdb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
            let start = start.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parents: Value, rt: &mut Runtime| {
                let goal = goal.clone();
                let start = start.clone();
                ({
                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                    __aivi_call_args.push((aivi_ok(parents.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return {
                                let f = (def_reconstructHelp__d25389cd01a7023a(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(start.clone()))?);
                                __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_pathFromParents__e86b0b75b3e599f2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
            let start = start.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parents: Value, rt: &mut Runtime| {
                let goal = goal.clone();
                let start = start.clone();
                ({
                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                    __aivi_call_args.push((aivi_ok(parents.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(Value::List(Arc::new(Vec::new())));
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return {
                                let f = (def_reconstructHelp__d25389cd01a7023a(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(start.clone()))?);
                                __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_bfsVisitNeighbors__9e60cc0f899fa6d0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parent: Value, rt: &mut Runtime| {
                let goal = goal.clone();
                let idx = idx.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ns: Value, rt: &mut Runtime| {
                    let goal = goal.clone();
                    let idx = idx.clone();
                    let parent = parent.clone();
                    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                        let goal = goal.clone();
                        let idx = idx.clone();
                        let ns = ns.clone();
                        let parent = parent.clone();
                        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |visited: Value, rt: &mut Runtime| {
                            let goal = goal.clone();
                            let idx = idx.clone();
                            let ns = ns.clone();
                            let parent = parent.clone();
                            let q = q.clone();
                            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parents: Value, rt: &mut Runtime| {
                                let goal = goal.clone();
                                let idx = idx.clone();
                                let ns = ns.clone();
                                let parent = parent.clone();
                                let q = q.clone();
                                let visited = visited.clone();
                                (aivi_ok(ns.clone())).and_then(|__scrut| {
                                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::List(items) => {
                                                let items = items.as_ref();
                                                if items.len() < 0 { return false; }
                                                items.len() == 0
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_0(&__scrut, &mut __b) {
                                            return {
                                                let f = (def_bfsLoop__0e51d026c42f2084(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                                __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                                __aivi_call_args.push((aivi_ok(q.clone()))?);
                                                __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            };
                                        }
                                    }

                                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::List(items) => {
                                                let items = items.as_ref();
                                                if items.len() < 1 { return false; }
                                                let v0 = &items[0];
                                                if !({ b.insert("n", v0.clone()); true }) { return false; }
                                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                                { b.insert("rest", (&tail).clone()); true }
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_1(&__scrut, &mut __b) {
                                            let n = __b.remove("n").expect("pattern binder");
                                            let rest = __b.remove("rest").expect("pattern binder");
                                            return ({
                                                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(n.clone()))?);
                                                __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            }).and_then(|c| match c { Value::Bool(true) => {
                                                let f = (def_bfsVisitNeighbors__9e60cc0f899fa6d0(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                                __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parent.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push((aivi_ok(q.clone()))?);
                                                __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            }, Value::Bool(false) => {
                                                let f = (def_bfsVisitNeighbors__9e60cc0f899fa6d0(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                                __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parent.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push(({
                                                    let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(q.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                })?);
                                                __aivi_call_args.push(({
                                                    let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                })?);
                                                __aivi_call_args.push(({
                                                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(parent.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                })?);
                                                rt.call(f, __aivi_call_args)
                                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                        }
                                    }

                                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                })
                            }) })))
                        }) })))
                    }) })))
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_bfsVisitNeighbors__88835815da4968d9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parent: Value, rt: &mut Runtime| {
                let goal = goal.clone();
                let idx = idx.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ns: Value, rt: &mut Runtime| {
                    let goal = goal.clone();
                    let idx = idx.clone();
                    let parent = parent.clone();
                    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                        let goal = goal.clone();
                        let idx = idx.clone();
                        let ns = ns.clone();
                        let parent = parent.clone();
                        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |visited: Value, rt: &mut Runtime| {
                            let goal = goal.clone();
                            let idx = idx.clone();
                            let ns = ns.clone();
                            let parent = parent.clone();
                            let q = q.clone();
                            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parents: Value, rt: &mut Runtime| {
                                let goal = goal.clone();
                                let idx = idx.clone();
                                let ns = ns.clone();
                                let parent = parent.clone();
                                let q = q.clone();
                                let visited = visited.clone();
                                (aivi_ok(ns.clone())).and_then(|__scrut| {
                                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::List(items) => {
                                                let items = items.as_ref();
                                                if items.len() < 0 { return false; }
                                                items.len() == 0
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_0(&__scrut, &mut __b) {
                                            return {
                                                let f = (def_bfsLoop__0e51d026c42f2084(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                                __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                                __aivi_call_args.push((aivi_ok(q.clone()))?);
                                                __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            };
                                        }
                                    }

                                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::List(items) => {
                                                let items = items.as_ref();
                                                if items.len() < 1 { return false; }
                                                let v0 = &items[0];
                                                if !({ b.insert("n", v0.clone()); true }) { return false; }
                                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                                { b.insert("rest", (&tail).clone()); true }
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_1(&__scrut, &mut __b) {
                                            let n = __b.remove("n").expect("pattern binder");
                                            let rest = __b.remove("rest").expect("pattern binder");
                                            return ({
                                                let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(n.clone()))?);
                                                __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            }).and_then(|c| match c { Value::Bool(true) => {
                                                let f = (def_bfsVisitNeighbors__9e60cc0f899fa6d0(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                                __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parent.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push((aivi_ok(q.clone()))?);
                                                __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            }, Value::Bool(false) => {
                                                let f = (def_bfsVisitNeighbors__9e60cc0f899fa6d0(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                                __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parent.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push(({
                                                    let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(q.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                })?);
                                                __aivi_call_args.push(({
                                                    let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                })?);
                                                __aivi_call_args.push(({
                                                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(parent.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                })?);
                                                rt.call(f, __aivi_call_args)
                                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                        }
                                    }

                                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                })
                            }) })))
                        }) })))
                    }) })))
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_bfsLoop__0e51d026c42f2084_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                let goal = goal.clone();
                let idx = idx.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |visited: Value, rt: &mut Runtime| {
                    let goal = goal.clone();
                    let idx = idx.clone();
                    let q = q.clone();
                    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parents: Value, rt: &mut Runtime| {
                        let goal = goal.clone();
                        let idx = idx.clone();
                        let q = q.clone();
                        let visited = visited.clone();
                        ({
                            let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("dequeue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(q.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|__scrut| {
                            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_0(&__scrut, &mut __b) {
                                    return aivi_ok(__builtin("None"));
                                }
                            }

                            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !(match v0 { Value::Tuple(items) if items.len() == 2 => {
                                            let v0 = &items[0];
                                            if !({ b.insert("node", v0.clone()); true }) { return false; }
                                            let v1 = &items[1];
                                            if !({ b.insert("q2", v1.clone()); true }) { return false; }
                                            true
                                        }, _ => false }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_1(&__scrut, &mut __b) {
                                    let node = __b.remove("node").expect("pattern binder");
                                    let q2 = __b.remove("q2").expect("pattern binder");
                                    return ((aivi_ok(node.clone())).and_then(|a| (aivi_ok(goal.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                        let f = (aivi_ok(__builtin("Some")))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    }, Value::Bool(false) => {
                                        let f = (def_bfsVisitNeighbors__9e60cc0f899fa6d0(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                        __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                        __aivi_call_args.push((aivi_ok(node.clone()))?);
                                        __aivi_call_args.push(({
                                            let f = (def_neighborsI__104c9ba413dc1b93(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        __aivi_call_args.push((aivi_ok(q2.clone()))?);
                                        __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                        __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                }
                            }

                            Err(RuntimeError::Message("non-exhaustive match".to_string()))
                        })
                    }) })))
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_bfsLoop__0e51d026c42f2084_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
            let q = q.clone();
            ({
                let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("dequeue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(q.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !(match v0 { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !({ b.insert("t", v0.clone()); true }) { return false; }
                                let v1 = &items[1];
                                if !({ b.insert("q2", v1.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let q2 = __b.remove("q2").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let __v = ({
                                let f = (def_bfsEnqueueChildren__7a2e32d389d2171f(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = (def_childrenOf__79a234e067329433(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(t.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                __aivi_call_args.push((aivi_ok(q2.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("q3", v.clone()); true }
                                    }

                            })(&__v, &mut __b0);
                            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let q3 = __b0.remove("q3").expect("pattern binder");
                            {
                                let f = (def_bfsLoop__0e51d026c42f2084(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(q3.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                    let f = (def_valueOf__a3a7fde9b1aa14db(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(t.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                rt.call(f, __aivi_call_args)
                            }
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_bfsLoop__0e51d026c42f2084(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_bfsLoop__0e51d026c42f2084_clause_0(rt))?,
        (def_bfsLoop__0e51d026c42f2084_clause_1(rt))?,
    ]))
}

fn def_aivi_graph_bfsLoop__c94fb13157c56d2d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                let goal = goal.clone();
                let idx = idx.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |visited: Value, rt: &mut Runtime| {
                    let goal = goal.clone();
                    let idx = idx.clone();
                    let q = q.clone();
                    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parents: Value, rt: &mut Runtime| {
                        let goal = goal.clone();
                        let idx = idx.clone();
                        let q = q.clone();
                        let visited = visited.clone();
                        ({
                            let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("dequeue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(q.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|__scrut| {
                            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_0(&__scrut, &mut __b) {
                                    return aivi_ok(__builtin("None"));
                                }
                            }

                            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !(match v0 { Value::Tuple(items) if items.len() == 2 => {
                                            let v0 = &items[0];
                                            if !({ b.insert("node", v0.clone()); true }) { return false; }
                                            let v1 = &items[1];
                                            if !({ b.insert("q2", v1.clone()); true }) { return false; }
                                            true
                                        }, _ => false }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_1(&__scrut, &mut __b) {
                                    let node = __b.remove("node").expect("pattern binder");
                                    let q2 = __b.remove("q2").expect("pattern binder");
                                    return ((aivi_ok(node.clone())).and_then(|a| (aivi_ok(goal.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                        let f = (aivi_ok(__builtin("Some")))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    }, Value::Bool(false) => {
                                        let f = (def_bfsVisitNeighbors__9e60cc0f899fa6d0(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                        __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                        __aivi_call_args.push((aivi_ok(node.clone()))?);
                                        __aivi_call_args.push(({
                                            let f = (def_neighborsI__104c9ba413dc1b93(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        __aivi_call_args.push((aivi_ok(q2.clone()))?);
                                        __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                        __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                }
                            }

                            Err(RuntimeError::Message("non-exhaustive match".to_string()))
                        })
                    }) })))
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_bfsPathIndexed__9a1f8c45a26ad47a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
                let idx = idx.clone();
                let start = start.clone();
                {
                    let __v = ({
                        let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(start.clone()))?);
                        __aivi_call_args.push(((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("q0", v.clone()); true }
                            }

                    })(&__v, &mut __b0);
                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let q0 = __b0.remove("q0").expect("pattern binder");
                    let __v = ({
                        let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(start.clone()))?);
                        __aivi_call_args.push(((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("visited0", v.clone()); true }
                            }

                    })(&__v, &mut __b1);
                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let visited0 = __b1.remove("visited0").expect("pattern binder");
                    let __v = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                    let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("parents0", v.clone()); true }
                            }

                    })(&__v, &mut __b2);
                    if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let parents0 = __b2.remove("parents0").expect("pattern binder");
                    let __v = ({
                        let f = (def_bfsLoop__0e51d026c42f2084(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(idx.clone()))?);
                        __aivi_call_args.push((aivi_ok(goal.clone()))?);
                        __aivi_call_args.push((aivi_ok(q0.clone()))?);
                        __aivi_call_args.push((aivi_ok(visited0.clone()))?);
                        __aivi_call_args.push((aivi_ok(parents0.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b3: HashMap<&'static str, Value> = HashMap::new();
                    let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("res", v.clone()); true }
                            }

                    })(&__v, &mut __b3);
                    if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let res = __b3.remove("res").expect("pattern binder");
                    (aivi_ok(res.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(Value::List(Arc::new(Vec::new())));
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                    let v0 = &args[0];
                                    if !({ b.insert("parents", v0.clone()); true }) { return false; }
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let parents = __b.remove("parents").expect("pattern binder");
                                return {
                                    let f = (def_pathFromParents__993b1dbfceb9ecdb(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                    __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_bfsPathIndexed__52285aaea4ae271d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
                let idx = idx.clone();
                let start = start.clone();
                {
                    let __v = ({
                        let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(start.clone()))?);
                        __aivi_call_args.push(((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("q0", v.clone()); true }
                            }

                    })(&__v, &mut __b0);
                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let q0 = __b0.remove("q0").expect("pattern binder");
                    let __v = ({
                        let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(start.clone()))?);
                        __aivi_call_args.push(((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("visited0", v.clone()); true }
                            }

                    })(&__v, &mut __b1);
                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let visited0 = __b1.remove("visited0").expect("pattern binder");
                    let __v = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                    let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("parents0", v.clone()); true }
                            }

                    })(&__v, &mut __b2);
                    if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let parents0 = __b2.remove("parents0").expect("pattern binder");
                    let __v = ({
                        let f = (def_bfsLoop__0e51d026c42f2084(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(idx.clone()))?);
                        __aivi_call_args.push((aivi_ok(goal.clone()))?);
                        __aivi_call_args.push((aivi_ok(q0.clone()))?);
                        __aivi_call_args.push((aivi_ok(visited0.clone()))?);
                        __aivi_call_args.push((aivi_ok(parents0.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b3: HashMap<&'static str, Value> = HashMap::new();
                    let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("res", v.clone()); true }
                            }

                    })(&__v, &mut __b3);
                    if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let res = __b3.remove("res").expect("pattern binder");
                    (aivi_ok(res.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(Value::List(Arc::new(Vec::new())));
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                    let v0 = &args[0];
                                    if !({ b.insert("parents", v0.clone()); true }) { return false; }
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let parents = __b.remove("parents").expect("pattern binder");
                                return {
                                    let f = (def_pathFromParents__993b1dbfceb9ecdb(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                                    __aivi_call_args.push((aivi_ok(parents.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }
            }) })))
        }) })))
    }) })))
}

fn def_bfsPath__2845b402ed7a7935(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let g = g.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
                let g = g.clone();
                let start = start.clone();
                ((aivi_ok(start.clone())).and_then(|a| (aivi_ok(goal.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new(vec![(aivi_ok(start.clone()))?]))), Value::Bool(false) => {
                    let f = (def_bfsPathIndexed__9a1f8c45a26ad47a(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_index__83cf8e8f9081468b(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(g.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                    rt.call(f, __aivi_call_args)
                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_bfsPath__fad0b59658282cf0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let g = g.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
                let g = g.clone();
                let start = start.clone();
                ((aivi_ok(start.clone())).and_then(|a| (aivi_ok(goal.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new(vec![(aivi_ok(start.clone()))?]))), Value::Bool(false) => {
                    let f = (def_bfsPathIndexed__9a1f8c45a26ad47a(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_index__83cf8e8f9081468b(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(g.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                    rt.call(f, __aivi_call_args)
                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
            }) })))
        }) })))
    }) })))
}

fn def_bfs__00352d191335515e_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_bfsPath__2845b402ed7a7935(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                __aivi_call_args.push(((aivi_ok(args.clone())).and_then(|b| match b { Value::Record(map) => map.get("start").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(args.clone())).and_then(|b| match b { Value::Record(map) => map.get("end").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_bfs__00352d191335515e_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tree: Value, rt: &mut Runtime| {
        {
            let f = (def_bfsLoop__0e51d026c42f2084(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(tree.clone()))?);
                __aivi_call_args.push(((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_bfs__00352d191335515e(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_bfs__00352d191335515e_clause_0(rt))?,
        (def_bfs__00352d191335515e_clause_1(rt))?,
    ]))
}

fn def_aivi_graph_bfs__c176d2a461a5c9c7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_bfsPath__2845b402ed7a7935(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                __aivi_call_args.push(((aivi_ok(args.clone())).and_then(|b| match b { Value::Record(map) => map.get("start").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(args.clone())).and_then(|b| match b { Value::Record(map) => map.get("end").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_shortestPathUnweighted__f00d0cc12c248a6e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let g = g.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
                let g = g.clone();
                let start = start.clone();
                {
                    let f = (def_bfsPath__2845b402ed7a7935(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_shortestPathUnweighted__780341f722bd0179(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let g = g.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
                let g = g.clone();
                let start = start.clone();
                {
                    let f = (def_bfsPath__2845b402ed7a7935(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_dfsLoop__ab20a2057b13182a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |visited: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |stack: Value, rt: &mut Runtime| {
                let idx = idx.clone();
                let visited = visited.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
                    let idx = idx.clone();
                    let stack = stack.clone();
                    let visited = visited.clone();
                    (aivi_ok(stack.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return {
                                    let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("node", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let node = __b.remove("node").expect("pattern binder");
                                let rest = __b.remove("rest").expect("pattern binder");
                                return ({
                                    let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(node.clone()))?);
                                    __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }).and_then(|c| match c { Value::Bool(true) => {
                                    let f = (def_dfsLoop__ab20a2057b13182a(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                    __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                    __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                    __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }, Value::Bool(false) => {
                                    let __v = ({
                                        let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(node.clone()))?);
                                        __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("visited2", v.clone()); true }
                                            }

                                    })(&__v, &mut __b0);
                                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let visited2 = __b0.remove("visited2").expect("pattern binder");
                                    let __v = ({
                                        let f = (def_append__3e7fe942f71f1e61(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push(({
                                                let f = (def_neighborsI__104c9ba413dc1b93(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                                __aivi_call_args.push((aivi_ok(node.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            })?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("next", v.clone()); true }
                                            }

                                    })(&__v, &mut __b1);
                                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let next = __b1.remove("next").expect("pattern binder");
                                    {
                                        let f = (def_dfsLoop__ab20a2057b13182a(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                        __aivi_call_args.push((aivi_ok(visited2.clone()))?);
                                        __aivi_call_args.push((aivi_ok(next.clone()))?);
                                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(node.clone()))?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                        rt.call(f, __aivi_call_args)
                                    }
                                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_dfsLoop__a5eaebb46b5e1a97(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |visited: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |stack: Value, rt: &mut Runtime| {
                let idx = idx.clone();
                let visited = visited.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
                    let idx = idx.clone();
                    let stack = stack.clone();
                    let visited = visited.clone();
                    (aivi_ok(stack.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return {
                                    let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("node", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let node = __b.remove("node").expect("pattern binder");
                                let rest = __b.remove("rest").expect("pattern binder");
                                return ({
                                    let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(node.clone()))?);
                                    __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }).and_then(|c| match c { Value::Bool(true) => {
                                    let f = (def_dfsLoop__ab20a2057b13182a(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                    __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                    __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                    __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }, Value::Bool(false) => {
                                    let __v = ({
                                        let f = ((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(node.clone()))?);
                                        __aivi_call_args.push((aivi_ok(visited.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("visited2", v.clone()); true }
                                            }

                                    })(&__v, &mut __b0);
                                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let visited2 = __b0.remove("visited2").expect("pattern binder");
                                    let __v = ({
                                        let f = (def_append__3e7fe942f71f1e61(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push(({
                                                let f = (def_neighborsI__104c9ba413dc1b93(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                                __aivi_call_args.push((aivi_ok(node.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            })?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("next", v.clone()); true }
                                            }

                                    })(&__v, &mut __b1);
                                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let next = __b1.remove("next").expect("pattern binder");
                                    {
                                        let f = (def_dfsLoop__ab20a2057b13182a(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                        __aivi_call_args.push((aivi_ok(visited2.clone()))?);
                                        __aivi_call_args.push((aivi_ok(next.clone()))?);
                                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(node.clone()))?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                        rt.call(f, __aivi_call_args)
                                    }
                                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_dfs__ca973f18f45fedd4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_dfsLoop__ab20a2057b13182a(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_index__83cf8e8f9081468b(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                __aivi_call_args.push(((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(start.clone()))?]))))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_graph_dfs__af3d68a457128c39(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let g = g.clone();
            {
                let f = (def_dfsLoop__ab20a2057b13182a(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_index__83cf8e8f9081468b(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                __aivi_call_args.push(((aivi_ok(__builtin("Set"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(start.clone()))?]))))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_indegreeInit__61b01eb49b82e244(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
            let nodes = nodes.clone();
            (aivi_ok(nodes.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(m.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return {
                            let f = (def_indegreeInit__61b01eb49b82e244(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push(({
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(n.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_graph_indegreeInit__f7a21ee0f6fcf0b3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
            let nodes = nodes.clone();
            (aivi_ok(nodes.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(m.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("n", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let n = __b.remove("n").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return {
                            let f = (def_indegreeInit__61b01eb49b82e244(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push(({
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(n.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_indegreeEdges__231240940a7059ec(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |indeg: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
            let indeg = indeg.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |inMap: Value, rt: &mut Runtime| {
                let indeg = indeg.clone();
                let nodes = nodes.clone();
                (aivi_ok(nodes.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(indeg.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("n", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let n = __b.remove("n").expect("pattern binder");
                            let rest = __b.remove("rest").expect("pattern binder");
                            return {
                                let f = (def_indegreeEdges__231240940a7059ec(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                    __aivi_call_args.push(({
                                        let f = (def_length__ea11573f1af59eb5(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                            __aivi_call_args.push((aivi_ok(inMap.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        rt.call(f, __aivi_call_args)
                                    })?);
                                    __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push((aivi_ok(inMap.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_indegreeEdges__256c0a1fb616b29d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |indeg: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
            let indeg = indeg.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |inMap: Value, rt: &mut Runtime| {
                let indeg = indeg.clone();
                let nodes = nodes.clone();
                (aivi_ok(nodes.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(indeg.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("n", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let n = __b.remove("n").expect("pattern binder");
                            let rest = __b.remove("rest").expect("pattern binder");
                            return {
                                let f = (def_indegreeEdges__231240940a7059ec(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                    __aivi_call_args.push(({
                                        let f = (def_length__ea11573f1af59eb5(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(n.clone()))?);
                                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                            __aivi_call_args.push((aivi_ok(inMap.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        rt.call(f, __aivi_call_args)
                                    })?);
                                    __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push((aivi_ok(inMap.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_enqueueZero__77181d13ee25cc7b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |indeg: Value, rt: &mut Runtime| {
            let nodes = nodes.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                let indeg = indeg.clone();
                let nodes = nodes.clone();
                (aivi_ok(nodes.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(q.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("n", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let n = __b.remove("n").expect("pattern binder");
                            let rest = __b.remove("rest").expect("pattern binder");
                            return (({
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(n.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }).and_then(|a| (aivi_ok(Value::Int(0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                let f = (def_enqueueZero__77181d13ee25cc7b(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                    __aivi_call_args.push((aivi_ok(q.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            }, Value::Bool(false) => {
                                let f = (def_enqueueZero__77181d13ee25cc7b(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                __aivi_call_args.push((aivi_ok(q.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_enqueueZero__a0e92ced9fbb45fa(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |nodes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |indeg: Value, rt: &mut Runtime| {
            let nodes = nodes.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                let indeg = indeg.clone();
                let nodes = nodes.clone();
                (aivi_ok(nodes.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(q.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("n", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let n = __b.remove("n").expect("pattern binder");
                            let rest = __b.remove("rest").expect("pattern binder");
                            return (({
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(n.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }).and_then(|a| (aivi_ok(Value::Int(0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                let f = (def_enqueueZero__77181d13ee25cc7b(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(n.clone()))?);
                                    __aivi_call_args.push((aivi_ok(q.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            }, Value::Bool(false) => {
                                let f = (def_enqueueZero__77181d13ee25cc7b(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                __aivi_call_args.push((aivi_ok(q.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_topoRelax__cac59c06b13cafb1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |indeg: Value, rt: &mut Runtime| {
            let edges = edges.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                let edges = edges.clone();
                let indeg = indeg.clone();
                (aivi_ok(edges.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let mut map = HashMap::new();
                                map.insert("indeg".to_string(), (aivi_ok(indeg.clone()))?);
                                map.insert("q".to_string(), (aivi_ok(q.clone()))?);
                                aivi_ok(Value::Record(Arc::new(map)))
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("e", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let e = __b.remove("e").expect("pattern binder");
                            let rest = __b.remove("rest").expect("pattern binder");
                            return {
                                let __v = ((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("to", v.clone()); true }
                                        }

                                })(&__v, &mut __b0);
                                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let to = __b0.remove("to").expect("pattern binder");
                                let __v = ({
                                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(to.clone()))?);
                                    __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                                    __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?;
                                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("cur", v.clone()); true }
                                        }

                                })(&__v, &mut __b1);
                                if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let cur = __b1.remove("cur").expect("pattern binder");
                                let __v = ((aivi_ok(cur.clone())).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                                let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                                let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("next", v.clone()); true }
                                        }

                                })(&__v, &mut __b2);
                                if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let next = __b2.remove("next").expect("pattern binder");
                                let __v = ({
                                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(to.clone()))?);
                                    __aivi_call_args.push((aivi_ok(next.clone()))?);
                                    __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?;
                                let mut __b3: HashMap<&'static str, Value> = HashMap::new();
                                let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("indeg2", v.clone()); true }
                                        }

                                })(&__v, &mut __b3);
                                if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let indeg2 = __b3.remove("indeg2").expect("pattern binder");
                                let __v = (((aivi_ok(next.clone())).and_then(|a| (aivi_ok(Value::Int(0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                    let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(to.clone()))?);
                                    __aivi_call_args.push((aivi_ok(q.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }, Value::Bool(false) => aivi_ok(q.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __b4: HashMap<&'static str, Value> = HashMap::new();
                                let __ok4 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("q2", v.clone()); true }
                                        }

                                })(&__v, &mut __b4);
                                if !__ok4 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let q2 = __b4.remove("q2").expect("pattern binder");
                                {
                                    let f = (def_topoRelax__cac59c06b13cafb1(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                    __aivi_call_args.push((aivi_ok(indeg2.clone()))?);
                                    __aivi_call_args.push((aivi_ok(q2.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_topoRelax__280fe4555e3d3648(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |indeg: Value, rt: &mut Runtime| {
            let edges = edges.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                let edges = edges.clone();
                let indeg = indeg.clone();
                (aivi_ok(edges.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let mut map = HashMap::new();
                                map.insert("indeg".to_string(), (aivi_ok(indeg.clone()))?);
                                map.insert("q".to_string(), (aivi_ok(q.clone()))?);
                                aivi_ok(Value::Record(Arc::new(map)))
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("e", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let e = __b.remove("e").expect("pattern binder");
                            let rest = __b.remove("rest").expect("pattern binder");
                            return {
                                let __v = ((aivi_ok(e.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("to", v.clone()); true }
                                        }

                                })(&__v, &mut __b0);
                                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let to = __b0.remove("to").expect("pattern binder");
                                let __v = ({
                                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(to.clone()))?);
                                    __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                                    __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?;
                                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("cur", v.clone()); true }
                                        }

                                })(&__v, &mut __b1);
                                if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let cur = __b1.remove("cur").expect("pattern binder");
                                let __v = ((aivi_ok(cur.clone())).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                                let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                                let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("next", v.clone()); true }
                                        }

                                })(&__v, &mut __b2);
                                if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let next = __b2.remove("next").expect("pattern binder");
                                let __v = ({
                                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(to.clone()))?);
                                    __aivi_call_args.push((aivi_ok(next.clone()))?);
                                    __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?;
                                let mut __b3: HashMap<&'static str, Value> = HashMap::new();
                                let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("indeg2", v.clone()); true }
                                        }

                                })(&__v, &mut __b3);
                                if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let indeg2 = __b3.remove("indeg2").expect("pattern binder");
                                let __v = (((aivi_ok(next.clone())).and_then(|a| (aivi_ok(Value::Int(0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                    let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(to.clone()))?);
                                    __aivi_call_args.push((aivi_ok(q.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }, Value::Bool(false) => aivi_ok(q.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __b4: HashMap<&'static str, Value> = HashMap::new();
                                let __ok4 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("q2", v.clone()); true }
                                        }

                                })(&__v, &mut __b4);
                                if !__ok4 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let q2 = __b4.remove("q2").expect("pattern binder");
                                {
                                    let f = (def_topoRelax__cac59c06b13cafb1(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                    __aivi_call_args.push((aivi_ok(indeg2.clone()))?);
                                    __aivi_call_args.push((aivi_ok(q2.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_topoLoop__26ef90398ab60307(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |indeg: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                let idx = idx.clone();
                let indeg = indeg.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
                    let idx = idx.clone();
                    let indeg = indeg.clone();
                    let q = q.clone();
                    ({
                        let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("dequeue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(q.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(outRev.clone());
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                    let v0 = &args[0];
                                    if !(match v0 { Value::Tuple(items) if items.len() == 2 => {
                                        let v0 = &items[0];
                                        if !({ b.insert("node", v0.clone()); true }) { return false; }
                                        let v1 = &items[1];
                                        if !({ b.insert("q2", v1.clone()); true }) { return false; }
                                        true
                                    }, _ => false }) { return false; }
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let node = __b.remove("node").expect("pattern binder");
                                let q2 = __b.remove("q2").expect("pattern binder");
                                return {
                                    let __v = ({
                                        let f = (def_topoRelax__cac59c06b13cafb1(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = (def_edgesFromI__fe47d6af8a7b706c(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                        __aivi_call_args.push((aivi_ok(q2.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("res", v.clone()); true }
                                            }

                                    })(&__v, &mut __b0);
                                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let res = __b0.remove("res").expect("pattern binder");
                                    {
                                        let f = (def_topoLoop__26ef90398ab60307(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                        __aivi_call_args.push(((aivi_ok(res.clone())).and_then(|b| match b { Value::Record(map) => map.get("indeg").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                        __aivi_call_args.push(((aivi_ok(res.clone())).and_then(|b| match b { Value::Record(map) => map.get("q").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(node.clone()))?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                        rt.call(f, __aivi_call_args)
                                    }
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_topoLoop__48c506ae9018a9b8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |indeg: Value, rt: &mut Runtime| {
            let idx = idx.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
                let idx = idx.clone();
                let indeg = indeg.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
                    let idx = idx.clone();
                    let indeg = indeg.clone();
                    let q = q.clone();
                    ({
                        let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("dequeue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(q.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(outRev.clone());
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                    let v0 = &args[0];
                                    if !(match v0 { Value::Tuple(items) if items.len() == 2 => {
                                        let v0 = &items[0];
                                        if !({ b.insert("node", v0.clone()); true }) { return false; }
                                        let v1 = &items[1];
                                        if !({ b.insert("q2", v1.clone()); true }) { return false; }
                                        true
                                    }, _ => false }) { return false; }
                                    true
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let node = __b.remove("node").expect("pattern binder");
                                let q2 = __b.remove("q2").expect("pattern binder");
                                return {
                                    let __v = ({
                                        let f = (def_topoRelax__cac59c06b13cafb1(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = (def_edgesFromI__fe47d6af8a7b706c(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                            __aivi_call_args.push((aivi_ok(node.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                                        __aivi_call_args.push((aivi_ok(q2.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("res", v.clone()); true }
                                            }

                                    })(&__v, &mut __b0);
                                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let res = __b0.remove("res").expect("pattern binder");
                                    {
                                        let f = (def_topoLoop__26ef90398ab60307(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idx.clone()))?);
                                        __aivi_call_args.push(((aivi_ok(res.clone())).and_then(|b| match b { Value::Record(map) => map.get("indeg").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                        __aivi_call_args.push(((aivi_ok(res.clone())).and_then(|b| match b { Value::Record(map) => map.get("q").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(node.clone()))?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                        rt.call(f, __aivi_call_args)
                                    }
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_topoSortIndexed__d2c4a8aecc7468ea(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_indegreeInit__61b01eb49b82e244(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("indeg0", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let indeg0 = __b0.remove("indeg0").expect("pattern binder");
            let __v = ({
                let f = (def_indegreeEdges__231240940a7059ec(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(indeg0.clone()))?);
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("incoming").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("indeg", v.clone()); true }
                    }

            })(&__v, &mut __b1);
            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let indeg = __b1.remove("indeg").expect("pattern binder");
            let __v = ({
                let f = (def_enqueueZero__77181d13ee25cc7b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                __aivi_call_args.push(((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b2: HashMap<&'static str, Value> = HashMap::new();
            let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("q0", v.clone()); true }
                    }

            })(&__v, &mut __b2);
            if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let q0 = __b2.remove("q0").expect("pattern binder");
            let __v = ({
                let f = (def_topoLoop__26ef90398ab60307(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                __aivi_call_args.push((aivi_ok(q0.clone()))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b3: HashMap<&'static str, Value> = HashMap::new();
            let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("outRev", v.clone()); true }
                    }

            })(&__v, &mut __b3);
            if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let outRev = __b3.remove("outRev").expect("pattern binder");
            let __v = ({
                let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b4: HashMap<&'static str, Value> = HashMap::new();
            let __ok4 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("out", v.clone()); true }
                    }

            })(&__v, &mut __b4);
            if !__ok4 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let out = __b4.remove("out").expect("pattern binder");
            (({
                let f = (def_length__ea11573f1af59eb5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(out.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|a| ({
                let f = (def_length__ea11573f1af59eb5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(out.clone()), Value::Bool(false) => aivi_ok(Value::List(Arc::new(Vec::new()))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_aivi_graph_topoSortIndexed__c94becef7677db6f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idx: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_indegreeInit__61b01eb49b82e244(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("indeg0", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let indeg0 = __b0.remove("indeg0").expect("pattern binder");
            let __v = ({
                let f = (def_indegreeEdges__231240940a7059ec(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(indeg0.clone()))?);
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("incoming").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("indeg", v.clone()); true }
                    }

            })(&__v, &mut __b1);
            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let indeg = __b1.remove("indeg").expect("pattern binder");
            let __v = ({
                let f = (def_enqueueZero__77181d13ee25cc7b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                __aivi_call_args.push(((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b2: HashMap<&'static str, Value> = HashMap::new();
            let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("q0", v.clone()); true }
                    }

            })(&__v, &mut __b2);
            if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let q0 = __b2.remove("q0").expect("pattern binder");
            let __v = ({
                let f = (def_topoLoop__26ef90398ab60307(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(idx.clone()))?);
                __aivi_call_args.push((aivi_ok(indeg.clone()))?);
                __aivi_call_args.push((aivi_ok(q0.clone()))?);
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b3: HashMap<&'static str, Value> = HashMap::new();
            let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("outRev", v.clone()); true }
                    }

            })(&__v, &mut __b3);
            if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let outRev = __b3.remove("outRev").expect("pattern binder");
            let __v = ({
                let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b4: HashMap<&'static str, Value> = HashMap::new();
            let __ok4 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("out", v.clone()); true }
                    }

            })(&__v, &mut __b4);
            if !__ok4 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let out = __b4.remove("out").expect("pattern binder");
            (({
                let f = (def_length__ea11573f1af59eb5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(out.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|a| ({
                let f = (def_length__ea11573f1af59eb5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(idx.clone())).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            }).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(out.clone()), Value::Bool(false) => aivi_ok(Value::List(Arc::new(Vec::new()))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_topoSort__045760e6340065e5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let f = (def_topoSortIndexed__d2c4a8aecc7468ea(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (def_index__83cf8e8f9081468b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_graph_topoSort__385e0f4a2a53b63a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        {
            let f = (def_topoSortIndexed__d2c4a8aecc7468ea(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (def_index__83cf8e8f9081468b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_hasCycle__da4c0d393ee54c2b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        ({
            let f = (def_length__ea11573f1af59eb5(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (def_topoSort__045760e6340065e5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }).and_then(|a| ({
            let f = (def_length__ea11573f1af59eb5(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((({
                let f = (def_index__83cf8e8f9081468b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }).map(|b| Value::Bool(!aivi_native_runtime::values_equal(&a, &b))))
    }) })))
}

fn def_aivi_graph_hasCycle__854755a7f7d8a6d8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        ({
            let f = (def_length__ea11573f1af59eb5(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (def_topoSort__045760e6340065e5(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }).and_then(|a| ({
            let f = (def_length__ea11573f1af59eb5(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((({
                let f = (def_index__83cf8e8f9081468b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(g.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|b| match b { Value::Record(map) => map.get("nodes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }).map(|b| Value::Bool(!aivi_native_runtime::values_equal(&a, &b))))
    }) })))
}

fn def_shortestPath__36478c74a79779c0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let g = g.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
                let g = g.clone();
                let start = start.clone();
                {
                    let f = ((aivi_ok(__builtin("graph"))).and_then(|b| match b { Value::Record(map) => map.get("shortestPath").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_shortestPath__4f710561b4c37ab7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |g: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |start: Value, rt: &mut Runtime| {
            let g = g.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |goal: Value, rt: &mut Runtime| {
                let g = g.clone();
                let start = start.clone();
                {
                    let f = ((aivi_ok(__builtin("graph"))).and_then(|b| match b { Value::Record(map) => map.get("shortestPath").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(g.clone()))?);
                    __aivi_call_args.push((aivi_ok(start.clone()))?);
                    __aivi_call_args.push((aivi_ok(goal.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_relax__e79982f33b289295(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |dists: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |currentDist: Value, rt: &mut Runtime| {
            let dists = dists.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
                let currentDist = currentDist.clone();
                let dists = dists.clone();
                aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
                    func: Arc::new(move |rt: &mut Runtime| {
                        let mut __cleanups: Vec<Value> = Vec::new();
                        let currentDist = currentDist.clone();
                        let dists = dists.clone();
                        let edge = edge.clone();
                        let __result: R = {
                                let __tmp = ({
                                let f = (aivi_ok(__builtin("pure")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(currentDist.clone())).and_then(|l| ((aivi_ok(edge.clone())).and_then(|b| match b { Value::Record(map) => map.get("weight").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                                let __v = match __tmp {
                                    Value::Resource(res) => {
                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                        __cleanups.push(cleanup);
                                        v
                                    }
                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                    other => other,
                                };
                            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("newDist", v.clone()); true }
                                    }

                            })(&__v, &mut __b0);
                            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let newDist = __b0.remove("newDist").expect("pattern binder");
                                let __tmp = ({
                                let f = ((aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(edge.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                __aivi_call_args.push((aivi_ok(dists.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                                let __v = match __tmp {
                                    Value::Resource(res) => {
                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                        __cleanups.push(cleanup);
                                        v
                                    }
                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                    other => other,
                                };
                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("maybeDist", v.clone()); true }
                                    }

                            })(&__v, &mut __b1);
                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let maybeDist = __b1.remove("maybeDist").expect("pattern binder");
                                let __tmp = ({
                                let f = (aivi_ok(__builtin("pure")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(maybeDist.clone())).and_then(|__scrut| {
                                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                                true
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_0(&__scrut, &mut __b) {
                                            return aivi_ok(Value::Bool(true));
                                        }
                                    }

                                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                                let v0 = &args[0];
                                                if !({ b.insert("oldDist", v0.clone()); true }) { return false; }
                                                true
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_1(&__scrut, &mut __b) {
                                            let oldDist = __b.remove("oldDist").expect("pattern binder");
                                            return (aivi_ok(newDist.clone())).and_then(|l| (aivi_ok(oldDist.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }));
                                        }
                                    }

                                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                }))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                                let __v = match __tmp {
                                    Value::Resource(res) => {
                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                        __cleanups.push(cleanup);
                                        v
                                    }
                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                    other => other,
                                };
                            let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                            let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("shouldUpdate", v.clone()); true }
                                    }

                            })(&__v, &mut __b2);
                            if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let shouldUpdate = __b2.remove("shouldUpdate").expect("pattern binder");
                                let __e = ((aivi_ok(shouldUpdate.clone())).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
                                func: Arc::new(move |rt: &mut Runtime| {
                                    let mut __cleanups: Vec<Value> = Vec::new();
                                    let dists = dists.clone();
                                    let edge = edge.clone();
                                    let newDist = newDist.clone();
                                    let __result: R = {
                                            let __tmp = ({
                                            let f = ((aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push(((aivi_ok(edge.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                            __aivi_call_args.push((aivi_ok(newDist.clone()))?);
                                            __aivi_call_args.push((aivi_ok(dists.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?;
                                            let __v = match __tmp {
                                                Value::Resource(res) => {
                                                    let (v, cleanup) = rt.acquire_resource(res)?;
                                                    __cleanups.push(cleanup);
                                                    v
                                                }
                                                Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                                other => other,
                                            };
                                        let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                        let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                                {
                                                    use Value::*;
                                                    true
                                                }

                                        })(&__v, &mut __b0);
                                        if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                            let __e = ({
                                            let f = (aivi_ok(__builtin("pure")))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(Value::Bool(true)))?);
                                            rt.call(f, __aivi_call_args)
                                        })?;
                                            rt.run_effect_value(__e)
                                    };
                                    let __cleanup_result: Result<(), RuntimeError> = (|| {
                                            for cleanup in __cleanups.into_iter().rev() {
                                                let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                                            }
                                            Ok(())
                                    })();
                                    match (__result, __cleanup_result) {
                                            (Err(err), _) => Err(err),
                                            (Ok(_), Err(err)) => Err(err),
                                            (Ok(v), Ok(())) => Ok(v),
                                    }
                                }),
                            }))), Value::Bool(false) => {
                                let f = (aivi_ok(__builtin("pure")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(Value::Bool(false)))?);
                                rt.call(f, __aivi_call_args)
                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                rt.run_effect_value(__e)
                        };
                        let __cleanup_result: Result<(), RuntimeError> = (|| {
                                for cleanup in __cleanups.into_iter().rev() {
                                    let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                                }
                                Ok(())
                        })();
                        match (__result, __cleanup_result) {
                                (Err(err), _) => Err(err),
                                (Ok(_), Err(err)) => Err(err),
                                (Ok(v), Ok(())) => Ok(v),
                        }
                    }),
                })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_relax__57b6d09a3cf9655c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |dists: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |currentDist: Value, rt: &mut Runtime| {
            let dists = dists.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edge: Value, rt: &mut Runtime| {
                let currentDist = currentDist.clone();
                let dists = dists.clone();
                aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
                    func: Arc::new(move |rt: &mut Runtime| {
                        let mut __cleanups: Vec<Value> = Vec::new();
                        let currentDist = currentDist.clone();
                        let dists = dists.clone();
                        let edge = edge.clone();
                        let __result: R = {
                                let __tmp = ({
                                let f = (aivi_ok(__builtin("pure")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(currentDist.clone())).and_then(|l| ((aivi_ok(edge.clone())).and_then(|b| match b { Value::Record(map) => map.get("weight").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                                let __v = match __tmp {
                                    Value::Resource(res) => {
                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                        __cleanups.push(cleanup);
                                        v
                                    }
                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                    other => other,
                                };
                            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("newDist", v.clone()); true }
                                    }

                            })(&__v, &mut __b0);
                            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let newDist = __b0.remove("newDist").expect("pattern binder");
                                let __tmp = ({
                                let f = ((aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(edge.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                __aivi_call_args.push((aivi_ok(dists.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                                let __v = match __tmp {
                                    Value::Resource(res) => {
                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                        __cleanups.push(cleanup);
                                        v
                                    }
                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                    other => other,
                                };
                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("maybeDist", v.clone()); true }
                                    }

                            })(&__v, &mut __b1);
                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let maybeDist = __b1.remove("maybeDist").expect("pattern binder");
                                let __tmp = ({
                                let f = (aivi_ok(__builtin("pure")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(((aivi_ok(maybeDist.clone())).and_then(|__scrut| {
                                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                                true
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_0(&__scrut, &mut __b) {
                                            return aivi_ok(Value::Bool(true));
                                        }
                                    }

                                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                                let v0 = &args[0];
                                                if !({ b.insert("oldDist", v0.clone()); true }) { return false; }
                                                true
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_1(&__scrut, &mut __b) {
                                            let oldDist = __b.remove("oldDist").expect("pattern binder");
                                            return (aivi_ok(newDist.clone())).and_then(|l| (aivi_ok(oldDist.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }));
                                        }
                                    }

                                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                }))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                                let __v = match __tmp {
                                    Value::Resource(res) => {
                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                        __cleanups.push(cleanup);
                                        v
                                    }
                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                    other => other,
                                };
                            let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                            let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("shouldUpdate", v.clone()); true }
                                    }

                            })(&__v, &mut __b2);
                            if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let shouldUpdate = __b2.remove("shouldUpdate").expect("pattern binder");
                                let __e = ((aivi_ok(shouldUpdate.clone())).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
                                func: Arc::new(move |rt: &mut Runtime| {
                                    let mut __cleanups: Vec<Value> = Vec::new();
                                    let dists = dists.clone();
                                    let edge = edge.clone();
                                    let newDist = newDist.clone();
                                    let __result: R = {
                                            let __tmp = ({
                                            let f = ((aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push(((aivi_ok(edge.clone())).and_then(|b| match b { Value::Record(map) => map.get("to").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                            __aivi_call_args.push((aivi_ok(newDist.clone()))?);
                                            __aivi_call_args.push((aivi_ok(dists.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?;
                                            let __v = match __tmp {
                                                Value::Resource(res) => {
                                                    let (v, cleanup) = rt.acquire_resource(res)?;
                                                    __cleanups.push(cleanup);
                                                    v
                                                }
                                                Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                                other => other,
                                            };
                                        let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                        let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                                {
                                                    use Value::*;
                                                    true
                                                }

                                        })(&__v, &mut __b0);
                                        if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                            let __e = ({
                                            let f = (aivi_ok(__builtin("pure")))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(Value::Bool(true)))?);
                                            rt.call(f, __aivi_call_args)
                                        })?;
                                            rt.run_effect_value(__e)
                                    };
                                    let __cleanup_result: Result<(), RuntimeError> = (|| {
                                            for cleanup in __cleanups.into_iter().rev() {
                                                let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                                            }
                                            Ok(())
                                    })();
                                    match (__result, __cleanup_result) {
                                            (Err(err), _) => Err(err),
                                            (Ok(_), Err(err)) => Err(err),
                                            (Ok(v), Ok(())) => Ok(v),
                                    }
                                }),
                            }))), Value::Bool(false) => {
                                let f = (aivi_ok(__builtin("pure")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(Value::Bool(false)))?);
                                rt.call(f, __aivi_call_args)
                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                rt.run_effect_value(__e)
                        };
                        let __cleanup_result: Result<(), RuntimeError> = (|| {
                                for cleanup in __cleanups.into_iter().rev() {
                                    let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                                }
                                Ok(())
                        })();
                        match (__result, __cleanup_result) {
                                (Err(err), _) => Err(err),
                                (Ok(_), Err(err)) => Err(err),
                                (Ok(v), Ok(())) => Ok(v),
                        }
                    }),
                })))
            }) })))
        }) })))
    }) })))
}

fn def_relaxEdges__be3568e2b367078d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |dists: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |currentDist: Value, rt: &mut Runtime| {
            let dists = dists.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
                let currentDist = currentDist.clone();
                let dists = dists.clone();
                {
                    let f = (def_relaxEdgesHelp__82bde04094189162(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(dists.clone()))?);
                    __aivi_call_args.push((aivi_ok(currentDist.clone()))?);
                    __aivi_call_args.push((aivi_ok(edges.clone()))?);
                    __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_relaxEdges__d37ebc53d35196d6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |dists: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |currentDist: Value, rt: &mut Runtime| {
            let dists = dists.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
                let currentDist = currentDist.clone();
                let dists = dists.clone();
                {
                    let f = (def_relaxEdgesHelp__82bde04094189162(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(dists.clone()))?);
                    __aivi_call_args.push((aivi_ok(currentDist.clone()))?);
                    __aivi_call_args.push((aivi_ok(edges.clone()))?);
                    __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_relaxEdgesHelp__82bde04094189162(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |dists: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |currentDist: Value, rt: &mut Runtime| {
            let dists = dists.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
                let currentDist = currentDist.clone();
                let dists = dists.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |count: Value, rt: &mut Runtime| {
                    let currentDist = currentDist.clone();
                    let dists = dists.clone();
                    let edges = edges.clone();
                    (aivi_ok(edges.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return {
                                    let f = (aivi_ok(__builtin("pure")))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(count.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("e", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let e = __b.remove("e").expect("pattern binder");
                                let rest = __b.remove("rest").expect("pattern binder");
                                return aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
                                    func: Arc::new(move |rt: &mut Runtime| {
                                        let mut __cleanups: Vec<Value> = Vec::new();
                                        let count = count.clone();
                                        let currentDist = currentDist.clone();
                                        let dists = dists.clone();
                                        let e = e.clone();
                                        let rest = rest.clone();
                                        let __result: R = {
                                                let __tmp = ({
                                                let f = (def_relax__e79982f33b289295(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(dists.clone()))?);
                                                __aivi_call_args.push((aivi_ok(currentDist.clone()))?);
                                                __aivi_call_args.push((aivi_ok(e.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            })?;
                                                let __v = match __tmp {
                                                    Value::Resource(res) => {
                                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                                        __cleanups.push(cleanup);
                                                        v
                                                    }
                                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                                    other => other,
                                                };
                                            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                                    {
                                                        use Value::*;
                                                        { b.insert("updated", v.clone()); true }
                                                    }

                                            })(&__v, &mut __b0);
                                            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                            let updated = __b0.remove("updated").expect("pattern binder");
                                                let __tmp = ({
                                                let f = (aivi_ok(__builtin("pure")))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push(((aivi_ok(updated.clone())).and_then(|c| match c { Value::Bool(true) => (aivi_ok(count.clone())).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), Value::Bool(false) => aivi_ok(count.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                                rt.call(f, __aivi_call_args)
                                            })?;
                                                let __v = match __tmp {
                                                    Value::Resource(res) => {
                                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                                        __cleanups.push(cleanup);
                                                        v
                                                    }
                                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                                    other => other,
                                                };
                                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                                    {
                                                        use Value::*;
                                                        { b.insert("next", v.clone()); true }
                                                    }

                                            })(&__v, &mut __b1);
                                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                            let next = __b1.remove("next").expect("pattern binder");
                                                let __e = ({
                                                let f = (def_relaxEdgesHelp__82bde04094189162(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(dists.clone()))?);
                                                __aivi_call_args.push((aivi_ok(currentDist.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push((aivi_ok(next.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            })?;
                                                rt.run_effect_value(__e)
                                        };
                                        let __cleanup_result: Result<(), RuntimeError> = (|| {
                                                for cleanup in __cleanups.into_iter().rev() {
                                                    let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                                                }
                                                Ok(())
                                        })();
                                        match (__result, __cleanup_result) {
                                                (Err(err), _) => Err(err),
                                                (Ok(_), Err(err)) => Err(err),
                                                (Ok(v), Ok(())) => Ok(v),
                                        }
                                    }),
                                })));
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_graph_relaxEdgesHelp__937e0f162049d199(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |dists: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |currentDist: Value, rt: &mut Runtime| {
            let dists = dists.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |edges: Value, rt: &mut Runtime| {
                let currentDist = currentDist.clone();
                let dists = dists.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |count: Value, rt: &mut Runtime| {
                    let currentDist = currentDist.clone();
                    let dists = dists.clone();
                    let edges = edges.clone();
                    (aivi_ok(edges.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return {
                                    let f = (aivi_ok(__builtin("pure")))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(count.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("e", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let e = __b.remove("e").expect("pattern binder");
                                let rest = __b.remove("rest").expect("pattern binder");
                                return aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
                                    func: Arc::new(move |rt: &mut Runtime| {
                                        let mut __cleanups: Vec<Value> = Vec::new();
                                        let count = count.clone();
                                        let currentDist = currentDist.clone();
                                        let dists = dists.clone();
                                        let e = e.clone();
                                        let rest = rest.clone();
                                        let __result: R = {
                                                let __tmp = ({
                                                let f = (def_relax__e79982f33b289295(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(dists.clone()))?);
                                                __aivi_call_args.push((aivi_ok(currentDist.clone()))?);
                                                __aivi_call_args.push((aivi_ok(e.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            })?;
                                                let __v = match __tmp {
                                                    Value::Resource(res) => {
                                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                                        __cleanups.push(cleanup);
                                                        v
                                                    }
                                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                                    other => other,
                                                };
                                            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                                    {
                                                        use Value::*;
                                                        { b.insert("updated", v.clone()); true }
                                                    }

                                            })(&__v, &mut __b0);
                                            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                            let updated = __b0.remove("updated").expect("pattern binder");
                                                let __tmp = ({
                                                let f = (aivi_ok(__builtin("pure")))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push(((aivi_ok(updated.clone())).and_then(|c| match c { Value::Bool(true) => (aivi_ok(count.clone())).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), Value::Bool(false) => aivi_ok(count.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                                                rt.call(f, __aivi_call_args)
                                            })?;
                                                let __v = match __tmp {
                                                    Value::Resource(res) => {
                                                        let (v, cleanup) = rt.acquire_resource(res)?;
                                                        __cleanups.push(cleanup);
                                                        v
                                                    }
                                                    Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                                    other => other,
                                                };
                                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                                    {
                                                        use Value::*;
                                                        { b.insert("next", v.clone()); true }
                                                    }

                                            })(&__v, &mut __b1);
                                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                            let next = __b1.remove("next").expect("pattern binder");
                                                let __e = ({
                                                let f = (def_relaxEdgesHelp__82bde04094189162(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(dists.clone()))?);
                                                __aivi_call_args.push((aivi_ok(currentDist.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push((aivi_ok(next.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            })?;
                                                rt.run_effect_value(__e)
                                        };
                                        let __cleanup_result: Result<(), RuntimeError> = (|| {
                                                for cleanup in __cleanups.into_iter().rev() {
                                                    let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                                                }
                                                Ok(())
                                        })();
                                        match (__result, __cleanup_result) {
                                                (Err(err), _) => Err(err),
                                                (Ok(_), Err(err)) => Err(err),
                                                (Ok(v), Ok(())) => Ok(v),
                                        }
                                    }),
                                })));
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_node__3c2f1bbad18642ad(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |children: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = (aivi_ok(Value::Constructor { name: "Node".to_string(), args: Vec::new() }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(children.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_tree_node__dff2d0185e2e0e66(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |children: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = (aivi_ok(Value::Constructor { name: "Node".to_string(), args: Vec::new() }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(children.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_leaf__24ad84ada20208d5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Node".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_tree_leaf__c0ee272a8710562e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Node".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_valueOf__a3a7fde9b1aa14db(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        (aivi_ok(t.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Node" && args.len() == 2 => {
                        let v0 = &args[0];
                        if !({ b.insert("v", v0.clone()); true }) { return false; }
                        let v1 = &args[1];
                        if !(true) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let v = __b.remove("v").expect("pattern binder");
                    return aivi_ok(v.clone());
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_tree_valueOf__b717b2670f09df36(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        (aivi_ok(t.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Node" && args.len() == 2 => {
                        let v0 = &args[0];
                        if !({ b.insert("v", v0.clone()); true }) { return false; }
                        let v1 = &args[1];
                        if !(true) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let v = __b.remove("v").expect("pattern binder");
                    return aivi_ok(v.clone());
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_childrenOf__79a234e067329433(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        (aivi_ok(t.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Node" && args.len() == 2 => {
                        let v0 = &args[0];
                        if !(true) { return false; }
                        let v1 = &args[1];
                        if !({ b.insert("cs", v1.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let cs = __b.remove("cs").expect("pattern binder");
                    return aivi_ok(cs.clone());
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_tree_childrenOf__372feca7083582b8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        (aivi_ok(t.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Node" && args.len() == 2 => {
                        let v0 = &args[0];
                        if !(true) { return false; }
                        let v1 = &args[1];
                        if !({ b.insert("cs", v1.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    let cs = __b.remove("cs").expect("pattern binder");
                    return aivi_ok(cs.clone());
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_tree_append__46b188fc4ffdf59e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ys: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(ys.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("h", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("t", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let h = __b.remove("h").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(h.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(ys.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_tree_reverse__0ff7e41fc68856d4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        {
            let f = (def_reverseGo__55c01e74c8f95d2b(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(xs.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_reverseGo__55c01e74c8f95d2b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(acc.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("h", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("t", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let h = __b.remove("h").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let f = (def_reverseGo__55c01e74c8f95d2b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(h.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_tree_reverseGo__7c72b2325dbffb12(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(acc.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("h", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("t", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let h = __b.remove("h").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let f = (def_reverseGo__55c01e74c8f95d2b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(h.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_dfsPreorder__4c987917f7faf99f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tree: Value, rt: &mut Runtime| {
        {
            let f = (def_dfsPreorderGo__571004b0366d2d05(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tree.clone()))?]))))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_tree_dfsPreorder__2c162f0fad93f56e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tree: Value, rt: &mut Runtime| {
        {
            let f = (def_dfsPreorderGo__571004b0366d2d05(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tree.clone()))?]))))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_dfsPreorderGo__571004b0366d2d05(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |stack: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
            let stack = stack.clone();
            (aivi_ok(stack.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("t", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let __v = ({
                                let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = (def_childrenOf__79a234e067329433(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(t.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("childrenRev", v.clone()); true }
                                    }

                            })(&__v, &mut __b0);
                            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let childrenRev = __b0.remove("childrenRev").expect("pattern binder");
                            let __v = ({
                                let f = (def_append__3e7fe942f71f1e61(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(childrenRev.clone()))?);
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("stack2", v.clone()); true }
                                    }

                            })(&__v, &mut __b1);
                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let stack2 = __b1.remove("stack2").expect("pattern binder");
                            {
                                let f = (def_dfsPreorderGo__571004b0366d2d05(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(stack2.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                    let f = (def_valueOf__a3a7fde9b1aa14db(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(t.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                rt.call(f, __aivi_call_args)
                            }
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_tree_dfsPreorderGo__ec913a94e967c90c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |stack: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
            let stack = stack.clone();
            (aivi_ok(stack.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("t", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let __v = ({
                                let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = (def_childrenOf__79a234e067329433(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(t.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("childrenRev", v.clone()); true }
                                    }

                            })(&__v, &mut __b0);
                            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let childrenRev = __b0.remove("childrenRev").expect("pattern binder");
                            let __v = ({
                                let f = (def_append__3e7fe942f71f1e61(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(childrenRev.clone()))?);
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("stack2", v.clone()); true }
                                    }

                            })(&__v, &mut __b1);
                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let stack2 = __b1.remove("stack2").expect("pattern binder");
                            {
                                let f = (def_dfsPreorderGo__571004b0366d2d05(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(stack2.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                    let f = (def_valueOf__a3a7fde9b1aa14db(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(t.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                rt.call(f, __aivi_call_args)
                            }
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_dfsPostorder__4b709162b9814536(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tree: Value, rt: &mut Runtime| {
        {
            let f = (def_dfsPostorderGo__5ab5b54fe12a0484(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tree.clone()))?]))))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_tree_dfsPostorder__ec60b0145e29d1a9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tree: Value, rt: &mut Runtime| {
        {
            let f = (def_dfsPostorderGo__5ab5b54fe12a0484(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tree.clone()))?]))))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_dfsPostorderGo__5ab5b54fe12a0484(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |work: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outStack: Value, rt: &mut Runtime| {
            let work = work.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
                let outStack = outStack.clone();
                let work = work.clone();
                (aivi_ok(work.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                {
                                    let f = (def_dfsPostorderDrain__7e7d99f4ef35a53c(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(outStack.clone()))?);
                                    __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("t", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let rest = __b.remove("rest").expect("pattern binder");
                            let t = __b.remove("t").expect("pattern binder");
                            return {
                                let __v = ({
                                    let f = (def_append__3e7fe942f71f1e61(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push(({
                                        let f = (def_childrenOf__79a234e067329433(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(t.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?);
                                    __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?;
                                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("work2", v.clone()); true }
                                        }

                                })(&__v, &mut __b0);
                                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let work2 = __b0.remove("work2").expect("pattern binder");
                                {
                                    let f = (def_dfsPostorderGo__5ab5b54fe12a0484(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(work2.clone()))?);
                                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(t.clone()))?]); out.extend({ let v = (aivi_ok(outStack.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                    __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_tree_dfsPostorderGo__17356e15cdb3fd7f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |work: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outStack: Value, rt: &mut Runtime| {
            let work = work.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
                let outStack = outStack.clone();
                let work = work.clone();
                (aivi_ok(work.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                {
                                    let f = (def_dfsPostorderDrain__7e7d99f4ef35a53c(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(outStack.clone()))?);
                                    __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("t", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let rest = __b.remove("rest").expect("pattern binder");
                            let t = __b.remove("t").expect("pattern binder");
                            return {
                                let __v = ({
                                    let f = (def_append__3e7fe942f71f1e61(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push(({
                                        let f = (def_childrenOf__79a234e067329433(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(t.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?);
                                    __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?;
                                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            { b.insert("work2", v.clone()); true }
                                        }

                                })(&__v, &mut __b0);
                                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                let work2 = __b0.remove("work2").expect("pattern binder");
                                {
                                    let f = (def_dfsPostorderGo__5ab5b54fe12a0484(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(work2.clone()))?);
                                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(t.clone()))?]); out.extend({ let v = (aivi_ok(outStack.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                    __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_dfsPostorderDrain__7e7d99f4ef35a53c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outStack: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
            let outStack = outStack.clone();
            (aivi_ok(outStack.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("t", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let f = (def_dfsPostorderDrain__7e7d99f4ef35a53c(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                let f = (def_valueOf__a3a7fde9b1aa14db(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(t.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_tree_dfsPostorderDrain__da383a9d8b8c4605(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outStack: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
            let outStack = outStack.clone();
            (aivi_ok(outStack.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("t", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let f = (def_dfsPostorderDrain__7e7d99f4ef35a53c(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                let f = (def_valueOf__a3a7fde9b1aa14db(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(t.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_tree_bfs__9b0a7c49b3c2978b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tree: Value, rt: &mut Runtime| {
        {
            let f = (def_bfsLoop__0e51d026c42f2084(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(tree.clone()))?);
                __aivi_call_args.push(((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_tree_bfsLoop__70001740b4a01809(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |outRev: Value, rt: &mut Runtime| {
            let q = q.clone();
            ({
                let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("dequeue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(q.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return {
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(outRev.clone()))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !(match v0 { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !({ b.insert("t", v0.clone()); true }) { return false; }
                                let v1 = &items[1];
                                if !({ b.insert("q2", v1.clone()); true }) { return false; }
                                true
                            }, _ => false }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let q2 = __b.remove("q2").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return {
                            let __v = ({
                                let f = (def_bfsEnqueueChildren__7a2e32d389d2171f(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = (def_childrenOf__79a234e067329433(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(t.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                __aivi_call_args.push((aivi_ok(q2.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        { b.insert("q3", v.clone()); true }
                                    }

                            })(&__v, &mut __b0);
                            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                            let q3 = __b0.remove("q3").expect("pattern binder");
                            {
                                let f = (def_bfsLoop__0e51d026c42f2084(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(q3.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![({
                                    let f = (def_valueOf__a3a7fde9b1aa14db(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(t.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?]); out.extend({ let v = (aivi_ok(outRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                rt.call(f, __aivi_call_args)
                            }
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_bfsEnqueueChildren__7a2e32d389d2171f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |children: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
            let children = children.clone();
            (aivi_ok(children.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(q.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("c", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let c = __b.remove("c").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return {
                            let f = (def_bfsEnqueueChildren__7a2e32d389d2171f(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push(({
                                let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(c.clone()))?);
                                __aivi_call_args.push((aivi_ok(q.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_tree_bfsEnqueueChildren__d5256d0daf02992c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |children: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
            let children = children.clone();
            (aivi_ok(children.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(q.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("c", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let c = __b.remove("c").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return {
                            let f = (def_bfsEnqueueChildren__7a2e32d389d2171f(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push(({
                                let f = ((aivi_ok(__builtin("Queue"))).and_then(|b| match b { Value::Record(map) => map.get("enqueue").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(c.clone()))?);
                                __aivi_call_args.push((aivi_ok(q.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_fromListBy__5e004bf343e1eff0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parentIdFn: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
                let idFn = idFn.clone();
                let parentIdFn = parentIdFn.clone();
                {
                    let __v = ({
                        let f = (def_fromListChildrenMap__cd1d7b480e8df638(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                        __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                        __aivi_call_args.push((aivi_ok(items.clone()))?);
                        __aivi_call_args.push(((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("childrenMap", v.clone()); true }
                            }

                    })(&__v, &mut __b0);
                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let childrenMap = __b0.remove("childrenMap").expect("pattern binder");
                    let __v = ({
                        let f = (def_rootsFromList__ee547cd5b363c1d2(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                        __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                        __aivi_call_args.push((aivi_ok(items.clone()))?);
                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("roots", v.clone()); true }
                            }

                    })(&__v, &mut __b1);
                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let roots = __b1.remove("roots").expect("pattern binder");
                    (aivi_ok(roots.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(__builtin("None"));
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("root", v0.clone()); true }) { return false; }
                                    items.len() == 1
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let root = __b.remove("root").expect("pattern binder");
                                return {
                                    let f = (aivi_ok(__builtin("Some")))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push(({
                                        let f = (def_buildTree__f2a40a4665f91dff(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                        __aivi_call_args.push(({
                                            let f = (aivi_ok(idFn.clone()))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(root.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        __aivi_call_args.push((aivi_ok(root.clone()))?);
                                        __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                true
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_2(&__scrut, &mut __b) {
                                return aivi_ok(__builtin("None"));
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_tree_fromListBy__ec31e04ed999dce3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parentIdFn: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
                let idFn = idFn.clone();
                let parentIdFn = parentIdFn.clone();
                {
                    let __v = ({
                        let f = (def_fromListChildrenMap__cd1d7b480e8df638(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                        __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                        __aivi_call_args.push((aivi_ok(items.clone()))?);
                        __aivi_call_args.push(((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("childrenMap", v.clone()); true }
                            }

                    })(&__v, &mut __b0);
                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let childrenMap = __b0.remove("childrenMap").expect("pattern binder");
                    let __v = ({
                        let f = (def_rootsFromList__ee547cd5b363c1d2(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                        __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                        __aivi_call_args.push((aivi_ok(items.clone()))?);
                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("roots", v.clone()); true }
                            }

                    })(&__v, &mut __b1);
                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                    let roots = __b1.remove("roots").expect("pattern binder");
                    (aivi_ok(roots.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(__builtin("None"));
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("root", v0.clone()); true }) { return false; }
                                    items.len() == 1
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let root = __b.remove("root").expect("pattern binder");
                                return {
                                    let f = (aivi_ok(__builtin("Some")))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push(({
                                        let f = (def_buildTree__f2a40a4665f91dff(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                        __aivi_call_args.push(({
                                            let f = (aivi_ok(idFn.clone()))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(root.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        __aivi_call_args.push((aivi_ok(root.clone()))?);
                                        __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                true
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_2(&__scrut, &mut __b) {
                                return aivi_ok(__builtin("None"));
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }
            }) })))
        }) })))
    }) })))
}

fn def_fromListChildrenMap__cd1d7b480e8df638(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parentIdFn: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
                let idFn = idFn.clone();
                let parentIdFn = parentIdFn.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
                    let idFn = idFn.clone();
                    let items = items.clone();
                    let parentIdFn = parentIdFn.clone();
                    (aivi_ok(items.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(acc.clone());
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let rest = __b.remove("rest").expect("pattern binder");
                                let x = __b.remove("x").expect("pattern binder");
                                return {
                                    let __v = ({
                                        let f = (aivi_ok(parentIdFn.clone()))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(x.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("pidOpt", v.clone()); true }
                                            }

                                    })(&__v, &mut __b0);
                                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let pidOpt = __b0.remove("pidOpt").expect("pattern binder");
                                    let __v = ((aivi_ok(pidOpt.clone())).and_then(|__scrut| {
                                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                            {
                                                use Value::*;
                                                match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                                    true
                                                }, _ => false }
                                            }
                                        }

                                        {
                                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                            if __match_arm_0(&__scrut, &mut __b) {
                                                return aivi_ok(acc.clone());
                                            }
                                        }

                                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                            {
                                                use Value::*;
                                                match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                                    let v0 = &args[0];
                                                    if !({ b.insert("pid", v0.clone()); true }) { return false; }
                                                    true
                                                }, _ => false }
                                            }
                                        }

                                        {
                                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                            if __match_arm_1(&__scrut, &mut __b) {
                                                let pid = __b.remove("pid").expect("pattern binder");
                                                return {
                                                    let f = (def_mapPush__a9dac869aac8f161(rt))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(pid.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(x.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(acc.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                };
                                            }
                                        }

                                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                    }))?;
                                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("acc2", v.clone()); true }
                                            }

                                    })(&__v, &mut __b1);
                                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let acc2 = __b1.remove("acc2").expect("pattern binder");
                                    {
                                        let f = (def_fromListChildrenMap__cd1d7b480e8df638(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                        __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        __aivi_call_args.push((aivi_ok(acc2.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    }
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_tree_fromListChildrenMap__d8c6434ece71a671(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parentIdFn: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
                let idFn = idFn.clone();
                let parentIdFn = parentIdFn.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
                    let idFn = idFn.clone();
                    let items = items.clone();
                    let parentIdFn = parentIdFn.clone();
                    (aivi_ok(items.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(acc.clone());
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let rest = __b.remove("rest").expect("pattern binder");
                                let x = __b.remove("x").expect("pattern binder");
                                return {
                                    let __v = ({
                                        let f = (aivi_ok(parentIdFn.clone()))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(x.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("pidOpt", v.clone()); true }
                                            }

                                    })(&__v, &mut __b0);
                                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let pidOpt = __b0.remove("pidOpt").expect("pattern binder");
                                    let __v = ((aivi_ok(pidOpt.clone())).and_then(|__scrut| {
                                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                            {
                                                use Value::*;
                                                match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                                    true
                                                }, _ => false }
                                            }
                                        }

                                        {
                                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                            if __match_arm_0(&__scrut, &mut __b) {
                                                return aivi_ok(acc.clone());
                                            }
                                        }

                                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                            {
                                                use Value::*;
                                                match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                                    let v0 = &args[0];
                                                    if !({ b.insert("pid", v0.clone()); true }) { return false; }
                                                    true
                                                }, _ => false }
                                            }
                                        }

                                        {
                                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                            if __match_arm_1(&__scrut, &mut __b) {
                                                let pid = __b.remove("pid").expect("pattern binder");
                                                return {
                                                    let f = (def_mapPush__a9dac869aac8f161(rt))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(pid.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(x.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(acc.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                };
                                            }
                                        }

                                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                    }))?;
                                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("acc2", v.clone()); true }
                                            }

                                    })(&__v, &mut __b1);
                                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let acc2 = __b1.remove("acc2").expect("pattern binder");
                                    {
                                        let f = (def_fromListChildrenMap__cd1d7b480e8df638(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                        __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        __aivi_call_args.push((aivi_ok(acc2.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    }
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_mapPush__a9dac869aac8f161(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let key = key.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
                let key = key.clone();
                let value = value.clone();
                ({
                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(key.clone()))?);
                    __aivi_call_args.push((aivi_ok(m.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(key.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(value.clone()))?]))))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("xs", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let xs = __b.remove("xs").expect("pattern binder");
                            return {
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(key.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(value.clone()))?]); out.extend({ let v = (aivi_ok(xs.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_tree_mapPush__03f329e6348b04f0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let key = key.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
                let key = key.clone();
                let value = value.clone();
                ({
                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(key.clone()))?);
                    __aivi_call_args.push((aivi_ok(m.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(key.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(value.clone()))?]))))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("xs", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let xs = __b.remove("xs").expect("pattern binder");
                            return {
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(key.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(value.clone()))?]); out.extend({ let v = (aivi_ok(xs.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                __aivi_call_args.push((aivi_ok(m.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_rootsFromList__ee547cd5b363c1d2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parentIdFn: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
                let idFn = idFn.clone();
                let parentIdFn = parentIdFn.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |accRev: Value, rt: &mut Runtime| {
                    let idFn = idFn.clone();
                    let items = items.clone();
                    let parentIdFn = parentIdFn.clone();
                    (aivi_ok(items.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return {
                                    let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let rest = __b.remove("rest").expect("pattern binder");
                                let x = __b.remove("x").expect("pattern binder");
                                return ({
                                    let f = (aivi_ok(parentIdFn.clone()))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(x.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }).and_then(|__scrut| {
                                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                                true
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_0(&__scrut, &mut __b) {
                                            return {
                                                let f = (def_rootsFromList__ee547cd5b363c1d2(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                                rt.call(f, __aivi_call_args)
                                            };
                                        }
                                    }

                                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                                let v0 = &args[0];
                                                if !(true) { return false; }
                                                true
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_1(&__scrut, &mut __b) {
                                            return {
                                                let f = (def_rootsFromList__ee547cd5b363c1d2(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            };
                                        }
                                    }

                                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                });
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_tree_rootsFromList__c1210f7a01ba4893(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |parentIdFn: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
                let idFn = idFn.clone();
                let parentIdFn = parentIdFn.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |accRev: Value, rt: &mut Runtime| {
                    let idFn = idFn.clone();
                    let items = items.clone();
                    let parentIdFn = parentIdFn.clone();
                    (aivi_ok(items.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return {
                                    let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let rest = __b.remove("rest").expect("pattern binder");
                                let x = __b.remove("x").expect("pattern binder");
                                return ({
                                    let f = (aivi_ok(parentIdFn.clone()))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(x.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }).and_then(|__scrut| {
                                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                                true
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_0(&__scrut, &mut __b) {
                                            return {
                                                let f = (def_rootsFromList__ee547cd5b363c1d2(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                                rt.call(f, __aivi_call_args)
                                            };
                                        }
                                    }

                                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                                let v0 = &args[0];
                                                if !(true) { return false; }
                                                true
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_1(&__scrut, &mut __b) {
                                            return {
                                                let f = (def_rootsFromList__ee547cd5b363c1d2(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                                __aivi_call_args.push((aivi_ok(parentIdFn.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            };
                                        }
                                    }

                                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                });
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_buildTree__f2a40a4665f91dff(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |id: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |item: Value, rt: &mut Runtime| {
                let id = id.clone();
                let idFn = idFn.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |childrenMap: Value, rt: &mut Runtime| {
                    let id = id.clone();
                    let idFn = idFn.clone();
                    let item = item.clone();
                    {
                        let __v = ({
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(id.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        })?;
                        let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                        let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                {
                                    use Value::*;
                                    { b.insert("children", v.clone()); true }
                                }

                        })(&__v, &mut __b0);
                        if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                        let children = __b0.remove("children").expect("pattern binder");
                        {
                            let f = (aivi_ok(Value::Constructor { name: "Node".to_string(), args: Vec::new() }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(item.clone()))?);
                            __aivi_call_args.push(({
                                let f = (def_buildForest__bba2ff23d65fcf9e(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                __aivi_call_args.push((aivi_ok(children.clone()))?);
                                __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        }
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_tree_buildTree__95e242bd8776fdce(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |id: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |item: Value, rt: &mut Runtime| {
                let id = id.clone();
                let idFn = idFn.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |childrenMap: Value, rt: &mut Runtime| {
                    let id = id.clone();
                    let idFn = idFn.clone();
                    let item = item.clone();
                    {
                        let __v = ({
                            let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(id.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        })?;
                        let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                        let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                {
                                    use Value::*;
                                    { b.insert("children", v.clone()); true }
                                }

                        })(&__v, &mut __b0);
                        if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                        let children = __b0.remove("children").expect("pattern binder");
                        {
                            let f = (aivi_ok(Value::Constructor { name: "Node".to_string(), args: Vec::new() }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(item.clone()))?);
                            __aivi_call_args.push(({
                                let f = (def_buildForest__bba2ff23d65fcf9e(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                __aivi_call_args.push((aivi_ok(children.clone()))?);
                                __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        }
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_buildForest__bba2ff23d65fcf9e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |childrenMap: Value, rt: &mut Runtime| {
                let idFn = idFn.clone();
                let items = items.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |accRev: Value, rt: &mut Runtime| {
                    let childrenMap = childrenMap.clone();
                    let idFn = idFn.clone();
                    let items = items.clone();
                    (aivi_ok(items.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return {
                                    let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let rest = __b.remove("rest").expect("pattern binder");
                                let x = __b.remove("x").expect("pattern binder");
                                return {
                                    let __v = ({
                                        let f = (aivi_ok(idFn.clone()))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(x.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("id", v.clone()); true }
                                            }

                                    })(&__v, &mut __b0);
                                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let id = __b0.remove("id").expect("pattern binder");
                                    let __v = ({
                                        let f = (def_buildTree__f2a40a4665f91dff(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                        __aivi_call_args.push((aivi_ok(id.clone()))?);
                                        __aivi_call_args.push((aivi_ok(x.clone()))?);
                                        __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("childTree", v.clone()); true }
                                            }

                                    })(&__v, &mut __b1);
                                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let childTree = __b1.remove("childTree").expect("pattern binder");
                                    {
                                        let f = (def_buildForest__bba2ff23d65fcf9e(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(childTree.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                        rt.call(f, __aivi_call_args)
                                    }
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_tree_buildForest__c8420159ca8d963b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |idFn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
            let idFn = idFn.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |childrenMap: Value, rt: &mut Runtime| {
                let idFn = idFn.clone();
                let items = items.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |accRev: Value, rt: &mut Runtime| {
                    let childrenMap = childrenMap.clone();
                    let idFn = idFn.clone();
                    let items = items.clone();
                    (aivi_ok(items.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return {
                                    let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(accRev.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                };
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("x", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let rest = __b.remove("rest").expect("pattern binder");
                                let x = __b.remove("x").expect("pattern binder");
                                return {
                                    let __v = ({
                                        let f = (aivi_ok(idFn.clone()))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(x.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("id", v.clone()); true }
                                            }

                                    })(&__v, &mut __b0);
                                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let id = __b0.remove("id").expect("pattern binder");
                                    let __v = ({
                                        let f = (def_buildTree__f2a40a4665f91dff(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                        __aivi_call_args.push((aivi_ok(id.clone()))?);
                                        __aivi_call_args.push((aivi_ok(x.clone()))?);
                                        __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?;
                                    let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                    let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                            {
                                                use Value::*;
                                                { b.insert("childTree", v.clone()); true }
                                            }

                                    })(&__v, &mut __b1);
                                    if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                                    let childTree = __b1.remove("childTree").expect("pattern binder");
                                    {
                                        let f = (def_buildForest__bba2ff23d65fcf9e(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(idFn.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        __aivi_call_args.push((aivi_ok(childrenMap.clone()))?);
                                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(childTree.clone()))?]); out.extend({ let v = (aivi_ok(accRev.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                        rt.call(f, __aivi_call_args)
                                    }
                                };
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    })
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_pi__08d53f07b5755532(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("pi").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_pi__46afab18e8000fd3(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("pi").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_tau__56d7bd194448c389(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("tau").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_tau__3d9e15524a6118ce(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("tau").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_e__af63d84c8601e5c0(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("e").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_e__921cf494f2ff5657(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("e").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_inf__2ba00d192bd4e008(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("inf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_inf__5302a151c5497893(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("inf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_negInf__6daa59f032877b4c(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("negInf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_negInf__c93939fb7cb36ead(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("negInf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_nan__212bdc19256738ba(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("nan").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_nan__7e337651ddb77c45(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("nan").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_phi__77b2591956620fe4(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("phi").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_phi__1c8c51523818460b(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("phi").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_sqrt2__ce33e495d24702e7(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sqrt2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_sqrt2__8914e53fd19e5c2c(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sqrt2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_ln2__125448191db2f3f7(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ln2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_ln2__6f47ee51d5f2a2dc(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ln2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_ln10__d82dcfad771754ae(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ln10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_math_ln10__09e6d30e8b5313bf(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ln10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_radians__223c4f5cf7037461(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("radians".to_string(), (aivi_ok(value.clone()))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_math_radians__81586285d2d74d56(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("radians".to_string(), (aivi_ok(value.clone()))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_degrees__2566cc910de1dbce(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("radians".to_string(), ((aivi_ok(value.clone())).and_then(|l| ((def_pi__08d53f07b5755532(rt)).and_then(|l| (aivi_ok(Value::Float(180.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_math_degrees__7c1cc948fca649a1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("radians".to_string(), ((aivi_ok(value.clone())).and_then(|l| ((def_pi__08d53f07b5755532(rt)).and_then(|l| (aivi_ok(Value::Float(180.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_toRadians__ec0721af4b3197fa(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        (aivi_ok(angle.clone())).and_then(|b| match b { Value::Record(map) => map.get("radians").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_aivi_math_toRadians__66df6893dea599c5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        (aivi_ok(angle.clone())).and_then(|b| match b { Value::Record(map) => map.get("radians").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_toDegrees__a0603d65f732569d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        ((aivi_ok(angle.clone())).and_then(|b| match b { Value::Record(map) => map.get("radians").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(Value::Float(180.0))).and_then(|l| (def_pi__08d53f07b5755532(rt)).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
    }) })))
}

fn def_aivi_math_toDegrees__ac25ca69e21815da(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        ((aivi_ok(angle.clone())).and_then(|b| match b { Value::Record(map) => map.get("radians").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(Value::Float(180.0))).and_then(|l| (def_pi__08d53f07b5755532(rt)).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))
    }) })))
}

fn def_abs__e71fb2190541727b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("abs").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_abs__9ab20451ee90da48(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("abs").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_sign__4e0f7f18e637a364(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sign").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_sign__4e0f7f18e637a364_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sign").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_sign__d153bccd62ba7d39(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sign").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_copysign__83cba2532c76a005(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |mag: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sign: Value, rt: &mut Runtime| {
            let mag = mag.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("copysign").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(mag.clone()))?);
                __aivi_call_args.push((aivi_ok(sign.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_copysign__83cba2532c76a005_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |mag: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let mag = mag.clone();
            Box::new(move |sign: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let mag = Value::Float(mag.clone());
                let sign = Value::Float(sign.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("copysign").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(mag.clone()))?);
                    __aivi_call_args.push((aivi_ok(sign.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_copysign__cfcbcee5c9b87ba4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |mag: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sign: Value, rt: &mut Runtime| {
            let mag = mag.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("copysign").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(mag.clone()))?);
                __aivi_call_args.push((aivi_ok(sign.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_min__07f4431917564077(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("min").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_min__07f4431917564077_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |a: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let a = a.clone();
            Box::new(move |b: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let a = Value::Float(a.clone());
                let b = Value::Float(b.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("min").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(a.clone()))?);
                    __aivi_call_args.push((aivi_ok(b.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_min__771b4b51da24b3a4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("min").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_max__080f5119176d1ff9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("max").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_max__080f5119176d1ff9_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |a: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let a = a.clone();
            Box::new(move |b: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let a = Value::Float(a.clone());
                let b = Value::Float(b.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("max").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(a.clone()))?);
                    __aivi_call_args.push((aivi_ok(b.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_max__77365951da3b9326(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("max").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_minAll__1ef934bef2d2e872(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("minAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_minAll__6ff40b0b09963f7f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("minAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_maxAll__45c8ccf76ab62720(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("maxAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_maxAll__9656ab43811cb9e5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("maxAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_clamp__7e6a71555b1ce027(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |low: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |high: Value, rt: &mut Runtime| {
            let low = low.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
                let high = high.clone();
                let low = low.clone();
                {
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("clamp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(low.clone()))?);
                    __aivi_call_args.push((aivi_ok(high.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_sum__82719e195d0fc4a8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sum").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_sum__82719e195d0fc4a8_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(Vec<f64>, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |values: Vec<f64>, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let values = Value::List(Arc::new(values.clone().into_iter().map(|e| Value::Float(e)).collect()));
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sum").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(values.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_sum__360af05246654b23(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sum").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_sumInt__7eef8094f9a78589(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sumInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_sumInt__7eef8094f9a78589_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(Vec<i64>, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |values: Vec<i64>, rt: &mut aivi_native_runtime::Runtime| -> Result<i64, RuntimeError> {
            Ok((match ({
            let values = Value::List(Arc::new(values.clone().into_iter().map(|e| Value::Int(e)).collect()));
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sumInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(values.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_sumInt__dc63b1623c0f042c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sumInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_floor__a03a74a942db43bd(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("floor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_floor__a03a74a942db43bd_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("floor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_floor__07bcbe9052010fde(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("floor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_ceil__d9951890fd6d7e88(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ceil").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_ceil__d9951890fd6d7e88_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ceil").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_ceil__593c3a4576ddbd59(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ceil").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_trunc__8c28a4a7272b50a5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("trunc").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_trunc__8c28a4a7272b50a5_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("trunc").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_trunc__1343e966bc380176(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("trunc").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_round__311418469f09741b_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("round").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_round__311418469f09741b_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |places: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("round").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(places.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_round__311418469f09741b(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_round__311418469f09741b_clause_0(rt))?,
        (def_round__311418469f09741b_clause_1(rt))?,
    ]))
}

fn def_aivi_math_round__5d05aa0344721bd0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("round").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_fract__d8b2505628969d07(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("fract").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_fract__d8b2505628969d07_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("fract").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_fract__c577f324f5f3f464(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("fract").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_modf__0d3deaa2c41dabff(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("modf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_modf__0d3deaa2c41dabff_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<(f64, f64), RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<(f64, f64), RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("modf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Tuple(items) if items.len() == 2 => Ok(((match items[0].clone() { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?, (match items[1].clone() { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)), other => Err(RuntimeError::Message(format!("expected Tuple(2), got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_modf__5253f8158d69b9ae(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("modf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_frexp__fcaef6563d595694(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("frexp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_frexp__fcaef6563d595694_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<(f64, i64), RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<(f64, i64), RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("frexp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Tuple(items) if items.len() == 2 => Ok(((match items[0].clone() { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?, (match items[1].clone() { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?)), other => Err(RuntimeError::Message(format!("expected Tuple(2), got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_frexp__e9c09d250af85337(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("frexp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_ldexp__3e532e162ece13c0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |mantissa: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |exponent: Value, rt: &mut Runtime| {
            let mantissa = mantissa.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ldexp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(mantissa.clone()))?);
                __aivi_call_args.push((aivi_ok(exponent.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_ldexp__3e532e162ece13c0_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |mantissa: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let mantissa = mantissa.clone();
            Box::new(move |exponent: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let exponent = Value::Int(exponent.clone());
                let mantissa = Value::Float(mantissa.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ldexp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(mantissa.clone()))?);
                    __aivi_call_args.push((aivi_ok(exponent.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_ldexp__807584e88a7200a7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |mantissa: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |exponent: Value, rt: &mut Runtime| {
            let mantissa = mantissa.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ldexp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(mantissa.clone()))?);
                __aivi_call_args.push((aivi_ok(exponent.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_pow__779b5f19564f3b35(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |base: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |exp: Value, rt: &mut Runtime| {
            let base = base.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("pow").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(base.clone()))?);
                __aivi_call_args.push((aivi_ok(exp.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_pow__779b5f19564f3b35_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |base: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let base = base.clone();
            Box::new(move |exp: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let base = Value::Float(base.clone());
                let exp = Value::Float(exp.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("pow").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(base.clone()))?);
                    __aivi_call_args.push((aivi_ok(exp.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_pow__1ca45f52382cefb6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |base: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |exp: Value, rt: &mut Runtime| {
            let base = base.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("pow").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(base.clone()))?);
                __aivi_call_args.push((aivi_ok(exp.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_sqrt__9614cf190fc8d7cf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sqrt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_sqrt__9614cf190fc8d7cf_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sqrt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_sqrt__157e0ccd8903e516(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sqrt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_cbrt__9bd1e590da2028d6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("cbrt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_cbrt__9bd1e590da2028d6_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("cbrt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_cbrt__51c1154572f6818f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("cbrt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_hypot__df3ef727d53e7f25(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
            let x = x.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("hypot").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(x.clone()))?);
                __aivi_call_args.push((aivi_ok(y.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_hypot__df3ef727d53e7f25_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |x: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let x = x.clone();
            Box::new(move |y: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let x = Value::Float(x.clone());
                let y = Value::Float(y.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("hypot").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(x.clone()))?);
                    __aivi_call_args.push((aivi_ok(y.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_hypot__8f5e9c039d45c36a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
            let x = x.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("hypot").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(x.clone()))?);
                __aivi_call_args.push((aivi_ok(y.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_exp__c3120b18f0704408(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("exp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_exp__c3120b18f0704408_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("exp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_exp__bb90af5200ae28f7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("exp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_exp2__e7ed15608ec3ee8e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("exp2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_exp2__e7ed15608ec3ee8e_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("exp2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_exp2__6502ad5727ef46bf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("exp2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_expm1__dc5c1212976a9caa(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("expm1").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_expm1__dc5c1212976a9caa_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("expm1").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_expm1__92411918db18f52d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("expm1").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_log__125073191daf5431_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_log__125073191daf5431_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("log").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_log__125073191daf5431(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_log__125073191daf5431_clause_0(rt))?,
        (def_log__125073191daf5431_clause_1(rt))?,
    ]))
}

fn def_aivi_math_log__6f4b4b51d5f576ba(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_log10__029c1fb6e090c590(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_log10__029c1fb6e090c590_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_log10__5e587ebed982ebb3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log10").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_log2__ce0796ad70ebc119(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_log2__ce0796ad70ebc119_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_log2__1267840e90186918(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_log1p__029c5fb6e0913250(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log1p").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_log1p__029c5fb6e0913250_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log1p").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_log1p__5e58bebed9835873(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("log1p").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_sin__8248a1195cecc4ad(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sin").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(angle.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_sin__35e1f152464247c2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sin").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(angle.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_cos__f604fc190d0176dc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("cos").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(angle.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_cos__a9ab5651f661954b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("cos").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(angle.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_tan__56d7b2194448b0d8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("tan").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(angle.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_tan__3d9dfc524a60ee53(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |angle: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("tan").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(angle.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_asin__90174c8442111426(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("asin").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_asin__ef020638a9815c87(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("asin").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_acos__072bc983f4fcebbf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("acos").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_acos__663161385c83c212(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("acos").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_atan__52bd2f841f1cccdf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("atan").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_atan__2c920338cca2fcde(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("atan").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_atan2__b444aa80ddf036b7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
            let y = y.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("atan2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(y.clone()))?);
                __aivi_call_args.push((aivi_ok(x.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_math_atan2__5f186583b8f3c504(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |y: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
            let y = y.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("atan2").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(y.clone()))?);
                __aivi_call_args.push((aivi_ok(x.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_sinh__4e2e8318e6525abf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sinh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_sinh__4e2e8318e6525abf_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sinh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_sinh__d134b8cd629fc5de(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("sinh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_cosh__0bef1291197cb3dc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("cosh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_cosh__0bef1291197cb3dc_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("cosh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_cosh__afb8d045a7d06a79(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("cosh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_tanh__d93450ef07843b10(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("tanh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_tanh__d93450ef07843b10_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("tanh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_tanh__1461fad462b4ce41(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("tanh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_asinh__e8ab52bc4305808a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("asinh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_asinh__e8ab52bc4305808a_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("asinh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_asinh__a1cd814806d0ea1d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("asinh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_acosh__2c53423949c4be55(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("acosh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_acosh__2c53423949c4be55_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("acosh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_acosh__29aaacc533e3754e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("acosh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_atanh__b4447480ddefdaf5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("atanh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_atanh__b4447480ddefdaf5_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("atanh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_atanh__5f182f83b8f36942(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("atanh").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_gcd__d4e97718fab0baa1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("gcd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_gcd__d4e97718fab0baa1_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |a: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError> {
            Ok({
            let a = a.clone();
            Box::new(move |b: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<i64, RuntimeError> {
                Ok((match ({
                let a = Value::Int(a.clone());
                let b = Value::Int(b.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("gcd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(a.clone()))?);
                    __aivi_call_args.push((aivi_ok(b.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_gcd__cddc0f520b517bba(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("gcd").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_lcm__125e89191dbbb6ef(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("lcm").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_lcm__125e89191dbbb6ef_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |a: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError> {
            Ok({
            let a = a.clone();
            Box::new(move |b: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<i64, RuntimeError> {
                Ok((match ({
                let a = Value::Int(a.clone());
                let b = Value::Int(b.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("lcm").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(a.clone()))?);
                    __aivi_call_args.push((aivi_ok(b.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_lcm__6f744151d6186ad0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("lcm").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_gcdAll__ffd19aceee165bd8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("gcdAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_gcdAll__cd1ae47f3525ed21(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("gcdAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_lcmAll__654fb083aaf5f3fa(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("lcmAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_lcmAll__9f762cc8a7eecbe3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |values: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("lcmAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(values.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_factorial__3c55039e77afe2a8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("factorial").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_math_factorial__1ec6b031c24fa59b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("factorial").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_comb__0bcd1c91195fde74(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let n = n.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("comb").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                __aivi_call_args.push((aivi_ok(k.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_math_comb__afe8ee45a7f9c135(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let n = n.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("comb").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                __aivi_call_args.push((aivi_ok(k.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_perm__dfc46a0dd71032cb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let n = n.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("perm").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                __aivi_call_args.push((aivi_ok(k.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_math_perm__0af3c9b590b91e56(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let n = n.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("perm").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(n.clone()))?);
                __aivi_call_args.push((aivi_ok(k.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_divmod__f5500b268d75475c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("divmod").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_divmod__f5500b268d75475c_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<(i64, i64), RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |a: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<(i64, i64), RuntimeError>>, RuntimeError> {
            Ok({
            let a = a.clone();
            Box::new(move |b: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<(i64, i64), RuntimeError> {
                Ok((match ({
                let a = Value::Int(a.clone());
                let b = Value::Int(b.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("divmod").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(a.clone()))?);
                    __aivi_call_args.push((aivi_ok(b.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Tuple(items) if items.len() == 2 => Ok(((match items[0].clone() { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?, (match items[1].clone() { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?)), other => Err(RuntimeError::Message(format!("expected Tuple(2), got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_divmod__ca42764cd4c5da91(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("divmod").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_modPow__40994533f2446dff(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |base: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |exp: Value, rt: &mut Runtime| {
            let base = base.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |modulus: Value, rt: &mut Runtime| {
                let base = base.clone();
                let exp = exp.clone();
                {
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("modPow").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(base.clone()))?);
                    __aivi_call_args.push((aivi_ok(exp.clone()))?);
                    __aivi_call_args.push((aivi_ok(modulus.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_modPow__40994533f2446dff_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |base: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError>>, RuntimeError> {
            Ok({
            let base = base.clone();
            Box::new(move |exp: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError> {
                Ok({
                let base = base.clone();
                let exp = exp.clone();
                Box::new(move |modulus: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<i64, RuntimeError> {
                    Ok((match ({
                    let base = Value::Int(base.clone());
                    let exp = Value::Int(exp.clone());
                    let modulus = Value::Int(modulus.clone());
                    ({
                        let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("modPow").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(base.clone()))?);
                        __aivi_call_args.push((aivi_ok(exp.clone()))?);
                        __aivi_call_args.push((aivi_ok(modulus.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?
                }) { Value::Int(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Int, got {}", aivi_native_runtime::format_value(&other)))) })?)
                })
            })
            })
        })
        })
    })
}

fn def_aivi_math_modPow__7d344bac30f85052(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |base: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |exp: Value, rt: &mut Runtime| {
            let base = base.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |modulus: Value, rt: &mut Runtime| {
                let base = base.clone();
                let exp = exp.clone();
                {
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("modPow").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(base.clone()))?);
                    __aivi_call_args.push((aivi_ok(exp.clone()))?);
                    __aivi_call_args.push((aivi_ok(modulus.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_isFinite__38172b8557eef4b6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isFinite").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_isFinite__38172b8557eef4b6_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<bool, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isFinite").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_isFinite__da95d3ac990af6e7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isFinite").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isInf__c5ef4bfa52783cf8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isInf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_isInf__c5ef4bfa52783cf8_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<bool, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isInf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_isInf__362782ac0d5a2d9b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isInf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_isNaN__baa1fafa4b526e8a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isNaN").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_isNaN__baa1fafa4b526e8a_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<bool, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isNaN").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_isNaN__618e27ac25f56f2d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("isNaN").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_nextAfter__d96cedbfe7279092(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |from: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |to: Value, rt: &mut Runtime| {
            let from = from.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("nextAfter").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(from.clone()))?);
                __aivi_call_args.push((aivi_ok(to.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_nextAfter__d96cedbfe7279092_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |from: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let from = from.clone();
            Box::new(move |to: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let from = Value::Float(from.clone());
                let to = Value::Float(to.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("nextAfter").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(from.clone()))?);
                    __aivi_call_args.push((aivi_ok(to.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_nextAfter__52706ec8e4dcda2d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |from: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |to: Value, rt: &mut Runtime| {
            let from = from.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("nextAfter").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(from.clone()))?);
                __aivi_call_args.push((aivi_ok(to.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_ulp__4ca793193e14f4ec(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ulp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_ulp__4ca793193e14f4ec_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
            Ok((match ({
            let value = Value::Float(value.clone());
            ({
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ulp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_math_ulp__4804275250c24e13(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("ulp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_fmod__cb7ba679021c39d7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("fmod").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_fmod__cb7ba679021c39d7_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |a: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let a = a.clone();
            Box::new(move |b: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let a = Value::Float(a.clone());
                let b = Value::Float(b.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("fmod").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(a.clone()))?);
                    __aivi_call_args.push((aivi_ok(b.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_fmod__87052c620c5b7a4e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("fmod").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_remainder__5fbacc195df81b58(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("remainder").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_remainder__5fbacc195df81b58_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |a: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(f64, &mut aivi_native_runtime::Runtime) -> Result<f64, RuntimeError>>, RuntimeError> {
            Ok({
            let a = a.clone();
            Box::new(move |b: f64, rt: &mut aivi_native_runtime::Runtime| -> Result<f64, RuntimeError> {
                Ok((match ({
                let a = Value::Float(a.clone());
                let b = Value::Float(b.clone());
                ({
                    let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("remainder").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(a.clone()))?);
                    __aivi_call_args.push((aivi_ok(b.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Float(v) => Ok(v), Value::Int(v) => Ok(v as f64), other => Err(RuntimeError::Message(format!("expected Float, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_math_remainder__0546db4aa5e44747(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("math"))).and_then(|b| match b { Value::Record(map) => map.get("remainder").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_parse__0c4e87a7a1f6fd8c_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("url"))).and_then(|b| match b { Value::Record(map) => map.get("parse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_parse__0c4e87a7a1f6fd8c_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |raw: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(raw.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("cleaned", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let cleaned = __b0.remove("cleaned").expect("pattern binder");
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("replaceAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("\\".to_string())))?);
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(cleaned.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("cleaned", v.clone()); true }
                    }

            })(&__v, &mut __b1);
            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let cleaned = __b1.remove("cleaned").expect("pattern binder");
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("startsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(cleaned.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b2: HashMap<&'static str, Value> = HashMap::new();
            let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("absolute", v.clone()); true }
                    }

            })(&__v, &mut __b2);
            if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let absolute = __b2.remove("absolute").expect("pattern binder");
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("split").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(cleaned.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b3: HashMap<&'static str, Value> = HashMap::new();
            let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("parts", v.clone()); true }
                    }

            })(&__v, &mut __b3);
            if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let parts = __b3.remove("parts").expect("pattern binder");
            {
                let mut map = HashMap::new();
                map.insert("absolute".to_string(), (aivi_ok(absolute.clone()))?);
                map.insert("segments".to_string(), ({
                let f = (def_normalizeSegments__eaaa92e4158a8d92(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                __aivi_call_args.push((aivi_ok(parts.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }
    }) })))
}

fn def_parse__0c4e87a7a1f6fd8c(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_parse__0c4e87a7a1f6fd8c_clause_0(rt))?,
        (def_parse__0c4e87a7a1f6fd8c_clause_1(rt))?,
    ]))
}

fn def_aivi_url_parse__55348b132b177fec(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("url"))).and_then(|b| match b { Value::Record(map) => map.get("parse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toString__c5c8cdb28370e485_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("url"))).and_then(|b| match b { Value::Record(map) => map.get("toString").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toString__c5c8cdb28370e485_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        ({
            let f = (def_isEmpty__f74d14521ba2de7e(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|c| match c { Value::Bool(true) => ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/".to_string())), Value::Bool(false) => aivi_ok(Value::Text(".".to_string())), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), Value::Bool(false) => ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("/".to_string())))?]); out.extend(vec![({
                let f = (def_joinSegments__758d268579581f23(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?]); out }))))?);
            rt.call(f, __aivi_call_args)
        }, Value::Bool(false) => {
            let f = (def_joinSegments__758d268579581f23(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_toString__c5c8cdb28370e485(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_toString__c5c8cdb28370e485_clause_0(rt))?,
        (def_toString__c5c8cdb28370e485_clause_1(rt))?,
    ]))
}

fn def_aivi_url_toString__7b7c092441050aa5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("url"))).and_then(|b| match b { Value::Record(map) => map.get("toString").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_url_filter__9387240c5ff939d7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |predicate: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |items: Value, rt: &mut Runtime| {
            let predicate = predicate.clone();
            (aivi_ok(items.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return ({
                            let f = (aivi_ok(predicate.clone()))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_filter__8ed8bca89377d4f7(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(predicate.clone()))?);
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), Value::Bool(false) => {
                            let f = (def_filter__8ed8bca89377d4f7(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(predicate.clone()))?);
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_url_append__e57c2e7ac1f40641(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(left.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(right.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            __aivi_call_args.push((aivi_ok(right.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_filterKey__3661d05f4aa34cae(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pair: Value, rt: &mut Runtime| {
            let key = key.clone();
            (aivi_ok(pair.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !({ b.insert("k", v0.clone()); true }) { return false; }
                            let v1 = &items[1];
                            if !(true) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let k = __b.remove("k").expect("pattern binder");
                        return (aivi_ok(k.clone())).and_then(|a| (aivi_ok(key.clone())).map(|b| Value::Bool(!aivi_native_runtime::values_equal(&a, &b))));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_filterKey__3661d05f4aa34cae_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn((String, String), &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |key: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn((String, String), &mut aivi_native_runtime::Runtime) -> Result<bool, RuntimeError>>, RuntimeError> {
            Ok({
            let key = key.clone();
            Box::new(move |pair: (String, String), rt: &mut aivi_native_runtime::Runtime| -> Result<bool, RuntimeError> {
                Ok((match ({
                let key = Value::Text(key.clone());
                let pair = Value::Tuple(vec![Value::Text(pair.clone().0), Value::Text(pair.clone().1)]);
                ((aivi_ok(pair.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Tuple(items) if items.len() == 2 => {
                                let v0 = &items[0];
                                if !({ b.insert("k", v0.clone()); true }) { return false; }
                                let v1 = &items[1];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            let k = __b.remove("k").expect("pattern binder");
                            return (aivi_ok(k.clone())).and_then(|a| (aivi_ok(key.clone())).map(|b| Value::Bool(!aivi_native_runtime::values_equal(&a, &b))));
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                }))?
            }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_url_filterKey__019a5346cf73934e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pair: Value, rt: &mut Runtime| {
            let key = key.clone();
            (aivi_ok(pair.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !({ b.insert("k", v0.clone()); true }) { return false; }
                            let v1 = &items[1];
                            if !(true) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let k = __b.remove("k").expect("pattern binder");
                        return (aivi_ok(k.clone())).and_then(|a| (aivi_ok(key.clone())).map(|b| Value::Bool(!aivi_native_runtime::values_equal(&a, &b))));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_url______5fa7783fa9c92567(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |_arg0: Value, rt: &mut Runtime| {
            let value = value.clone();
            (aivi_ok(_arg0.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Tuple(items) if items.len() == 2 => {
                            let v0 = &items[0];
                            if !({ b.insert("key", v0.clone()); true }) { return false; }
                            let v1 = &items[1];
                            if !({ b.insert("v", v1.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        let key = __b.remove("key").expect("pattern binder");
                        let v = __b.remove("v").expect("pattern binder");
                        return {
                            let mut map = HashMap::new();
                            match (aivi_ok(value.clone()))? { Value::Record(m) => { map.extend(m.as_ref().clone()); }, _ => return Err(RuntimeError::Message("record spread expects a record".to_string())), };
                            map.insert("query".to_string(), ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(value.clone())).and_then(|b| match b { Value::Record(map) => map.get("query").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(vec![(aivi_ok(Value::Tuple(vec![(aivi_ok(key.clone()))?, (aivi_ok(v.clone()))?])))?]))))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                            aivi_ok(Value::Record(Arc::new(map)))
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_url______5fa05c3fa9c2d725(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let mut map = HashMap::new();
                match (aivi_ok(value.clone()))? { Value::Record(m) => { map.extend(m.as_ref().clone()); }, _ => return Err(RuntimeError::Message("record spread expects a record".to_string())), };
                map.insert("query".to_string(), ({
                let f = (def_filter__8ed8bca89377d4f7(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_filterKey__3661d05f4aa34cae(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(key.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                __aivi_call_args.push(((aivi_ok(value.clone())).and_then(|b| match b { Value::Record(map) => map.get("query").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_isAbsolute__0be9e796532382ec(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        (aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_aivi_path_isAbsolute__1c8d1be47118c6ba(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        (aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_aivi_path_append__7a9dcac42f023143(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            (aivi_ok(left.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(right.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                            let f = (def_append__3e7fe942f71f1e61(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            __aivi_call_args.push((aivi_ok(right.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_path_revAppend__ddafb7d1d8d6ea8c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ys: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(ys.clone());
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let x = __b.remove("x").expect("pattern binder");
                        return {
                            let f = (def_revAppend__c7fdbeeb6c8d8a56(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = (aivi_ok(ys.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_path_reverse__cc5a7dbbdc89dad7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        {
            let f = (def_revAppend__c7fdbeeb6c8d8a56(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(xs.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_path_isEmpty__3f522f6497d4fd94(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        (aivi_ok(xs.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::Bool(true));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    true
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    return aivi_ok(Value::Bool(false));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_normalizeAcc__6da523a43d76944d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |absolute: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
            let absolute = absolute.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |segments: Value, rt: &mut Runtime| {
                let absolute = absolute.clone();
                let acc = acc.clone();
                (aivi_ok(segments.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(acc.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("s", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let rest = __b.remove("rest").expect("pattern binder");
                            let s = __b.remove("s").expect("pattern binder");
                            return (((aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text("".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Bool(true)), Value::Bool(false) => (aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text(".".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
                                let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                __aivi_call_args.push((aivi_ok(acc.clone()))?);
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }, Value::Bool(false) => ((aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text("..".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => (aivi_ok(acc.clone())).and_then(|__scrut| {
                                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::List(items) => {
                                            let items = items.as_ref();
                                            if items.len() < 0 { return false; }
                                            items.len() == 0
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_0(&__scrut, &mut __b) {
                                        return (aivi_ok(absolute.clone())).and_then(|c| match c { Value::Bool(true) => {
                                            let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        }, Value::Bool(false) => {
                                            let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("..".to_string())))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                    }
                                }

                                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::List(items) => {
                                            let items = items.as_ref();
                                            if items.len() < 1 { return false; }
                                            let v0 = &items[0];
                                            if !({ b.insert("a", v0.clone()); true }) { return false; }
                                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                                            { b.insert("accTail", (&tail).clone()); true }
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_1(&__scrut, &mut __b) {
                                        let a = __b.remove("a").expect("pattern binder");
                                        let accTail = __b.remove("accTail").expect("pattern binder");
                                        return ((aivi_ok(a.clone())).and_then(|a| (aivi_ok(Value::Text("..".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                            let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("..".to_string())))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        }, Value::Bool(false) => {
                                            let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                            __aivi_call_args.push((aivi_ok(accTail.clone()))?);
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                    }
                                }

                                Err(RuntimeError::Message("non-exhaustive match".to_string()))
                            }), Value::Bool(false) => {
                                let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(s.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_normalizeAcc__6da523a43d76944d_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(bool, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |absolute: bool, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError>>, RuntimeError> {
            Ok({
            let absolute = absolute.clone();
            Box::new(move |acc: Vec<String>, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError> {
                Ok({
                let absolute = absolute.clone();
                let acc = acc.clone();
                Box::new(move |segments: Vec<String>, rt: &mut aivi_native_runtime::Runtime| -> Result<Vec<String>, RuntimeError> {
                    Ok((match ({
                    let absolute = Value::Bool(absolute.clone());
                    let acc = Value::List(Arc::new(acc.clone().into_iter().map(|e| Value::Text(e)).collect()));
                    let segments = Value::List(Arc::new(segments.clone().into_iter().map(|e| Value::Text(e)).collect()));
                    ((aivi_ok(segments.clone())).and_then(|__scrut| {
                        fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 0 { return false; }
                                    items.len() == 0
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_0(&__scrut, &mut __b) {
                                return aivi_ok(acc.clone());
                            }
                        }

                        fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                            {
                                use Value::*;
                                match v { Value::List(items) => {
                                    let items = items.as_ref();
                                    if items.len() < 1 { return false; }
                                    let v0 = &items[0];
                                    if !({ b.insert("s", v0.clone()); true }) { return false; }
                                    let tail = Value::List(Arc::new(items[1..].to_vec()));
                                    { b.insert("rest", (&tail).clone()); true }
                                }, _ => false }
                            }
                        }

                        {
                            let mut __b: HashMap<&'static str, Value> = HashMap::new();
                            if __match_arm_1(&__scrut, &mut __b) {
                                let rest = __b.remove("rest").expect("pattern binder");
                                let s = __b.remove("s").expect("pattern binder");
                                return (((aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text("".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Bool(true)), Value::Bool(false) => (aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text(".".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
                                    let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                    __aivi_call_args.push((aivi_ok(acc.clone()))?);
                                    __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }, Value::Bool(false) => ((aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text("..".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => (aivi_ok(acc.clone())).and_then(|__scrut| {
                                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::List(items) => {
                                                let items = items.as_ref();
                                                if items.len() < 0 { return false; }
                                                items.len() == 0
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_0(&__scrut, &mut __b) {
                                            return (aivi_ok(absolute.clone())).and_then(|c| match c { Value::Bool(true) => {
                                                let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            }, Value::Bool(false) => {
                                                let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("..".to_string())))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                        }
                                    }

                                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                        {
                                            use Value::*;
                                            match v { Value::List(items) => {
                                                let items = items.as_ref();
                                                if items.len() < 1 { return false; }
                                                let v0 = &items[0];
                                                if !({ b.insert("a", v0.clone()); true }) { return false; }
                                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                                { b.insert("accTail", (&tail).clone()); true }
                                            }, _ => false }
                                        }
                                    }

                                    {
                                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                        if __match_arm_1(&__scrut, &mut __b) {
                                            let a = __b.remove("a").expect("pattern binder");
                                            let accTail = __b.remove("accTail").expect("pattern binder");
                                            return ((aivi_ok(a.clone())).and_then(|a| (aivi_ok(Value::Text("..".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                                let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("..".to_string())))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            }, Value::Bool(false) => {
                                                let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                                __aivi_call_args.push((aivi_ok(accTail.clone()))?);
                                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                                rt.call(f, __aivi_call_args)
                                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                        }
                                    }

                                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                                }), Value::Bool(false) => {
                                    let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(s.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                    __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                            }
                        }

                        Err(RuntimeError::Message("non-exhaustive match".to_string()))
                    }))?
                }) { Value::List(xs) => { let mut out = Vec::new(); for e in xs.iter().cloned() { out.push((match e { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?); } Ok(out) }, other => Err(RuntimeError::Message(format!("expected List, got {}", aivi_native_runtime::format_value(&other)))) })?)
                })
            })
            })
        })
        })
    })
}

fn def_aivi_path_normalizeAcc__63a896da6818dc0b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |absolute: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |acc: Value, rt: &mut Runtime| {
            let absolute = absolute.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |segments: Value, rt: &mut Runtime| {
                let absolute = absolute.clone();
                let acc = acc.clone();
                (aivi_ok(segments.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return aivi_ok(acc.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("s", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let rest = __b.remove("rest").expect("pattern binder");
                            let s = __b.remove("s").expect("pattern binder");
                            return (((aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text("".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Bool(true)), Value::Bool(false) => (aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text(".".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b)))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
                                let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                __aivi_call_args.push((aivi_ok(acc.clone()))?);
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }, Value::Bool(false) => ((aivi_ok(s.clone())).and_then(|a| (aivi_ok(Value::Text("..".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => (aivi_ok(acc.clone())).and_then(|__scrut| {
                                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::List(items) => {
                                            let items = items.as_ref();
                                            if items.len() < 0 { return false; }
                                            items.len() == 0
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_0(&__scrut, &mut __b) {
                                        return (aivi_ok(absolute.clone())).and_then(|c| match c { Value::Bool(true) => {
                                            let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        }, Value::Bool(false) => {
                                            let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("..".to_string())))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                    }
                                }

                                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::List(items) => {
                                            let items = items.as_ref();
                                            if items.len() < 1 { return false; }
                                            let v0 = &items[0];
                                            if !({ b.insert("a", v0.clone()); true }) { return false; }
                                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                                            { b.insert("accTail", (&tail).clone()); true }
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_1(&__scrut, &mut __b) {
                                        let a = __b.remove("a").expect("pattern binder");
                                        let accTail = __b.remove("accTail").expect("pattern binder");
                                        return ((aivi_ok(a.clone())).and_then(|a| (aivi_ok(Value::Text("..".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                                            let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("..".to_string())))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        }, Value::Bool(false) => {
                                            let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                            __aivi_call_args.push((aivi_ok(accTail.clone()))?);
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                                    }
                                }

                                Err(RuntimeError::Message("non-exhaustive match".to_string()))
                            }), Value::Bool(false) => {
                                let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(s.clone()))?]); out.extend({ let v = (aivi_ok(acc.clone()))?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))))?);
                                __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_normalizeSegments__eaaa92e4158a8d92(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |absolute: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |segments: Value, rt: &mut Runtime| {
            let absolute = absolute.clone();
            {
                let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                    __aivi_call_args.push((aivi_ok(segments.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_normalizeSegments__eaaa92e4158a8d92_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(bool, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |absolute: bool, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError> {
            Ok({
            let absolute = absolute.clone();
            Box::new(move |segments: Vec<String>, rt: &mut aivi_native_runtime::Runtime| -> Result<Vec<String>, RuntimeError> {
                Ok((match ({
                let absolute = Value::Bool(absolute.clone());
                let segments = Value::List(Arc::new(segments.clone().into_iter().map(|e| Value::Text(e)).collect()));
                ({
                    let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                        __aivi_call_args.push((aivi_ok(segments.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::List(xs) => { let mut out = Vec::new(); for e in xs.iter().cloned() { out.push((match e { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?); } Ok(out) }, other => Err(RuntimeError::Message(format!("expected List, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_path_normalizeSegments__81a6f660ff8f597c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |absolute: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |segments: Value, rt: &mut Runtime| {
            let absolute = absolute.clone();
            {
                let f = (def_reverse__c95b3c1f3263ab65(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = (def_normalizeAcc__6da523a43d76944d(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new(Vec::new()))))?);
                    __aivi_call_args.push((aivi_ok(segments.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_path_normalize__4501fba0c1ee77be(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            match (aivi_ok(p.clone()))? { Value::Record(m) => { map.extend(m.as_ref().clone()); }, _ => return Err(RuntimeError::Message("record spread expects a record".to_string())), };
            map.insert("segments".to_string(), ({
            let f = (def_normalizeSegments__eaaa92e4158a8d92(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        })?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_path_parse__c126b92b2073cb46(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |raw: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(raw.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("cleaned", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let cleaned = __b0.remove("cleaned").expect("pattern binder");
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("replaceAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("\\".to_string())))?);
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(cleaned.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("cleaned", v.clone()); true }
                    }

            })(&__v, &mut __b1);
            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let cleaned = __b1.remove("cleaned").expect("pattern binder");
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("startsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(cleaned.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b2: HashMap<&'static str, Value> = HashMap::new();
            let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("absolute", v.clone()); true }
                    }

            })(&__v, &mut __b2);
            if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let absolute = __b2.remove("absolute").expect("pattern binder");
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("split").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(cleaned.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b3: HashMap<&'static str, Value> = HashMap::new();
            let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("parts", v.clone()); true }
                    }

            })(&__v, &mut __b3);
            if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let parts = __b3.remove("parts").expect("pattern binder");
            {
                let mut map = HashMap::new();
                map.insert("absolute".to_string(), (aivi_ok(absolute.clone()))?);
                map.insert("segments".to_string(), ({
                let f = (def_normalizeSegments__eaaa92e4158a8d92(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(absolute.clone()))?);
                __aivi_call_args.push((aivi_ok(parts.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }
    }) })))
}

fn def_joinSegments__758d268579581f23(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |segments: Value, rt: &mut Runtime| {
        (aivi_ok(segments.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::Text("".to_string()));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("x", v0.clone()); true }) { return false; }
                        items.len() == 1
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let x = __b.remove("x").expect("pattern binder");
                    return aivi_ok(x.clone());
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("x", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("xs", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let x = __b.remove("x").expect("pattern binder");
                    let xs = __b.remove("xs").expect("pattern binder");
                    return {
                        let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend(vec![(aivi_ok(Value::Text("/".to_string())))?]); out.extend(vec![({
                            let f = (def_joinSegments__758d268579581f23(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?]); out }))))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

#[allow(dead_code)]
fn def_joinSegments__758d268579581f23_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(Vec<String>, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |segments: Vec<String>, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let segments = Value::List(Arc::new(segments.clone().into_iter().map(|e| Value::Text(e)).collect()));
            ((aivi_ok(segments.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::Text("".to_string()));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            items.len() == 1
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        return aivi_ok(x.clone());
                    }
                }

                fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("x", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("xs", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_2(&__scrut, &mut __b) {
                        let x = __b.remove("x").expect("pattern binder");
                        let xs = __b.remove("xs").expect("pattern binder");
                        return {
                            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend(vec![(aivi_ok(Value::Text("/".to_string())))?]); out.extend(vec![({
                                let f = (def_joinSegments__758d268579581f23(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(xs.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?]); out }))))?);
                            rt.call(f, __aivi_call_args)
                        };
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            }))?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_path_joinSegments__48164150f2b2427d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |segments: Value, rt: &mut Runtime| {
        (aivi_ok(segments.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::Text("".to_string()));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("x", v0.clone()); true }) { return false; }
                        items.len() == 1
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let x = __b.remove("x").expect("pattern binder");
                    return aivi_ok(x.clone());
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("x", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("xs", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let x = __b.remove("x").expect("pattern binder");
                    let xs = __b.remove("xs").expect("pattern binder");
                    return {
                        let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend(vec![(aivi_ok(Value::Text("/".to_string())))?]); out.extend(vec![({
                            let f = (def_joinSegments__758d268579581f23(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(xs.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?]); out }))))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_path_toString__8834f92f4d387aef(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        ({
            let f = (def_isEmpty__f74d14521ba2de7e(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|c| match c { Value::Bool(true) => ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/".to_string())), Value::Bool(false) => aivi_ok(Value::Text(".".to_string())), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), Value::Bool(false) => ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => {
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("/".to_string())))?]); out.extend(vec![({
                let f = (def_joinSegments__758d268579581f23(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?]); out }))))?);
            rt.call(f, __aivi_call_args)
        }, Value::Bool(false) => {
            let f = (def_joinSegments__758d268579581f23(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_init__f5d2afc57ab57213(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        (aivi_ok(xs.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(Vec::new())));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !(true) { return false; }
                        items.len() == 1
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(Vec::new())));
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("x", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let rest = __b.remove("rest").expect("pattern binder");
                    let x = __b.remove("x").expect("pattern binder");
                    return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                        let f = (def_init__f5d2afc57ab57213(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_path_init__2d2bc25e71e196ad(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        (aivi_ok(xs.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(Vec::new())));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !(true) { return false; }
                        items.len() == 1
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(Vec::new())));
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("x", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let rest = __b.remove("rest").expect("pattern binder");
                    let x = __b.remove("x").expect("pattern binder");
                    return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(x.clone()))?]); out.extend({ let v = ({
                        let f = (def_init__f5d2afc57ab57213(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_parent__664c41d7f144ef5d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        ({
            let f = (def_isEmpty__f74d14521ba2de7e(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|c| match c { Value::Bool(true) => aivi_ok(__builtin("None")), Value::Bool(false) => {
            let f = (aivi_ok(__builtin("Some")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let mut map = HashMap::new();
                map.insert("absolute".to_string(), ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("segments".to_string(), ({
                let f = (def_init__f5d2afc57ab57213(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            })?);
            rt.call(f, __aivi_call_args)
        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_aivi_path_parent__0dc70247cd61977b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        ({
            let f = (def_isEmpty__f74d14521ba2de7e(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|c| match c { Value::Bool(true) => aivi_ok(__builtin("None")), Value::Bool(false) => {
            let f = (aivi_ok(__builtin("Some")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let mut map = HashMap::new();
                map.insert("absolute".to_string(), ((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                map.insert("segments".to_string(), ({
                let f = (def_init__f5d2afc57ab57213(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
                aivi_ok(Value::Record(Arc::new(map)))
            })?);
            rt.call(f, __aivi_call_args)
        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_last__0456d2ad905847d9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        (aivi_ok(xs.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(__builtin("None"));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("x", v0.clone()); true }) { return false; }
                        items.len() == 1
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let x = __b.remove("x").expect("pattern binder");
                    return {
                        let f = (aivi_ok(__builtin("Some")))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(x.clone()))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !(true) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let rest = __b.remove("rest").expect("pattern binder");
                    return {
                        let f = (def_last__0456d2ad905847d9(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_path_last__bb4271885ea9b753(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        (aivi_ok(xs.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(__builtin("None"));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("x", v0.clone()); true }) { return false; }
                        items.len() == 1
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let x = __b.remove("x").expect("pattern binder");
                    return {
                        let f = (aivi_ok(__builtin("Some")))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(x.clone()))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            fn __match_arm_2(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !(true) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_2(&__scrut, &mut __b) {
                    let rest = __b.remove("rest").expect("pattern binder");
                    return {
                        let f = (def_last__0456d2ad905847d9(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_fileName__7acc2bd06d594688(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        {
            let f = (def_last__0456d2ad905847d9(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_path_fileName__2a7f4094b3517b8e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |p: Value, rt: &mut Runtime| {
        {
            let f = (def_last__0456d2ad905847d9(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((aivi_ok(p.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_path______145ff239dd42a1f9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |base: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |other: Value, rt: &mut Runtime| {
            let base = base.clone();
            ((aivi_ok(other.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|c| match c { Value::Bool(true) => aivi_ok(other.clone()), Value::Bool(false) => {
                let f = (def_normalize__eabe8385437e66cc(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let mut map = HashMap::new();
                    map.insert("absolute".to_string(), ((aivi_ok(base.clone())).and_then(|b| match b { Value::Record(map) => map.get("absolute").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    map.insert("segments".to_string(), ({
                    let f = (def_append__3e7fe942f71f1e61(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(base.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    __aivi_call_args.push(((aivi_ok(other.clone())).and_then(|b| match b { Value::Record(map) => map.get("segments").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                })?);
                    aivi_ok(Value::Record(Arc::new(map)))
                })?);
                rt.call(f, __aivi_call_args)
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }) })))
    }) })))
}

fn def_par__77ca6a195676bea8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("concurrent"))).and_then(|b| match b { Value::Record(map) => map.get("par").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_concurrency_par__43b5378f0fbfd8ae(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |left: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |right: Value, rt: &mut Runtime| {
            let left = left.clone();
            {
                let f = ((aivi_ok(__builtin("concurrent"))).and_then(|b| match b { Value::Record(map) => map.get("par").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(left.clone()))?);
                __aivi_call_args.push((aivi_ok(right.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_scope__c1074ffbe7efe44b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |run: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("concurrent"))).and_then(|b| match b { Value::Record(map) => map.get("scope").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (aivi_ok(run.clone()))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_concurrency_scope__eb1ea10442a27ea9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |run: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("concurrent"))).and_then(|b| match b { Value::Record(map) => map.get("scope").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (aivi_ok(run.clone()))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_make__1f5359a2ce9388cf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sample: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("channel"))).and_then(|b| match b { Value::Record(map) => map.get("make").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sample.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_concurrency_make__3e4df7f5365e6b61(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sample: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("channel"))).and_then(|b| match b { Value::Record(map) => map.get("make").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sample.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_send__2d1ff318d40c162f_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sender: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let sender = sender.clone();
            {
                let f = ((aivi_ok(__builtin("channel"))).and_then(|b| match b { Value::Record(map) => map.get("send").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(sender.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_send__2d1ff318d40c162f_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bytes: Value, rt: &mut Runtime| {
            let conn = conn.clone();
            {
                let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("send").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(conn.clone()))?);
                __aivi_call_args.push((aivi_ok(bytes.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_send__2d1ff318d40c162f(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_send__2d1ff318d40c162f_clause_0(rt))?,
        (def_send__2d1ff318d40c162f_clause_1(rt))?,
    ]))
}

fn def_aivi_concurrency_send__22ef17fedf9a9585(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sender: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let sender = sender.clone();
            {
                let f = ((aivi_ok(__builtin("channel"))).and_then(|b| match b { Value::Record(map) => map.get("send").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(sender.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_recv__4cec711fbfe274ad_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |receiver: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("channel"))).and_then(|b| match b { Value::Record(map) => map.get("recv").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(receiver.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_recv__4cec711fbfe274ad_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("recv").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(conn.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_recv__4cec711fbfe274ad(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_recv__4cec711fbfe274ad_clause_0(rt))?,
        (def_recv__4cec711fbfe274ad_clause_1(rt))?,
    ]))
}

fn def_aivi_concurrency_recv__8689ea05f16c03ff(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |receiver: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("channel"))).and_then(|b| match b { Value::Record(map) => map.get("recv").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(receiver.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_close__9ec2699513c0f9c3_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sender: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("channel"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sender.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_close__9ec2699513c0f9c3_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_close__9ec2699513c0f9c3_clause_2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |handle: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(handle.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_close__9ec2699513c0f9c3_clause_3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(conn.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_close__9ec2699513c0f9c3(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_close__9ec2699513c0f9c3_clause_0(rt))?,
        (def_close__9ec2699513c0f9c3_clause_1(rt))?,
        (def_close__9ec2699513c0f9c3_clause_2(rt))?,
        (def_close__9ec2699513c0f9c3_clause_3(rt))?,
    ]))
}

fn def_aivi_concurrency_close__829b91e0886795c9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |sender: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("channel"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(sender.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_console_log__a585ede0a21a1ab9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("log").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_println__776357686c3fa546(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("println").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_console_println__172704988bde2a4e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("println").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_print__2f0792248c7d6068(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("print").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_console_print__5700df49563490f0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("print").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_error__9f7452dd75d54d31(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("error").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_console_error__2ac4f01e2d646a29(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("error").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_readLine__2b9f61162513bc07(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("readLine").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_aivi_console_readLine__7c7728e1e7d230ef(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("readLine").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_color__77f5c18e246c6638(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tone: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let tone = tone.clone();
            {
                let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("color").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(tone.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_color__77f5c18e246c6638_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(__Adt_AnsiColor_8712be8f0868bd73, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |tone: __Adt_AnsiColor_8712be8f0868bd73, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
            Ok({
            let tone = tone.clone();
            Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
                Ok((match ({
                let tone = match &tone.clone() { __Adt_AnsiColor_8712be8f0868bd73::Black => Value::Constructor { name: "Black".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Red => Value::Constructor { name: "Red".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Green => Value::Constructor { name: "Green".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Yellow => Value::Constructor { name: "Yellow".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Blue => Value::Constructor { name: "Blue".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Magenta => Value::Constructor { name: "Magenta".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Cyan => Value::Constructor { name: "Cyan".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::White => Value::Constructor { name: "White".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Default => Value::Constructor { name: "Default".to_string(), args: vec![] } };
                let value = Value::Text(value.clone());
                ({
                    let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("color").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(tone.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_console_color__06c8d69c4c54beb0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tone: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let tone = tone.clone();
            {
                let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("color").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(tone.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_bgColor__b876d25043775549(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tone: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let tone = tone.clone();
            {
                let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("bgColor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(tone.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

#[allow(dead_code)]
fn def_bgColor__b876d25043775549_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(__Adt_AnsiColor_8712be8f0868bd73, &mut aivi_native_runtime::Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |tone: __Adt_AnsiColor_8712be8f0868bd73, rt: &mut aivi_native_runtime::Runtime| -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
            Ok({
            let tone = tone.clone();
            Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
                Ok((match ({
                let tone = match &tone.clone() { __Adt_AnsiColor_8712be8f0868bd73::Black => Value::Constructor { name: "Black".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Red => Value::Constructor { name: "Red".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Green => Value::Constructor { name: "Green".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Yellow => Value::Constructor { name: "Yellow".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Blue => Value::Constructor { name: "Blue".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Magenta => Value::Constructor { name: "Magenta".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Cyan => Value::Constructor { name: "Cyan".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::White => Value::Constructor { name: "White".to_string(), args: vec![] }, __Adt_AnsiColor_8712be8f0868bd73::Default => Value::Constructor { name: "Default".to_string(), args: vec![] } };
                let value = Value::Text(value.clone());
                ({
                    let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("bgColor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(tone.clone()))?);
                    __aivi_call_args.push((aivi_ok(value.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
            })
        })
        })
    })
}

fn def_aivi_console_bgColor__e3f45f9456200dc1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tone: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let tone = tone.clone();
            {
                let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("bgColor").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(tone.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_style__bf7282adbc7013f6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |attrs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let attrs = attrs.clone();
            {
                let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("style").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(attrs.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_console_style__5836a882cc8041de(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |attrs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let attrs = attrs.clone();
            {
                let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("style").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(attrs.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_strip__5e6cbcad84fd6531(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("strip").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_strip__5e6cbcad84fd6531_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("strip").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_console_strip__837c7282e5008ee9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("console"))).and_then(|b| match b { Value::Record(map) => map.get("strip").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_sha256__31c5f470214e1c5a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("crypto"))).and_then(|b| match b { Value::Record(map) => map.get("sha256").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_sha256__31c5f470214e1c5a_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |value: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let value = Value::Text(value.clone());
            ({
                let f = ((aivi_ok(__builtin("crypto"))).and_then(|b| match b { Value::Record(map) => map.get("sha256").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_crypto_sha256__380aaa33c80fa2da(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("crypto"))).and_then(|b| match b { Value::Record(map) => map.get("sha256").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_randomUuid__3251f17807325bdd(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("crypto"))).and_then(|b| match b { Value::Record(map) => map.get("randomUuid").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_aivi_crypto_randomUuid__a5a950ff72158a5d(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("crypto"))).and_then(|b| match b { Value::Record(map) => map.get("randomUuid").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_randomBytes__c346f2a348f58ca1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |count: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("crypto"))).and_then(|b| match b { Value::Record(map) => map.get("randomBytes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(count.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_crypto_randomBytes__a3ecc5bde8fd9021(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |count: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("crypto"))).and_then(|b| match b { Value::Record(map) => map.get("randomBytes").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(count.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_env__c2f01118f05367d4(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("get".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("env").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(key.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) }))))?);
        map.insert("set".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let key = key.clone();
            {
                let f = (((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("env").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("set").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(key.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) }))))?);
        map.insert("remove".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        {
            let f = (((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("env").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("remove").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(key.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) }))))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_aivi_system_env__945b1f008fef4364(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("get".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("env").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(key.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) }))))?);
        map.insert("set".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
            let key = key.clone();
            {
                let f = (((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("env").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("set").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(key.clone()))?);
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) }))))?);
        map.insert("remove".to_string(), (aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        {
            let f = (((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("env").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("remove").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(key.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) }))))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_args__894930843ebc9d7c(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("args").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_aivi_system_args__eafe2117d9617a8c(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("args").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_localeTag__b51b979f1a681b3d(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("localeTag").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_aivi_system_localeTag__540545bf1741148d(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("localeTag").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_exit__e79e4d608e807965(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |code: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("exit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(code.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_system_exit__4a2d3df429defa35(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |code: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("system"))).and_then(|b| match b { Value::Record(map) => map.get("exit").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(code.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_configure__e1186fc07fefbd0b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |config: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("configure").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(config.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_configure__e4446bd31417903f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |config: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("configure").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(config.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_table__77203729b376a83f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |name: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |columns: Value, rt: &mut Runtime| {
            let name = name.clone();
            {
                let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("table").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(name.clone()))?);
                __aivi_call_args.push((aivi_ok(columns.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_database_table__9e500882d925eceb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |name: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |columns: Value, rt: &mut Runtime| {
            let name = name.clone();
            {
                let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("table").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(name.clone()))?);
                __aivi_call_args.push((aivi_ok(columns.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_load__ce0eecad70f271e9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("load").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_load__12709b4e0fd13b8d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("load").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_applyDelta__8c0c40877627f01b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |table: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let table = table.clone();
            {
                let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("applyDelta").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(table.clone()))?);
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_database_applyDelta__33f7e06c0cfe819f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |table: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let table = table.clone();
            {
                let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("applyDelta").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(table.clone()))?);
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_runMigrations__96d96e458eed7c8b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tables: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("runMigrations").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tables.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_runMigrations__d43368a08c4c68b7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tables: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("runMigrations").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tables.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_ins__2ba002192bd4cd57_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Insert".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_ins__2ba002192bd4cd57_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Constructor { name: "Insert".to_string(), args: Vec::new() })
}

fn def_ins__2ba002192bd4cd57(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_ins__2ba002192bd4cd57_clause_0(rt))?,
        (def_ins__2ba002192bd4cd57_clause_1(rt))?,
    ]))
}

fn def_aivi_database_ins__f24daa65e51d7fb3_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Insert".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_ins__f24daa65e51d7fb3_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Constructor { name: "Insert".to_string(), args: Vec::new() })
}

fn def_aivi_database_ins__f24daa65e51d7fb3(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_database_ins__f24daa65e51d7fb3_clause_0(rt))?,
        (def_aivi_database_ins__f24daa65e51d7fb3_clause_1(rt))?,
    ]))
}

fn def_upd__4c487f193dc43e6c_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pred: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |patchFn: Value, rt: &mut Runtime| {
            let pred = pred.clone();
            {
                let f = (aivi_ok(Value::Constructor { name: "Update".to_string(), args: Vec::new() }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(pred.clone()))?);
                __aivi_call_args.push((aivi_ok(patchFn.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_upd__4c487f193dc43e6c_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Constructor { name: "Update".to_string(), args: Vec::new() })
}

fn def_upd__4c487f193dc43e6c(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_upd__4c487f193dc43e6c_clause_0(rt))?,
        (def_upd__4c487f193dc43e6c_clause_1(rt))?,
    ]))
}

fn def_aivi_database_upd__454d876583321610_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pred: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |patchFn: Value, rt: &mut Runtime| {
            let pred = pred.clone();
            {
                let f = (aivi_ok(Value::Constructor { name: "Update".to_string(), args: Vec::new() }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(pred.clone()))?);
                __aivi_call_args.push((aivi_ok(patchFn.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_database_upd__454d876583321610_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Constructor { name: "Update".to_string(), args: Vec::new() })
}

fn def_aivi_database_upd__454d876583321610(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_database_upd__454d876583321610_clause_0(rt))?,
        (def_aivi_database_upd__454d876583321610_clause_1(rt))?,
    ]))
}

fn def_del__ca9a2418f461f5ca_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pred: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Delete".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(pred.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_del__ca9a2418f461f5ca_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Constructor { name: "Delete".to_string(), args: Vec::new() })
}

fn def_del__ca9a2418f461f5ca(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_del__ca9a2418f461f5ca_clause_0(rt))?,
        (def_del__ca9a2418f461f5ca_clause_1(rt))?,
    ]))
}

fn def_aivi_database_del__d9214c65d716f336_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pred: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Delete".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(pred.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_del__d9214c65d716f336_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Constructor { name: "Delete".to_string(), args: Vec::new() })
}

fn def_aivi_database_del__d9214c65d716f336(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_aivi_database_del__d9214c65d716f336_clause_0(rt))?,
        (def_aivi_database_del__d9214c65d716f336_clause_1(rt))?,
    ]))
}

fn def_aivi_database______2537e96723ec325b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |table: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |delta: Value, rt: &mut Runtime| {
            let table = table.clone();
            {
                let f = (def_applyDelta__8c0c40877627f01b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(table.clone()))?);
                __aivi_call_args.push((aivi_ok(delta.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_create__f74e5feadea773fd_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |config: Value, rt: &mut Runtime| {
        {
            let f = (((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("pool").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("create").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(config.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_create__f74e5feadea773fd_clause_1(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("create").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_create__f74e5feadea773fd(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_create__f74e5feadea773fd_clause_0(rt))?,
        (def_create__f74e5feadea773fd_clause_1(rt))?,
    ]))
}

fn def_aivi_database_pool_create__6e29ade6e9d2fdeb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |config: Value, rt: &mut Runtime| {
        {
            let f = (((aivi_ok(__builtin("database"))).and_then(|b| match b { Value::Record(map) => map.get("pool").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("create").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(config.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_acquire__2f9e1731fe4a04d3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("acquire").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_pool_acquire__ad706cae6020d9a5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("acquire").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_release__a63d4c9b882b10fe(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
            let pool = pool.clone();
            {
                let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("release").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(conn.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_database_pool_release__68f196f1a679c888(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
            let pool = pool.clone();
            {
                let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("release").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(conn.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_stats__ee639cad45b1994c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("stats").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_pool_stats__04d91ac40b712466(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("stats").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_drain__16749dc90dc393b9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("drain").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_pool_drain__038d137b0badd1bb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("drain").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_database_pool_close__4fa725820ac4b8e1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_withConn__e73e20651b2d30fb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |run: Value, rt: &mut Runtime| {
            let pool = pool.clone();
            {
                let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("withConn").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(run.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_database_pool_withConn__06a20aaaa7a14ee5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |pool: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |run: Value, rt: &mut Runtime| {
            let pool = pool.clone();
            {
                let f = ((aivi_ok(pool.clone())).and_then(|b| match b { Value::Record(map) => map.get("withConn").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(run.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_open__f84f97b4633670e9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let path = path.clone();
            aivi_ok(Value::Resource(Arc::new(ResourceValue {
                acquire: Mutex::new(Some(Box::new(move |rt: &mut Runtime| {
                    let __e = ({
                        let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("open").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(path.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let __v = rt.run_effect_value(__e)?;
                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("handle", v.clone()); true }
                            }

                    })(&__v, &mut __b0);
                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                    let handle = __b0.remove("handle").expect("pattern binder");
                    let __value = (aivi_ok(handle.clone()))?;
                    let __cleanup = Value::Effect(Arc::new(EffectValue::Thunk {
                        func: Arc::new(move |rt: &mut Runtime| {
                            let __e = ({
                                let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(handle.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let __v = rt.run_effect_value(__e)?;
                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        true
                                    }

                            })(&__v, &mut __b1);
                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed in resource cleanup bind".to_string())); }
                            Ok(Value::Unit)
                        }),
                    }));
                    return Ok((__value, __cleanup));
                    let __e = ({
                        let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(handle.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let __v = rt.run_effect_value(__e)?;
                    let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                    let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                true
                            }

                    })(&__v, &mut __b2);
                    if !__ok2 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                    Err(RuntimeError::Message("resource block missing yield".to_string()))
                }))),
            })))
        }
    }) })))
}

fn def_aivi_file_open__6b6c4c1d28e83168(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let path = path.clone();
            aivi_ok(Value::Resource(Arc::new(ResourceValue {
                acquire: Mutex::new(Some(Box::new(move |rt: &mut Runtime| {
                    let __e = ({
                        let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("open").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(path.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let __v = rt.run_effect_value(__e)?;
                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("handle", v.clone()); true }
                            }

                    })(&__v, &mut __b0);
                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                    let handle = __b0.remove("handle").expect("pattern binder");
                    let __value = (aivi_ok(handle.clone()))?;
                    let __cleanup = Value::Effect(Arc::new(EffectValue::Thunk {
                        func: Arc::new(move |rt: &mut Runtime| {
                            let __e = ({
                                let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(handle.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let __v = rt.run_effect_value(__e)?;
                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        true
                                    }

                            })(&__v, &mut __b1);
                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed in resource cleanup bind".to_string())); }
                            Ok(Value::Unit)
                        }),
                    }));
                    return Ok((__value, __cleanup));
                    let __e = ({
                        let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(handle.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let __v = rt.run_effect_value(__e)?;
                    let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                    let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                true
                            }

                    })(&__v, &mut __b2);
                    if !__ok2 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                    Err(RuntimeError::Message("resource block missing yield".to_string()))
                }))),
            })))
        }
    }) })))
}

fn def_readAll__8eecef18ac146ba4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |handle: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("attempt")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("readAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(handle.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_file_readAll__f737fcef022deacf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |handle: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("attempt")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("readAll").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(handle.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_file_close__56bec0df6197c924(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |handle: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(handle.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_readText__6658b057d559a37e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("attempt")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (aivi_ok(__builtin("load")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("read").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_file_readText__de265b732d59a443(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("attempt")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = (aivi_ok(__builtin("load")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("read").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_writeText__30b2f0a0b80c649b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |contents: Value, rt: &mut Runtime| {
            let path = path.clone();
            {
                let f = (aivi_ok(__builtin("attempt")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("write_text").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    __aivi_call_args.push((aivi_ok(contents.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_file_writeText__0e2fca82b402a9d8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |contents: Value, rt: &mut Runtime| {
            let path = path.clone();
            {
                let f = (aivi_ok(__builtin("attempt")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("write_text").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    __aivi_call_args.push((aivi_ok(contents.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_exists__732d8bd38ff9851d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("exists").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(path.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_file_exists__a4055ce813efc6c0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("exists").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(path.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_stat__aefd5a191d95e3f7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("attempt")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("stat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(path.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_file_stat__502492406e939892(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("attempt")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("stat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(path.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_delete__f3fe6b5fdb85d50a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("attempt")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("delete").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(path.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_file_delete__a225fda22810253b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("attempt")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("delete").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(path.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_parseLocale__e84360b25ee6d816(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tag: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("parseLocale").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tag.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_i18n_parseLocale__f4f1cc0bcaf1756b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tag: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("parseLocale").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tag.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_key__3dc94a19365b10ec(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |text: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("key").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(text.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_i18n_key__ca52efe0410a2bbd(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |text: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("key").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(text.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_message__546401b5d2a8d2a4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |text: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("message").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(text.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_i18n_message__478cbed4cfc5f2c5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |text: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("message").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(text.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_render__393ee15f7d35d08d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
            let msg = msg.clone();
            {
                let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("render").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(msg.clone()))?);
                __aivi_call_args.push((aivi_ok(args.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_i18n_render__40d026e93911414a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
            let msg = msg.clone();
            {
                let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("render").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(msg.clone()))?);
                __aivi_call_args.push((aivi_ok(args.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_bundleFromProperties__901cda180e8bc28c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |props: Value, rt: &mut Runtime| {
            let locale = locale.clone();
            {
                let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("bundleFromProperties").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(locale.clone()))?);
                __aivi_call_args.push((aivi_ok(props.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_i18n_bundleFromProperties__fb84648055fd776f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |props: Value, rt: &mut Runtime| {
            let locale = locale.clone();
            {
                let f = ((aivi_ok(__builtin("i18n"))).and_then(|b| match b { Value::Record(map) => map.get("bundleFromProperties").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(locale.clone()))?);
                __aivi_call_args.push((aivi_ok(props.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_bundleFromPropertiesFile__ef0eb4fe8a5e815a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
            let locale = locale.clone();
            aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
                func: Arc::new(move |rt: &mut Runtime| {
                    let mut __cleanups: Vec<Value> = Vec::new();
                    let locale = locale.clone();
                    let path = path.clone();
                    let __result: R = {
                            let __tmp = ({
                            let f = (aivi_ok(__builtin("attempt")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(__builtin("load")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("read").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        })?;
                            let __v = match __tmp {
                                Value::Resource(res) => {
                                    let (v, cleanup) = rt.acquire_resource(res)?;
                                    __cleanups.push(cleanup);
                                    v
                                }
                                Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                other => other,
                            };
                        let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                        let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                {
                                    use Value::*;
                                    { b.insert("res", v.clone()); true }
                                }

                        })(&__v, &mut __b0);
                        if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                        let res = __b0.remove("res").expect("pattern binder");
                            let __e = ((aivi_ok(res.clone())).and_then(|__scrut| {
                            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !({ b.insert("e", v0.clone()); true }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_0(&__scrut, &mut __b) {
                                    let e = __b.remove("e").expect("pattern binder");
                                    return {
                                        let f = (aivi_ok(__builtin("pure")))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = (aivi_ok(__builtin("Err")))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !({ b.insert("txt", v0.clone()); true }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_1(&__scrut, &mut __b) {
                                    let txt = __b.remove("txt").expect("pattern binder");
                                    return {
                                        let f = (aivi_ok(__builtin("pure")))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = (def_bundleFromProperties__901cda180e8bc28c(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(locale.clone()))?);
                                            __aivi_call_args.push((aivi_ok(txt.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            Err(RuntimeError::Message("non-exhaustive match".to_string()))
                        }))?;
                            rt.run_effect_value(__e)
                    };
                    let __cleanup_result: Result<(), RuntimeError> = (|| {
                            for cleanup in __cleanups.into_iter().rev() {
                                let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                            }
                            Ok(())
                    })();
                    match (__result, __cleanup_result) {
                            (Err(err), _) => Err(err),
                            (Ok(_), Err(err)) => Err(err),
                            (Ok(v), Ok(())) => Ok(v),
                    }
                }),
            })))
        }) })))
    }) })))
}

fn def_aivi_i18n_bundleFromPropertiesFile__33f9e6a0bacf9ea1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
            let locale = locale.clone();
            aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
                func: Arc::new(move |rt: &mut Runtime| {
                    let mut __cleanups: Vec<Value> = Vec::new();
                    let locale = locale.clone();
                    let path = path.clone();
                    let __result: R = {
                            let __tmp = ({
                            let f = (aivi_ok(__builtin("attempt")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (aivi_ok(__builtin("load")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("file"))).and_then(|b| match b { Value::Record(map) => map.get("read").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        })?;
                            let __v = match __tmp {
                                Value::Resource(res) => {
                                    let (v, cleanup) = rt.acquire_resource(res)?;
                                    __cleanups.push(cleanup);
                                    v
                                }
                                Value::Effect(_) => rt.run_effect_value(__tmp)?,
                                other => other,
                            };
                        let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                        let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                {
                                    use Value::*;
                                    { b.insert("res", v.clone()); true }
                                }

                        })(&__v, &mut __b0);
                        if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                        let res = __b0.remove("res").expect("pattern binder");
                            let __e = ((aivi_ok(res.clone())).and_then(|__scrut| {
                            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !({ b.insert("e", v0.clone()); true }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_0(&__scrut, &mut __b) {
                                    let e = __b.remove("e").expect("pattern binder");
                                    return {
                                        let f = (aivi_ok(__builtin("pure")))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = (aivi_ok(__builtin("Err")))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(e.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !({ b.insert("txt", v0.clone()); true }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_1(&__scrut, &mut __b) {
                                    let txt = __b.remove("txt").expect("pattern binder");
                                    return {
                                        let f = (aivi_ok(__builtin("pure")))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push(({
                                            let f = (def_bundleFromProperties__901cda180e8bc28c(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(locale.clone()))?);
                                            __aivi_call_args.push((aivi_ok(txt.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        })?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            Err(RuntimeError::Message("non-exhaustive match".to_string()))
                        }))?;
                            rt.run_effect_value(__e)
                    };
                    let __cleanup_result: Result<(), RuntimeError> = (|| {
                            for cleanup in __cleanups.into_iter().rev() {
                                let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                            }
                            Ok(())
                    })();
                    match (__result, __cleanup_result) {
                            (Err(err), _) => Err(err),
                            (Ok(_), Err(err)) => Err(err),
                            (Ok(v), Ok(())) => Ok(v),
                    }
                }),
            })))
        }) })))
    }) })))
}

fn def_keyText__5ea31d6ba507902b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
        (aivi_ok(k.clone())).and_then(|b| match b { Value::Record(map) => map.get("body").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_aivi_i18n_keyText__d0e1a7e9e3b165e6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
        (aivi_ok(k.clone())).and_then(|b| match b { Value::Record(map) => map.get("body").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_messageText__d6312d0014ec3af3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        (aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("body").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_aivi_i18n_messageText__2b3ad01d3343bc3e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |m: Value, rt: &mut Runtime| {
        (aivi_ok(m.clone())).and_then(|b| match b { Value::Record(map) => map.get("body").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_tResult__aee08636d304a1aa(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let bundle = bundle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                let bundle = bundle.clone();
                let k = k.clone();
                ({
                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_keyText__5ea31d6ba507902b(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(k.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    __aivi_call_args.push(((aivi_ok(bundle.clone())).and_then(|b| match b { Value::Record(map) => map.get("entries").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = (aivi_ok(__builtin("Err")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("missing key: ".to_string())))?]); out.extend(vec![({
                                        let f = (def_keyText__5ea31d6ba507902b(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(k.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?]); out }))))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("msg", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let msg = __b.remove("msg").expect("pattern binder");
                            return {
                                let f = (def_render__393ee15f7d35d08d(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(msg.clone()))?);
                                __aivi_call_args.push((aivi_ok(args.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_i18n_tResult__ad3cc9d1c0c1407f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let bundle = bundle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                let bundle = bundle.clone();
                let k = k.clone();
                ({
                    let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_keyText__5ea31d6ba507902b(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(k.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    __aivi_call_args.push(((aivi_ok(bundle.clone())).and_then(|b| match b { Value::Record(map) => map.get("entries").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = (aivi_ok(__builtin("Err")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("missing key: ".to_string())))?]); out.extend(vec![({
                                        let f = (def_keyText__5ea31d6ba507902b(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(k.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?]); out }))))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("msg", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let msg = __b.remove("msg").expect("pattern binder");
                            return {
                                let f = (def_render__393ee15f7d35d08d(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(msg.clone()))?);
                                __aivi_call_args.push((aivi_ok(args.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_tOpt__460c06efd675feb8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let bundle = bundle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                let bundle = bundle.clone();
                let k = k.clone();
                ({
                    let f = (def_tResult__aee08636d304a1aa(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(bundle.clone()))?);
                    __aivi_call_args.push((aivi_ok(k.clone()))?);
                    __aivi_call_args.push((aivi_ok(args.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("txt", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            let txt = __b.remove("txt").expect("pattern binder");
                            return {
                                let f = (aivi_ok(__builtin("Some")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(txt.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return aivi_ok(__builtin("None"));
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_i18n_tOpt__24fc2937bd7a6cff(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let bundle = bundle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                let bundle = bundle.clone();
                let k = k.clone();
                ({
                    let f = (def_tResult__aee08636d304a1aa(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(bundle.clone()))?);
                    __aivi_call_args.push((aivi_ok(k.clone()))?);
                    __aivi_call_args.push((aivi_ok(args.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("txt", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            let txt = __b.remove("txt").expect("pattern binder");
                            return {
                                let f = (aivi_ok(__builtin("Some")))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(txt.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return aivi_ok(__builtin("None"));
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_t__af63e94c860202a3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let bundle = bundle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                let bundle = bundle.clone();
                let k = k.clone();
                ({
                    let f = (def_tResult__aee08636d304a1aa(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(bundle.clone()))?);
                    __aivi_call_args.push((aivi_ok(k.clone()))?);
                    __aivi_call_args.push((aivi_ok(args.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("txt", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            let txt = __b.remove("txt").expect("pattern binder");
                            return aivi_ok(txt.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return {
                                let f = (def_keyText__5ea31d6ba507902b(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(k.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_i18n_t__78e7f1ff1ed63996(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundle: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let bundle = bundle.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                let bundle = bundle.clone();
                let k = k.clone();
                ({
                    let f = (def_tResult__aee08636d304a1aa(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(bundle.clone()))?);
                    __aivi_call_args.push((aivi_ok(k.clone()))?);
                    __aivi_call_args.push((aivi_ok(args.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Ok" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("txt", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            let txt = __b.remove("txt").expect("pattern binder");
                            return aivi_ok(txt.clone());
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Err" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !(true) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return {
                                let f = (def_keyText__5ea31d6ba507902b(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(k.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_tWithFallback__6a82e199a989d5f1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundles: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let bundles = bundles.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                let bundles = bundles.clone();
                let k = k.clone();
                (aivi_ok(bundles.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = (def_keyText__5ea31d6ba507902b(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(k.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("b", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let b = __b.remove("b").expect("pattern binder");
                            let rest = __b.remove("rest").expect("pattern binder");
                            return ({
                                let f = (def_tOpt__460c06efd675feb8(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(b.clone()))?);
                                __aivi_call_args.push((aivi_ok(k.clone()))?);
                                __aivi_call_args.push((aivi_ok(args.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }).and_then(|__scrut| {
                                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                            let v0 = &args[0];
                                            if !({ b.insert("txt", v0.clone()); true }) { return false; }
                                            true
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_0(&__scrut, &mut __b) {
                                        let txt = __b.remove("txt").expect("pattern binder");
                                        return aivi_ok(txt.clone());
                                    }
                                }

                                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                            true
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_1(&__scrut, &mut __b) {
                                        return {
                                            let f = (def_tWithFallback__6a82e199a989d5f1(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            __aivi_call_args.push((aivi_ok(k.clone()))?);
                                            __aivi_call_args.push((aivi_ok(args.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        };
                                    }
                                }

                                Err(RuntimeError::Message("non-exhaustive match".to_string()))
                            });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_aivi_i18n_tWithFallback__813f339581cbc6d0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundles: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
            let bundles = bundles.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                let bundles = bundles.clone();
                let k = k.clone();
                (aivi_ok(bundles.clone())).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 0 { return false; }
                                items.len() == 0
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            return {
                                let f = (def_keyText__5ea31d6ba507902b(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(k.clone()))?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::List(items) => {
                                let items = items.as_ref();
                                if items.len() < 1 { return false; }
                                let v0 = &items[0];
                                if !({ b.insert("b", v0.clone()); true }) { return false; }
                                let tail = Value::List(Arc::new(items[1..].to_vec()));
                                { b.insert("rest", (&tail).clone()); true }
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            let b = __b.remove("b").expect("pattern binder");
                            let rest = __b.remove("rest").expect("pattern binder");
                            return ({
                                let f = (def_tOpt__460c06efd675feb8(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(b.clone()))?);
                                __aivi_call_args.push((aivi_ok(k.clone()))?);
                                __aivi_call_args.push((aivi_ok(args.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }).and_then(|__scrut| {
                                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                            let v0 = &args[0];
                                            if !({ b.insert("txt", v0.clone()); true }) { return false; }
                                            true
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_0(&__scrut, &mut __b) {
                                        let txt = __b.remove("txt").expect("pattern binder");
                                        return aivi_ok(txt.clone());
                                    }
                                }

                                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                            true
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_1(&__scrut, &mut __b) {
                                        return {
                                            let f = (def_tWithFallback__6a82e199a989d5f1(rt))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                            __aivi_call_args.push((aivi_ok(k.clone()))?);
                                            __aivi_call_args.push((aivi_ok(args.clone()))?);
                                            rt.call(f, __aivi_call_args)
                                        };
                                    }
                                }

                                Err(RuntimeError::Message("non-exhaustive match".to_string()))
                            });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }) })))
        }) })))
    }) })))
}

fn def_fallbackTags__d157c6187b15a08e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
        {
            let f = (def_fallbackTagsFromTag__1d40f51f98a51fd2(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(locale.clone())).and_then(|b| match b { Value::Record(map) => map.get("tag").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_i18n_fallbackTags__b4f93681e0889f25(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
        {
            let f = (def_fallbackTagsFromTag__1d40f51f98a51fd2(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(((aivi_ok(locale.clone())).and_then(|b| match b { Value::Record(map) => map.get("tag").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_fallbackTagsFromTag__1d40f51f98a51fd2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tag: Value, rt: &mut Runtime| {
        ({
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isEmpty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tag.clone()))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new(Vec::new()))), Value::Bool(false) => {
            let f = (def_fallbackTagsFromNonEmptyTag__bf616e0605e9c97e(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tag.clone()))?);
            rt.call(f, __aivi_call_args)
        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

#[allow(dead_code)]
fn def_fallbackTagsFromTag__1d40f51f98a51fd2_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |tag: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Vec<String>, RuntimeError> {
            Ok(if (match ({
            let tag = Value::Text(tag.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isEmpty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(tag.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })? { vec![] } else { (def_fallbackTagsFromNonEmptyTag__bf616e0605e9c97e_typed(rt)?)(tag.clone(), rt)? })
        })
    })
}

fn def_aivi_i18n_fallbackTagsFromTag__33b6a94873796303(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tag: Value, rt: &mut Runtime| {
        ({
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("isEmpty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tag.clone()))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new(Vec::new()))), Value::Bool(false) => {
            let f = (def_fallbackTagsFromNonEmptyTag__bf616e0605e9c97e(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tag.clone()))?);
            rt.call(f, __aivi_call_args)
        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_fallbackTagsFromNonEmptyTag__bf616e0605e9c97e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tag: Value, rt: &mut Runtime| {
        ({
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("lastIndexOf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tag.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::Text("-".to_string())))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tag.clone()))?])));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("i", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let i = __b.remove("i").expect("pattern binder");
                    return ((aivi_ok(i.clone())).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) <= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tag.clone()))?]))), Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(tag.clone()))?]); out.extend({ let v = ({
                        let f = (def_fallbackTagsFromNonEmptyTag__bf616e0605e9c97e(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(tag.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                            __aivi_call_args.push((aivi_ok(i.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

#[allow(dead_code)]
fn def_fallbackTagsFromNonEmptyTag__bf616e0605e9c97e_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<Vec<String>, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |tag: String, rt: &mut aivi_native_runtime::Runtime| -> Result<Vec<String>, RuntimeError> {
            Ok((match ({
            let tag = Value::Text(tag.clone());
            (({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("lastIndexOf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(tag.clone()))?);
                __aivi_call_args.push((aivi_ok(Value::Text("-".to_string())))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tag.clone()))?])));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                            let v0 = &args[0];
                            if !({ b.insert("i", v0.clone()); true }) { return false; }
                            true
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let i = __b.remove("i").expect("pattern binder");
                        return ((aivi_ok(i.clone())).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) <= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tag.clone()))?]))), Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(tag.clone()))?]); out.extend({ let v = ({
                            let f = (def_fallbackTagsFromNonEmptyTag__bf616e0605e9c97e(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(tag.clone()))?);
                                __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                                __aivi_call_args.push((aivi_ok(i.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            }))?
        }) { Value::List(xs) => { let mut out = Vec::new(); for e in xs.iter().cloned() { out.push((match e { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?); } Ok(out) }, other => Err(RuntimeError::Message(format!("expected List, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_i18n_fallbackTagsFromNonEmptyTag__fd39c5b385b6d49b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tag: Value, rt: &mut Runtime| {
        ({
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("lastIndexOf").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(tag.clone()))?);
            __aivi_call_args.push((aivi_ok(Value::Text("-".to_string())))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tag.clone()))?])));
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                        let v0 = &args[0];
                        if !({ b.insert("i", v0.clone()); true }) { return false; }
                        true
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let i = __b.remove("i").expect("pattern binder");
                    return ((aivi_ok(i.clone())).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a <= b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) <= b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a <= (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <=: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::List(Arc::new(vec![(aivi_ok(tag.clone()))?]))), Value::Bool(false) => aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(tag.clone()))?]); out.extend({ let v = ({
                        let f = (def_fallbackTagsFromNonEmptyTag__bf616e0605e9c97e(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(tag.clone()))?);
                            __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                            __aivi_call_args.push((aivi_ok(i.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out }))), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_catalogFromBundles__aa7e01cb28520609(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundles: Value, rt: &mut Runtime| {
        (aivi_ok(bundles.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return (aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), });
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("b", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let b = __b.remove("b").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return {
                        let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("locale").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("tag").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                        __aivi_call_args.push((aivi_ok(b.clone()))?);
                        __aivi_call_args.push(({
                            let f = (def_catalogFromBundles__aa7e01cb28520609(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_aivi_i18n_catalogFromBundles__881bbb28f9873d0a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bundles: Value, rt: &mut Runtime| {
        (aivi_ok(bundles.clone())).and_then(|__scrut| {
            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 0 { return false; }
                        items.len() == 0
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_0(&__scrut, &mut __b) {
                    return (aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), });
                }
            }

            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                {
                    use Value::*;
                    match v { Value::List(items) => {
                        let items = items.as_ref();
                        if items.len() < 1 { return false; }
                        let v0 = &items[0];
                        if !({ b.insert("b", v0.clone()); true }) { return false; }
                        let tail = Value::List(Arc::new(items[1..].to_vec()));
                        { b.insert("rest", (&tail).clone()); true }
                    }, _ => false }
                }
            }

            {
                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                if __match_arm_1(&__scrut, &mut __b) {
                    let b = __b.remove("b").expect("pattern binder");
                    let rest = __b.remove("rest").expect("pattern binder");
                    return {
                        let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("locale").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("tag").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                        __aivi_call_args.push((aivi_ok(b.clone()))?);
                        __aivi_call_args.push(({
                            let f = (def_catalogFromBundles__aa7e01cb28520609(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    };
                }
            }

            Err(RuntimeError::Message("non-exhaustive match".to_string()))
        })
    }) })))
}

fn def_bundleForLocale__daa140927b4763ea(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            {
                let f = (def_bundleForTags__c95719027af81e79(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                __aivi_call_args.push(({
                    let f = (def_fallbackTags__d157c6187b15a08e(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(locale.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_i18n_bundleForLocale__d1ebf92c73dc619f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            {
                let f = (def_bundleForTags__c95719027af81e79(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                __aivi_call_args.push(({
                    let f = (def_fallbackTags__d157c6187b15a08e(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(locale.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_bundleForTags__c95719027af81e79(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tags: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            (aivi_ok(tags.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("t", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return ({
                            let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|__scrut| {
                            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !({ b.insert("b", v0.clone()); true }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_0(&__scrut, &mut __b) {
                                    let b = __b.remove("b").expect("pattern binder");
                                    return {
                                        let f = (aivi_ok(__builtin("Some")))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(b.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_1(&__scrut, &mut __b) {
                                    return {
                                        let f = (def_bundleForTags__c95719027af81e79(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            Err(RuntimeError::Message("non-exhaustive match".to_string()))
                        });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_i18n_bundleForTags__e1ee8f1a231b1218(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tags: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            (aivi_ok(tags.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("t", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return ({
                            let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|__scrut| {
                            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !({ b.insert("b", v0.clone()); true }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_0(&__scrut, &mut __b) {
                                    let b = __b.remove("b").expect("pattern binder");
                                    return {
                                        let f = (aivi_ok(__builtin("Some")))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(b.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_1(&__scrut, &mut __b) {
                                    return {
                                        let f = (def_bundleForTags__c95719027af81e79(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            Err(RuntimeError::Message("non-exhaustive match".to_string()))
                        });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_bundlesForLocale__a173b917112d7013(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            {
                let f = (def_bundlesForTags__8fa512273e095b9c(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                __aivi_call_args.push(({
                    let f = (def_fallbackTags__d157c6187b15a08e(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(locale.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_i18n_bundlesForLocale__949e04e2e2f077fc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            {
                let f = (def_bundlesForTags__8fa512273e095b9c(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                __aivi_call_args.push(({
                    let f = (def_fallbackTags__d157c6187b15a08e(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(locale.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_bundlesForTags__8fa512273e095b9c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tags: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            (aivi_ok(tags.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("t", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return ({
                            let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|__scrut| {
                            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_0(&__scrut, &mut __b) {
                                    return {
                                        let f = (def_bundlesForTags__8fa512273e095b9c(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !({ b.insert("b", v0.clone()); true }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_1(&__scrut, &mut __b) {
                                    let b = __b.remove("b").expect("pattern binder");
                                    return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(b.clone()))?]); out.extend({ let v = ({
                                        let f = (def_bundlesForTags__8fa512273e095b9c(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                                }
                            }

                            Err(RuntimeError::Message("non-exhaustive match".to_string()))
                        });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_i18n_bundlesForTags__d10b5aaf87ef65c3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tags: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            (aivi_ok(tags.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(Vec::new())));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("t", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let rest = __b.remove("rest").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return ({
                            let f = ((aivi_ok(__builtin("Map"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|__scrut| {
                            fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_0(&__scrut, &mut __b) {
                                    return {
                                        let f = (def_bundlesForTags__8fa512273e095b9c(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    };
                                }
                            }

                            fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                {
                                    use Value::*;
                                    match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                        let v0 = &args[0];
                                        if !({ b.insert("b", v0.clone()); true }) { return false; }
                                        true
                                    }, _ => false }
                                }
                            }

                            {
                                let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                if __match_arm_1(&__scrut, &mut __b) {
                                    let b = __b.remove("b").expect("pattern binder");
                                    return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(b.clone()))?]); out.extend({ let v = ({
                                        let f = (def_bundlesForTags__8fa512273e095b9c(rt))?;
                                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                                        __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                                        __aivi_call_args.push((aivi_ok(rest.clone()))?);
                                        rt.call(f, __aivi_call_args)
                                    })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                                }
                            }

                            Err(RuntimeError::Message("non-exhaustive match".to_string()))
                        });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_tCatalog__f9f4b62fd43720ae(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                let catalog = catalog.clone();
                let locale = locale.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                    let catalog = catalog.clone();
                    let k = k.clone();
                    let locale = locale.clone();
                    {
                        let f = (def_tWithFallback__6a82e199a989d5f1(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_bundlesForLocale__a173b917112d7013(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                            __aivi_call_args.push((aivi_ok(locale.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        __aivi_call_args.push((aivi_ok(k.clone()))?);
                        __aivi_call_args.push((aivi_ok(args.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_i18n_tCatalog__a26c01ee5039e95d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                let catalog = catalog.clone();
                let locale = locale.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                    let catalog = catalog.clone();
                    let k = k.clone();
                    let locale = locale.clone();
                    {
                        let f = (def_tWithFallback__6a82e199a989d5f1(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_bundlesForLocale__a173b917112d7013(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                            __aivi_call_args.push((aivi_ok(locale.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        __aivi_call_args.push((aivi_ok(k.clone()))?);
                        __aivi_call_args.push((aivi_ok(args.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_tCatalogWithDefault__40f40dcec42d1537(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |defaultBundle: Value, rt: &mut Runtime| {
                let catalog = catalog.clone();
                let locale = locale.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                    let catalog = catalog.clone();
                    let defaultBundle = defaultBundle.clone();
                    let locale = locale.clone();
                    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                        let catalog = catalog.clone();
                        let defaultBundle = defaultBundle.clone();
                        let k = k.clone();
                        let locale = locale.clone();
                        {
                            let f = (def_tWithFallback__6a82e199a989d5f1(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (def_append1__5277acc9e9e081f0(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = (def_bundlesForLocale__a173b917112d7013(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                                    __aivi_call_args.push((aivi_ok(locale.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                __aivi_call_args.push((aivi_ok(defaultBundle.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            __aivi_call_args.push((aivi_ok(k.clone()))?);
                            __aivi_call_args.push((aivi_ok(args.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }
                    }) })))
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_aivi_i18n_tCatalogWithDefault__de24f67687989c32(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |catalog: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |locale: Value, rt: &mut Runtime| {
            let catalog = catalog.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |defaultBundle: Value, rt: &mut Runtime| {
                let catalog = catalog.clone();
                let locale = locale.clone();
                aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
                    let catalog = catalog.clone();
                    let defaultBundle = defaultBundle.clone();
                    let locale = locale.clone();
                    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |args: Value, rt: &mut Runtime| {
                        let catalog = catalog.clone();
                        let defaultBundle = defaultBundle.clone();
                        let k = k.clone();
                        let locale = locale.clone();
                        {
                            let f = (def_tWithFallback__6a82e199a989d5f1(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(({
                                let f = (def_append1__5277acc9e9e081f0(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = (def_bundlesForLocale__a173b917112d7013(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(catalog.clone()))?);
                                    __aivi_call_args.push((aivi_ok(locale.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                __aivi_call_args.push((aivi_ok(defaultBundle.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?);
                            __aivi_call_args.push((aivi_ok(k.clone()))?);
                            __aivi_call_args.push((aivi_ok(args.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }
                    }) })))
                }) })))
            }) })))
        }) })))
    }) })))
}

fn def_append1__5277acc9e9e081f0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(vec![(aivi_ok(x.clone()))?])));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("h", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("t", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let h = __b.remove("h").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(h.clone()))?]); out.extend({ let v = ({
                            let f = (def_append1__5277acc9e9e081f0(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_i18n_append1__b4ab92c30ccbbe39(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |xs: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
            let xs = xs.clone();
            (aivi_ok(xs.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(Value::List(Arc::new(vec![(aivi_ok(x.clone()))?])));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("h", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("t", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let h = __b.remove("h").expect("pattern binder");
                        let t = __b.remove("t").expect("pattern binder");
                        return aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(h.clone()))?]); out.extend({ let v = ({
                            let f = (def_append1__5277acc9e9e081f0(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(t.clone()))?);
                            __aivi_call_args.push((aivi_ok(x.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?; match v { Value::List(xs) => (*xs).clone(), other => return Err(RuntimeError::Message(format!("expected List for spread, got {}", aivi_native_runtime::format_value(&other)))), } }); out })));
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_absInt__512a13c4441365f4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => (aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), Value::Bool(false) => aivi_ok(n.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

#[allow(dead_code)]
fn def_absInt__512a13c4441365f4_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<i64, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |n: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<i64, RuntimeError> {
            Ok(if (n < 0_i64) { (0_i64 - n) } else { n })
        })
    })
}

fn def_aivi_number_bigint_absInt__fbfe4508a72be76d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |n: Value, rt: &mut Runtime| {
        ((aivi_ok(n.clone())).and_then(|l| (aivi_ok(Value::Int(0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Bool(a < b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Bool((a as f64) < b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Bool(a < (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for <: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|c| match c { Value::Bool(true) => (aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(n.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), Value::Bool(false) => aivi_ok(n.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_fromInt__e038b843950319ae(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("fromInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_bigint_fromInt__a841164bf970020d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("fromInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toInt__2ab89b7de3f751bd(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("toInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_bigint_toInt__362d7aeb1a5c1b1e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("toInt").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_bigint______f6112154ba2c5e64(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("add").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_bigint______f5fcbd54ba1b0b6e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("sub").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_bigint______f60dbd54ba297ea1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("bigint"))).and_then(|b| match b { Value::Record(map) => map.get("mul").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def__1n__07f85807b4b9a616(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_n: Value, rt: &mut Runtime| {
        {
            let f = (def_fromInt__e038b843950319ae(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_n.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_bigint_1n__0ed0a03656a15c4b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_n: Value, rt: &mut Runtime| {
        {
            let f = (def_fromInt__e038b843950319ae(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_n.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_fromBigInts__dc6f6c2c26cee7eb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |num: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |den: Value, rt: &mut Runtime| {
            let num = num.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("fromBigInts").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(num.clone()))?);
                __aivi_call_args.push((aivi_ok(den.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_rational_fromBigInts__681b69b195c91b2d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |num: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |den: Value, rt: &mut Runtime| {
            let num = num.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("fromBigInts").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(num.clone()))?);
                __aivi_call_args.push((aivi_ok(den.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_rational_normalize__e34173ff1c79c1a2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("normalize").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_numerator__6af85df9fd50dd54(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("numerator").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_rational_numerator__c151361cdcee7682(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("numerator").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_denominator__d1ea6c8aad051403(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("denominator").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_rational_denominator__43bd982347acced5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("denominator").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_rational______80d8932c90e948d1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("add").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_rational______80c42f2c90d7f5db(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("sub").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_rational______80dbb72c90ebbbd4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("mul").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_rational______80cabb2c90dd4f6d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("rational"))).and_then(|b| match b { Value::Record(map) => map.get("div").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_fromFloat__958f95fd6bc5c7d5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("fromFloat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_decimal_fromFloat__fdb4f4d8a0a55660(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("fromFloat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toFloat__164ac090812c6936(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("toFloat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_decimal_toFloat__434b8e1a455916af(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("toFloat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(value.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_decimal_round__f74038d2d908101e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |value: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |places: Value, rt: &mut Runtime| {
            let value = value.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("round").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(value.clone()))?);
                __aivi_call_args.push((aivi_ok(places.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_decimal______a9cb7095c27f5a6e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("add").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_decimal______a9dfd495c290ad64(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("sub").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_decimal______a9c84c95c27ce76b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("mul").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_number_decimal______a9d8f895c28acbe2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let f = ((aivi_ok(__builtin("decimal"))).and_then(|b| match b { Value::Record(map) => map.get("div").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(a.clone()))?);
                __aivi_call_args.push((aivi_ok(b.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def__1dec__4aefd8eff94e75fc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_dec: Value, rt: &mut Runtime| {
        {
            let f = (def_fromFloat__958f95fd6bc5c7d5(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_dec.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_decimal_1dec__fa5476c5d97e86e3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_dec: Value, rt: &mut Runtime| {
        {
            let f = (def_fromFloat__958f95fd6bc5c7d5(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_dec.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_i__af63e44c8601fa24(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("re".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("im".to_string(), (aivi_ok(Value::Float(1.0)))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_aivi_number_complex_i__fbab740ba2d6e956(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("re".to_string(), (aivi_ok(Value::Float(0.0)))?);
        map.insert("im".to_string(), (aivi_ok(Value::Float(1.0)))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_aivi_number_complex______7a0d4aee432f695d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("re".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("im".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_number_complex______7a13c6ee4334a7bf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("re".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("im".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_number_complex______7a105eee4331c130(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("re".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("im".to_string(), ((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_number_complex______7a1ae2ee433af601(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |z: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let z = z.clone();
            {
                let mut map = HashMap::new();
                map.insert("re".to_string(), (((aivi_ok(z.clone())).and_then(|b| match b { Value::Record(map) => map.get("re").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("im".to_string(), (((aivi_ok(z.clone())).and_then(|b| match b { Value::Record(map) => map.get("im").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_fromAxisAngle__93462c26c2e56bdf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |axis: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |theta: Value, rt: &mut Runtime| {
            let axis = axis.clone();
            {
                let __v = ({
                    let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((((((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("axisLen", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let axisLen = __b0.remove("axisLen").expect("pattern binder");
                let __v = (((aivi_ok(axisLen.clone())).and_then(|a| (aivi_ok(Value::Float(0.0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (aivi_ok(Value::Float(0.0)))?);
                    map.insert("y".to_string(), (aivi_ok(Value::Float(0.0)))?);
                    map.insert("z".to_string(), (aivi_ok(Value::Float(0.0)))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }, Value::Bool(false) => {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(axisLen.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(axisLen.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(axisLen.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("axisUnit", v.clone()); true }
                        }

                })(&__v, &mut __b1);
                if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let axisUnit = __b1.remove("axisUnit").expect("pattern binder");
                let __v = ((aivi_ok(theta.clone())).and_then(|l| (aivi_ok(Value::Float(2.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("half", v.clone()); true }
                        }

                })(&__v, &mut __b2);
                if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let half = __b2.remove("half").expect("pattern binder");
                let __v = ({
                    let f = (def_sin__8248a1195cecc4ad(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_radians__223c4f5cf7037461(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(half.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b3: HashMap<&'static str, Value> = HashMap::new();
                let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("s", v.clone()); true }
                        }

                })(&__v, &mut __b3);
                if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let s = __b3.remove("s").expect("pattern binder");
                let __v = ({
                    let f = (def_cos__f604fc190d0176dc(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_radians__223c4f5cf7037461(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(half.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b4: HashMap<&'static str, Value> = HashMap::new();
                let __ok4 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("c", v.clone()); true }
                        }

                })(&__v, &mut __b4);
                if !__ok4 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let c = __b4.remove("c").expect("pattern binder");
                {
                    let mut map = HashMap::new();
                    map.insert("w".to_string(), (aivi_ok(c.clone()))?);
                    map.insert("x".to_string(), (((aivi_ok(axisUnit.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(axisUnit.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((aivi_ok(axisUnit.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }
        }) })))
    }) })))
}

fn def_aivi_number_quaternion_fromAxisAngle__3c2174b2f1d0a7a3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |axis: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |theta: Value, rt: &mut Runtime| {
            let axis = axis.clone();
            {
                let __v = ({
                    let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((((((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("axisLen", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let axisLen = __b0.remove("axisLen").expect("pattern binder");
                let __v = (((aivi_ok(axisLen.clone())).and_then(|a| (aivi_ok(Value::Float(0.0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (aivi_ok(Value::Float(0.0)))?);
                    map.insert("y".to_string(), (aivi_ok(Value::Float(0.0)))?);
                    map.insert("z".to_string(), (aivi_ok(Value::Float(0.0)))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }, Value::Bool(false) => {
                    let mut map = HashMap::new();
                    map.insert("x".to_string(), (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(axisLen.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(axisLen.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((aivi_ok(axis.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(axisLen.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("axisUnit", v.clone()); true }
                        }

                })(&__v, &mut __b1);
                if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let axisUnit = __b1.remove("axisUnit").expect("pattern binder");
                let __v = ((aivi_ok(theta.clone())).and_then(|l| (aivi_ok(Value::Float(2.0))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?;
                let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("half", v.clone()); true }
                        }

                })(&__v, &mut __b2);
                if !__ok2 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let half = __b2.remove("half").expect("pattern binder");
                let __v = ({
                    let f = (def_sin__8248a1195cecc4ad(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_radians__223c4f5cf7037461(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(half.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b3: HashMap<&'static str, Value> = HashMap::new();
                let __ok3 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("s", v.clone()); true }
                        }

                })(&__v, &mut __b3);
                if !__ok3 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let s = __b3.remove("s").expect("pattern binder");
                let __v = ({
                    let f = (def_cos__f604fc190d0176dc(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(({
                        let f = (def_radians__223c4f5cf7037461(rt))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(half.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b4: HashMap<&'static str, Value> = HashMap::new();
                let __ok4 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("c", v.clone()); true }
                        }

                })(&__v, &mut __b4);
                if !__ok4 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let c = __b4.remove("c").expect("pattern binder");
                {
                    let mut map = HashMap::new();
                    map.insert("w".to_string(), (aivi_ok(c.clone()))?);
                    map.insert("x".to_string(), (((aivi_ok(axisUnit.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("y".to_string(), (((aivi_ok(axisUnit.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    map.insert("z".to_string(), (((aivi_ok(axisUnit.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    aivi_ok(Value::Record(Arc::new(map)))
                }
            }
        }) })))
    }) })))
}

fn def_conjugate__a325dd7f1988c18d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("w".to_string(), ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("x".to_string(), (((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(q.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("y".to_string(), (((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(q.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("z".to_string(), (((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(q.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_number_quaternion_conjugate__17bf3c1e269e1399(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        {
            let mut map = HashMap::new();
            map.insert("w".to_string(), ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("x".to_string(), (((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(q.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("y".to_string(), (((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(q.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            map.insert("z".to_string(), (((aivi_ok(Value::Int(0))).and_then(|l| (aivi_ok(q.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
            aivi_ok(Value::Record(Arc::new(map)))
        }
    }) })))
}

fn def_aivi_number_quaternion_magnitude__5d196b092f7b6a59(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        {
            let f = (def_sqrt__9614cf190fc8d7cf(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(((((((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_number_quaternion_normalize__ed60cc42dee83ae0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_magnitude__51bb22db9bbc7b95(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(q.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("m", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let m = __b0.remove("m").expect("pattern binder");
            ((aivi_ok(m.clone())).and_then(|a| (aivi_ok(Value::Float(0.0))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(q.clone()), Value::Bool(false) => (aivi_ok(q.clone())).and_then(|l| (aivi_ok(m.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_aivi_number_quaternion______3519bbc28e0e4163(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("w".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_number_quaternion______352e1fc28e1f9459(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("w".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("x".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_number_quaternion______351d1fc28e112126(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |a: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |b: Value, rt: &mut Runtime| {
            let a = a.clone();
            {
                let mut map = HashMap::new();
                map.insert("w".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("x".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), ((((((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|l| (((aivi_ok(a.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| ((aivi_ok(b.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a * b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a * b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) * b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a * (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for *: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    }))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a + b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a + b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) + b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a + (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for +: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_aivi_number_quaternion______3527a3c28e1a55f7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |q: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |s: Value, rt: &mut Runtime| {
            let q = q.clone();
            {
                let mut map = HashMap::new();
                map.insert("w".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("w").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("x".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("x").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("y".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("y").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                map.insert("z".to_string(), (((aivi_ok(q.clone())).and_then(|b| match b { Value::Record(map) => map.get("z").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|l| (aivi_ok(s.clone())).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a / b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a / b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) / b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a / (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for /: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                aivi_ok(Value::Record(Arc::new(map)))
            }
        }) })))
    }) })))
}

fn def_get__d4e26318faaa79f7_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |url: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("http"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(url.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_get__d4e26318faaa79f7_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |url: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("https"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(url.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_get__d4e26318faaa79f7_clause_2(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_get__d4e26318faaa79f7(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_get__d4e26318faaa79f7_clause_0(rt))?,
        (def_get__d4e26318faaa79f7_clause_1(rt))?,
        (def_get__d4e26318faaa79f7_clause_2(rt))?,
    ]))
}

fn def_aivi_net_http_get__e07136c9aac6dc15(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |url: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("http"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(url.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_post__8c2fe90da8958d47_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |url: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |body: Value, rt: &mut Runtime| {
            let url = url.clone();
            {
                let f = (aivi_ok(__builtin("load")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("http"))).and_then(|b| match b { Value::Record(map) => map.get("post").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(url.clone()))?);
                    __aivi_call_args.push((aivi_ok(body.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_post__8c2fe90da8958d47_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |url: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |body: Value, rt: &mut Runtime| {
            let url = url.clone();
            {
                let f = (aivi_ok(__builtin("load")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("https"))).and_then(|b| match b { Value::Record(map) => map.get("post").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(url.clone()))?);
                    __aivi_call_args.push((aivi_ok(body.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_post__8c2fe90da8958d47(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_post__8c2fe90da8958d47_clause_0(rt))?,
        (def_post__8c2fe90da8958d47_clause_1(rt))?,
    ]))
}

fn def_aivi_net_http_post__93592723749465ad(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |url: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |body: Value, rt: &mut Runtime| {
            let url = url.clone();
            {
                let f = (aivi_ok(__builtin("load")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("http"))).and_then(|b| match b { Value::Record(map) => map.get("post").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(url.clone()))?);
                    __aivi_call_args.push((aivi_ok(body.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_fetch__565a3fdfd862a0a3_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |request: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("http"))).and_then(|b| match b { Value::Record(map) => map.get("fetch").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(request.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_fetch__565a3fdfd862a0a3_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |request: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("https"))).and_then(|b| match b { Value::Record(map) => map.get("fetch").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(request.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_fetch__565a3fdfd862a0a3(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_fetch__565a3fdfd862a0a3_clause_0(rt))?,
        (def_fetch__565a3fdfd862a0a3_clause_1(rt))?,
    ]))
}

fn def_aivi_net_http_fetch__6c4ab58f9f4cc585(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |request: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("http"))).and_then(|b| match b { Value::Record(map) => map.get("fetch").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(request.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_https_get__ac076976f1ed7d62(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |url: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("https"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(url.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_https_post__f8042dcec47c4a08(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |url: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |body: Value, rt: &mut Runtime| {
            let url = url.clone();
            {
                let f = (aivi_ok(__builtin("load")))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push(({
                    let f = ((aivi_ok(__builtin("https"))).and_then(|b| match b { Value::Record(map) => map.get("post").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(url.clone()))?);
                    __aivi_call_args.push((aivi_ok(body.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_net_https_fetch__0ddc1969835e643a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |request: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(__builtin("load")))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("https"))).and_then(|b| match b { Value::Record(map) => map.get("fetch").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(request.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_listen__dc8acb313473c026_clause_0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |address: Value, rt: &mut Runtime| {
        {
            let address = address.clone();
            aivi_ok(Value::Resource(Arc::new(ResourceValue {
                acquire: Mutex::new(Some(Box::new(move |rt: &mut Runtime| {
                    let __e = ({
                        let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("listen").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(address.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let __v = rt.run_effect_value(__e)?;
                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("listener", v.clone()); true }
                            }

                    })(&__v, &mut __b0);
                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                    let listener = __b0.remove("listener").expect("pattern binder");
                    let __value = (aivi_ok(listener.clone()))?;
                    let __cleanup = Value::Effect(Arc::new(EffectValue::Thunk {
                        func: Arc::new(move |rt: &mut Runtime| {
                            let __e = ({
                                let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("closeListener").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(listener.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let __v = rt.run_effect_value(__e)?;
                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        true
                                    }

                            })(&__v, &mut __b1);
                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed in resource cleanup bind".to_string())); }
                            Ok(Value::Unit)
                        }),
                    }));
                    return Ok((__value, __cleanup));
                    let __e = ({
                        let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("closeListener").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(listener.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let __v = rt.run_effect_value(__e)?;
                    let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                    let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                true
                            }

                    })(&__v, &mut __b2);
                    if !__ok2 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                    Err(RuntimeError::Message("resource block missing yield".to_string()))
                }))),
            })))
        }
    }) })))
}

fn def_listen__dc8acb313473c026_clause_1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |config: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |handler: Value, rt: &mut Runtime| {
            let config = config.clone();
            {
                let config = config.clone();
                let handler = handler.clone();
                aivi_ok(Value::Resource(Arc::new(ResourceValue {
                    acquire: Mutex::new(Some(Box::new(move |rt: &mut Runtime| {
                        let __e = ({
                            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("listen").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(config.clone()))?);
                            __aivi_call_args.push((aivi_ok(handler.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?;
                        let __v = rt.run_effect_value(__e)?;
                        let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                        let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                {
                                    use Value::*;
                                    { b.insert("server", v.clone()); true }
                                }

                        })(&__v, &mut __b0);
                        if !__ok0 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                        let server = __b0.remove("server").expect("pattern binder");
                        let __value = (aivi_ok(server.clone()))?;
                        let __cleanup = Value::Effect(Arc::new(EffectValue::Thunk {
                            func: Arc::new(move |rt: &mut Runtime| {
                                let __e = ({
                                    let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("stop").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(server.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?;
                                let __v = rt.run_effect_value(__e)?;
                                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            true
                                        }

                                })(&__v, &mut __b1);
                                if !__ok1 { return Err(RuntimeError::Message("pattern match failed in resource cleanup bind".to_string())); }
                                Ok(Value::Unit)
                            }),
                        }));
                        return Ok((__value, __cleanup));
                        let __e = ({
                            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("stop").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(server.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?;
                        let __v = rt.run_effect_value(__e)?;
                        let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                        let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                {
                                    use Value::*;
                                    true
                                }

                        })(&__v, &mut __b2);
                        if !__ok2 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                        Err(RuntimeError::Message("resource block missing yield".to_string()))
                    }))),
                })))
            }
        }) })))
    }) })))
}

fn def_listen__dc8acb313473c026(rt: &mut Runtime) -> R {
    aivi_ok(Value::MultiClause(vec![
        (def_listen__dc8acb313473c026_clause_0(rt))?,
        (def_listen__dc8acb313473c026_clause_1(rt))?,
    ]))
}

fn def_aivi_net_sockets_listen__4c47f462ccfd8944(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |address: Value, rt: &mut Runtime| {
        {
            let address = address.clone();
            aivi_ok(Value::Resource(Arc::new(ResourceValue {
                acquire: Mutex::new(Some(Box::new(move |rt: &mut Runtime| {
                    let __e = ({
                        let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("listen").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(address.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let __v = rt.run_effect_value(__e)?;
                    let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                    let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                { b.insert("listener", v.clone()); true }
                            }

                    })(&__v, &mut __b0);
                    if !__ok0 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                    let listener = __b0.remove("listener").expect("pattern binder");
                    let __value = (aivi_ok(listener.clone()))?;
                    let __cleanup = Value::Effect(Arc::new(EffectValue::Thunk {
                        func: Arc::new(move |rt: &mut Runtime| {
                            let __e = ({
                                let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("closeListener").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(listener.clone()))?);
                                rt.call(f, __aivi_call_args)
                            })?;
                            let __v = rt.run_effect_value(__e)?;
                            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                    {
                                        use Value::*;
                                        true
                                    }

                            })(&__v, &mut __b1);
                            if !__ok1 { return Err(RuntimeError::Message("pattern match failed in resource cleanup bind".to_string())); }
                            Ok(Value::Unit)
                        }),
                    }));
                    return Ok((__value, __cleanup));
                    let __e = ({
                        let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("closeListener").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(listener.clone()))?);
                        rt.call(f, __aivi_call_args)
                    })?;
                    let __v = rt.run_effect_value(__e)?;
                    let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                    let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                            {
                                use Value::*;
                                true
                            }

                    })(&__v, &mut __b2);
                    if !__ok2 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                    Err(RuntimeError::Message("resource block missing yield".to_string()))
                }))),
            })))
        }
    }) })))
}

fn def_accept__7e5f7abe09509b09(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |listener: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("accept").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(listener.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_sockets_accept__26766404ec28bf4f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |listener: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("accept").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(listener.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_connect__54cb3aded715c1b9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |address: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("connect").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(address.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_sockets_connect__c715dd24eee804df(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |address: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("connect").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(address.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_sockets_send__32e1ae9ca87f242d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |bytes: Value, rt: &mut Runtime| {
            let conn = conn.clone();
            {
                let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("send").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(conn.clone()))?);
                __aivi_call_args.push((aivi_ok(bytes.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_net_sockets_recv__972060a3badc7097(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("recv").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(conn.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_sockets_close__a737e86e063b42f1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("sockets"))).and_then(|b| match b { Value::Record(map) => map.get("close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(conn.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_fromSocket__131966b4f9b1183c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("streams"))).and_then(|b| match b { Value::Record(map) => map.get("fromSocket").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(conn.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_streams_fromSocket__f0b387ec728702bb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("streams"))).and_then(|b| match b { Value::Record(map) => map.get("fromSocket").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(conn.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_toSocket__bd666267ab847bd5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |stream: Value, rt: &mut Runtime| {
            let conn = conn.clone();
            {
                let f = ((aivi_ok(__builtin("streams"))).and_then(|b| match b { Value::Record(map) => map.get("toSocket").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(conn.clone()))?);
                __aivi_call_args.push((aivi_ok(stream.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_net_streams_toSocket__6db83c2b4c12e56a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |conn: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |stream: Value, rt: &mut Runtime| {
            let conn = conn.clone();
            {
                let f = ((aivi_ok(__builtin("streams"))).and_then(|b| match b { Value::Record(map) => map.get("toSocket").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(conn.clone()))?);
                __aivi_call_args.push((aivi_ok(stream.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_chunks__99034d67cbe5d3a3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |size: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |stream: Value, rt: &mut Runtime| {
            let size = size.clone();
            {
                let f = ((aivi_ok(__builtin("streams"))).and_then(|b| match b { Value::Record(map) => map.get("chunks").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(size.clone()))?);
                __aivi_call_args.push((aivi_ok(stream.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_net_streams_chunks__caf204aa72f9c2b0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |size: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |stream: Value, rt: &mut Runtime| {
            let size = size.clone();
            {
                let f = ((aivi_ok(__builtin("streams"))).and_then(|b| match b { Value::Record(map) => map.get("chunks").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(size.clone()))?);
                __aivi_call_args.push((aivi_ok(stream.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_net_http_server_listen__36b3a9fbfa8c3320(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |config: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |handler: Value, rt: &mut Runtime| {
            let config = config.clone();
            {
                let config = config.clone();
                let handler = handler.clone();
                aivi_ok(Value::Resource(Arc::new(ResourceValue {
                    acquire: Mutex::new(Some(Box::new(move |rt: &mut Runtime| {
                        let __e = ({
                            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("listen").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(config.clone()))?);
                            __aivi_call_args.push((aivi_ok(handler.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?;
                        let __v = rt.run_effect_value(__e)?;
                        let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                        let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                {
                                    use Value::*;
                                    { b.insert("server", v.clone()); true }
                                }

                        })(&__v, &mut __b0);
                        if !__ok0 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                        let server = __b0.remove("server").expect("pattern binder");
                        let __value = (aivi_ok(server.clone()))?;
                        let __cleanup = Value::Effect(Arc::new(EffectValue::Thunk {
                            func: Arc::new(move |rt: &mut Runtime| {
                                let __e = ({
                                    let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("stop").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(server.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?;
                                let __v = rt.run_effect_value(__e)?;
                                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                        {
                                            use Value::*;
                                            true
                                        }

                                })(&__v, &mut __b1);
                                if !__ok1 { return Err(RuntimeError::Message("pattern match failed in resource cleanup bind".to_string())); }
                                Ok(Value::Unit)
                            }),
                        }));
                        return Ok((__value, __cleanup));
                        let __e = ({
                            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("stop").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(server.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?;
                        let __v = rt.run_effect_value(__e)?;
                        let mut __b2: HashMap<&'static str, Value> = HashMap::new();
                        let __ok2 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                                {
                                    use Value::*;
                                    true
                                }

                        })(&__v, &mut __b2);
                        if !__ok2 { return Err(RuntimeError::Message("pattern match failed in resource bind".to_string())); }
                        Err(RuntimeError::Message("resource block missing yield".to_string()))
                    }))),
                })))
            }
        }) })))
    }) })))
}

fn def_stop__af1f52191db2bcc5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |server: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("stop").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(server.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_http_server_stop__f98d6840a84b67ef(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |server: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("stop").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(server.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_wsRecv__0737c1222283fc7b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("ws_recv").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(socket.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_http_server_wsRecv__f3c60f4596a868f1(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("ws_recv").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(socket.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_wsSend__f999df1628402e39(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
            let socket = socket.clone();
            {
                let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("ws_send").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(socket.clone()))?);
                __aivi_call_args.push((aivi_ok(msg.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_net_http_server_wsSend__73dc313f966986eb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
            let socket = socket.clone();
            {
                let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("ws_send").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(socket.clone()))?);
                __aivi_call_args.push((aivi_ok(msg.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_wsClose__d122f2c691e527e5(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("ws_close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(socket.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_net_http_server_wsClose__543438ed2b4b12e7(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("ws_close").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(socket.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1px__448eff1817636a14(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_px: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Px".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_px.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def__1px__448eff1817636a14_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<__Adt_Length_d183a035e390377e, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |__lit_px: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<__Adt_Length_d183a035e390377e, RuntimeError> {
            Ok(__Adt_Length_d183a035e390377e::Px(__lit_px))
        })
    })
}

fn def_aivi_ui_layout_1px__14ac3006c947201f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_px: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Px".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_px.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1em__44bb10181788c1e2(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_em: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Em".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_em.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def__1em__44bb10181788c1e2_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<__Adt_Length_d183a035e390377e, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |__lit_em: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<__Adt_Length_d183a035e390377e, RuntimeError> {
            Ok(__Adt_Length_d183a035e390377e::Em(__lit_em))
        })
    })
}

fn def_aivi_ui_layout_1em__14d11f06c9661f79(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_em: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Em".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_em.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1rem__f45140efc83edf10(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_rem: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Rem".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_rem.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def__1rem__f45140efc83edf10_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<__Adt_Length_d183a035e390377e, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |__lit_rem: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<__Adt_Length_d183a035e390377e, RuntimeError> {
            Ok(__Adt_Length_d183a035e390377e::Rem(__lit_rem))
        })
    })
}

fn def_aivi_ui_layout_1rem__55c9bb87f9897b41(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_rem: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Rem".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_rem.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1vh__44881318175d6d62(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_vh: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Vh".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_vh.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def__1vh__44881318175d6d62_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<__Adt_Length_d183a035e390377e, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |__lit_vh: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<__Adt_Length_d183a035e390377e, RuntimeError> {
            Ok(__Adt_Length_d183a035e390377e::Vh(__lit_vh))
        })
    })
}

fn def_aivi_ui_layout_1vh__14971c06c934a219(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_vh: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Vh".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_vh.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1vw__44880618175d574b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_vw: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Vw".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_vw.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def__1vw__44880618175d574b_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<__Adt_Length_d183a035e390377e, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |__lit_vw: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<__Adt_Length_d183a035e390377e, RuntimeError> {
            Ok(__Adt_Length_d183a035e390377e::Vw(__lit_vw))
        })
    })
}

fn def_aivi_ui_layout_1vw__14973506c934cc94(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit_vw: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Vw".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit_vw.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def__1___07f89f07b4ba1ebb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit__: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Pct".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit__.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def__1___07f89f07b4ba1ebb_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(i64, &mut aivi_native_runtime::Runtime) -> Result<__Adt_Percentage_abe5954f4ef635aa, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |__lit__: i64, rt: &mut aivi_native_runtime::Runtime| -> Result<__Adt_Percentage_abe5954f4ef635aa, RuntimeError> {
            Ok(__Adt_Percentage_abe5954f4ef635aa::Pct(__lit__))
        })
    })
}

fn def_aivi_ui_layout_1___562b754029a81f8e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |__lit__: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Pct".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(__lit__.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vElement__683706d8204ee98b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tag: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |attrs: Value, rt: &mut Runtime| {
            let tag = tag.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |children: Value, rt: &mut Runtime| {
                let attrs = attrs.clone();
                let tag = tag.clone();
                {
                    let f = (aivi_ok(Value::Constructor { name: "Element".to_string(), args: Vec::new() }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(tag.clone()))?);
                    __aivi_call_args.push((aivi_ok(attrs.clone()))?);
                    __aivi_call_args.push((aivi_ok(children.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_aivi_ui_vElement__24137e89b1cbe9d6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |tag: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |attrs: Value, rt: &mut Runtime| {
            let tag = tag.clone();
            aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |children: Value, rt: &mut Runtime| {
                let attrs = attrs.clone();
                let tag = tag.clone();
                {
                    let f = (aivi_ok(Value::Constructor { name: "Element".to_string(), args: Vec::new() }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(tag.clone()))?);
                    __aivi_call_args.push((aivi_ok(attrs.clone()))?);
                    __aivi_call_args.push((aivi_ok(children.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            }) })))
        }) })))
    }) })))
}

fn def_vText__c0407139b2e5776a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "TextNode".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(t.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vText__ae5f2518601aad9d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "TextNode".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(t.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vKeyed__7e4f06877d24fe61(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let key = key.clone();
            {
                let f = (aivi_ok(Value::Constructor { name: "Keyed".to_string(), args: Vec::new() }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(key.clone()))?);
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_ui_vKeyed__c71b64ff8c7fc0cc(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |key: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
            let key = key.clone();
            {
                let f = (aivi_ok(Value::Constructor { name: "Keyed".to_string(), args: Vec::new() }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(key.clone()))?);
                __aivi_call_args.push((aivi_ok(node.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_vClass__24e90c90df1391f3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Class".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(t.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vClass__b5b2d78a9690609e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Class".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(t.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vId__687bfa194e5d90ac(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Id".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(t.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vId__4d58e8b281886723(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |t: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Id".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(t.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vStyle__62c5d9d7106498da(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |css: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Style".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(css.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vStyle__eeac824417f5c7b3(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |css: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "Style".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(css.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vAttr__0d74ad8808917586(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let k = k.clone();
            {
                let f = (aivi_ok(Value::Constructor { name: "Attr".to_string(), args: Vec::new() }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(k.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_ui_vAttr__f8f21cc5464158dd(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |k: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |v: Value, rt: &mut Runtime| {
            let k = k.clone();
            {
                let f = (aivi_ok(Value::Constructor { name: "Attr".to_string(), args: Vec::new() }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(k.clone()))?);
                __aivi_call_args.push((aivi_ok(v.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_vOnClick__91e5e1e04302b28c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnClick".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(msg.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnClick__f5cfc0fec6464bd9(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnClick".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(msg.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnInput__49d192f8e2330a98(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnInput".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnInput__b29ededbab9ab435(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnInput".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnClickE__ec519911dd95cb8b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnClickE".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnClickE__f6508ceae9727a14(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnClickE".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnInputE__a22799e85cbb7587(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnInputE".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnInputE__1ea91f4497e09a50(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnInputE".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnKeyDown__e11f924a04ea208f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnKeyDown".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnKeyDown__92887869cdbc75f6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnKeyDown".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnKeyUp__349ea5d5c7b45f26(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnKeyUp".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnKeyUp__9fd8d389a9b73843(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnKeyUp".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnPointerDown__c6ebc8194bb79b6d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnPointerDown".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnPointerDown__ec202b48d6c30330(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnPointerDown".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnPointerUp__2fd69c89176b2838(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnPointerUp".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnPointerUp__ae15e77765bfbf29(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnPointerUp".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnPointerMove__3ad29cd1241bc84c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnPointerMove".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnPointerMove__251a1695e9403d91(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |f: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnPointerMove".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(f.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnFocus__e877c4039961899c(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnFocus".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(msg.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnFocus__11fa1e30b8e96879(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnFocus".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(msg.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_vOnBlur__f6c1eaf31791e90d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnBlur".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(msg.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_vOnBlur__5758ecfb48af8c62(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |msg: Value, rt: &mut Runtime| {
        {
            let f = (aivi_ok(Value::Constructor { name: "OnBlur".to_string(), args: Vec::new() }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(msg.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_renderHtml__0b1af378118018e8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("renderHtml").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(node.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_aivi_ui_renderHtml__496c69a0cee93149(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |node: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("renderHtml").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(node.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_diff__c9fcc6675752105a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |old: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |new: Value, rt: &mut Runtime| {
            let old = old.clone();
            {
                let f = ((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("diff").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(old.clone()))?);
                __aivi_call_args.push((aivi_ok(new.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_ui_diff__ca9a90c76e10876b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |old: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |new: Value, rt: &mut Runtime| {
            let old = old.clone();
            {
                let f = ((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("diff").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(old.clone()))?);
                __aivi_call_args.push((aivi_ok(new.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_patchToJson__1ab169b77b0df81a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ops: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("patchToJson").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(ops.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

#[allow(dead_code)]
fn def_patchToJson__1ab169b77b0df81a_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(Vec<__Adt_PatchOp_ff4bb1258a8bfbc>, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |ops: Vec<__Adt_PatchOp_ff4bb1258a8bfbc>, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let ops = Value::List(Arc::new(ops.clone().into_iter().map(|e| match &e { __Adt_PatchOp_ff4bb1258a8bfbc::Replace(a0, a1) => Value::Constructor { name: "Replace".to_string(), args: vec![Value::Text(a0.clone()), Value::Text(a1.clone())] }, __Adt_PatchOp_ff4bb1258a8bfbc::SetText(a0, a1) => Value::Constructor { name: "SetText".to_string(), args: vec![Value::Text(a0.clone()), Value::Text(a1.clone())] }, __Adt_PatchOp_ff4bb1258a8bfbc::SetAttr(a0, a1, a2) => Value::Constructor { name: "SetAttr".to_string(), args: vec![Value::Text(a0.clone()), Value::Text(a1.clone()), Value::Text(a2.clone())] }, __Adt_PatchOp_ff4bb1258a8bfbc::RemoveAttr(a0, a1) => Value::Constructor { name: "RemoveAttr".to_string(), args: vec![Value::Text(a0.clone()), Value::Text(a1.clone())] } }).collect()));
            ({
                let f = ((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("patchToJson").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(ops.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_ui_patchToJson__135d54db1a14e69d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |ops: Value, rt: &mut Runtime| {
        {
            let f = ((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("patchToJson").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(ops.clone()))?);
            rt.call(f, __aivi_call_args)
        }
    }) })))
}

fn def_serveHttp__abe2546b663ceb64(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |app: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |req: Value, rt: &mut Runtime| {
            let app = app.clone();
            {
                let f = (((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("ServerHtml").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("serveHttp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(app.clone()))?);
                __aivi_call_args.push((aivi_ok(req.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_ui_ServerHtml_serveHttp__2d95bab53e745adf(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |app: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |req: Value, rt: &mut Runtime| {
            let app = app.clone();
            {
                let f = (((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("ServerHtml").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("serveHttp").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(app.clone()))?);
                __aivi_call_args.push((aivi_ok(req.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_serveWs__3451db949f48405e(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |app: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
            let app = app.clone();
            {
                let f = (((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("ServerHtml").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("serveWs").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(app.clone()))?);
                __aivi_call_args.push((aivi_ok(socket.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_ui_ServerHtml_serveWs__b282436cf5e3ec01(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |app: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
            let app = app.clone();
            {
                let f = (((aivi_ok(__builtin("ui"))).and_then(|b| match b { Value::Record(map) => map.get("ServerHtml").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })).and_then(|b| match b { Value::Record(map) => map.get("serveWs").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(app.clone()))?);
                __aivi_call_args.push((aivi_ok(socket.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_trimTrailingSlashes__6b8d685f75171cd6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        ((aivi_ok(path.clone())).and_then(|a| (aivi_ok(Value::Text("/".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/".to_string())), Value::Bool(false) => ({
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("endsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
            __aivi_call_args.push((aivi_ok(path.clone()))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|c| match c { Value::Bool(true) => {
            let f = (def_trimTrailingSlashes__6b8d685f75171cd6(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                __aivi_call_args.push((({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("length").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                __aivi_call_args.push((aivi_ok(path.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }, Value::Bool(false) => aivi_ok(path.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

#[allow(dead_code)]
fn def_trimTrailingSlashes__6b8d685f75171cd6_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |path: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok(if (path.clone() == "/".to_string()) { "/".to_string() } else { if (match ({
            let path = Value::Text(path.clone());
            ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("endsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(path.clone()))?);
                rt.call(f, __aivi_call_args)
            })?
        }) { Value::Bool(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))) })? { (def_trimTrailingSlashes__6b8d685f75171cd6_typed(rt)?)((match ({
                let path = Value::Text(path.clone());
                ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                    __aivi_call_args.push((({
                        let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("length").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push((aivi_ok(path.clone()))?);
                        rt.call(f, __aivi_call_args)
                    }).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?
            }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?, rt)? } else { path.clone() } })
        })
    })
}

fn def_aivi_ui_ServerHtml_trimTrailingSlashes__9293e63f5f0d2669(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        ((aivi_ok(path.clone())).and_then(|a| (aivi_ok(Value::Text("/".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/".to_string())), Value::Bool(false) => ({
            let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("endsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
            __aivi_call_args.push((aivi_ok(path.clone()))?);
            rt.call(f, __aivi_call_args)
        }).and_then(|c| match c { Value::Bool(true) => {
            let f = (def_trimTrailingSlashes__6b8d685f75171cd6(rt))?;
            let mut __aivi_call_args: Vec<Value> = Vec::new();
            __aivi_call_args.push(({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("slice").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Int(0)))?);
                __aivi_call_args.push((({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("length").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|l| (aivi_ok(Value::Int(1))).and_then(|r| match (l, r) {
        (Value::Int(a), Value::Int(b)) => aivi_ok(Value::Int(a - b)),
        (Value::Float(a), Value::Float(b)) => aivi_ok(Value::Float(a - b)),
        (Value::Int(a), Value::Float(b)) => aivi_ok(Value::Float((a as f64) - b)),
        (Value::Float(a), Value::Int(b)) => aivi_ok(Value::Float(a - (b as f64))),
        (l, r) => Err(RuntimeError::Message(format!("unsupported operands for -: {} and {}", aivi_native_runtime::format_value(&l), aivi_native_runtime::format_value(&r)))),
    })))?);
                __aivi_call_args.push((aivi_ok(path.clone()))?);
                rt.call(f, __aivi_call_args)
            })?);
            rt.call(f, __aivi_call_args)
        }, Value::Bool(false) => aivi_ok(path.clone()), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
    }) })))
}

fn def_normalizePath__46f15b918fec452b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |raw: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(raw.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("p", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let p = __b0.remove("p").expect("pattern binder");
            let __v = (((aivi_ok(p.clone())).and_then(|a| (aivi_ok(Value::Text("".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/".to_string())), Value::Bool(false) => ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("startsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(p.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|c| match c { Value::Bool(true) => aivi_ok(p.clone()), Value::Bool(false) => {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("/".to_string())))?]); out.extend(vec![(aivi_ok(p.clone()))?]); out }))))?);
                rt.call(f, __aivi_call_args)
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("p", v.clone()); true }
                    }

            })(&__v, &mut __b1);
            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let p = __b1.remove("p").expect("pattern binder");
            {
                let f = (def_trimTrailingSlashes__6b8d685f75171cd6(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(p.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }
    }) })))
}

#[allow(dead_code)]
fn def_normalizePath__46f15b918fec452b_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |raw: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let raw = Value::Text(raw.clone());
            ({
                let __v = ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(raw.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("p", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let p = __b0.remove("p").expect("pattern binder");
                let __v = (((aivi_ok(p.clone())).and_then(|a| (aivi_ok(Value::Text("".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/".to_string())), Value::Bool(false) => ({
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("startsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                    __aivi_call_args.push((aivi_ok(p.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|c| match c { Value::Bool(true) => aivi_ok(p.clone()), Value::Bool(false) => {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("/".to_string())))?]); out.extend(vec![(aivi_ok(p.clone()))?]); out }))))?);
                    rt.call(f, __aivi_call_args)
                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __b1: HashMap<&'static str, Value> = HashMap::new();
                let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("p", v.clone()); true }
                        }

                })(&__v, &mut __b1);
                if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let p = __b1.remove("p").expect("pattern binder");
                {
                    let f = (def_trimTrailingSlashes__6b8d685f75171cd6(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(p.clone()))?);
                    rt.call(f, __aivi_call_args)
                }
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_ui_ServerHtml_normalizePath__4cdcbb30856a4708(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |raw: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("trim").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(raw.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("p", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let p = __b0.remove("p").expect("pattern binder");
            let __v = (((aivi_ok(p.clone())).and_then(|a| (aivi_ok(Value::Text("".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/".to_string())), Value::Bool(false) => ({
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("startsWith").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::Text("/".to_string())))?);
                __aivi_call_args.push((aivi_ok(p.clone()))?);
                rt.call(f, __aivi_call_args)
            }).and_then(|c| match c { Value::Bool(true) => aivi_ok(p.clone()), Value::Bool(false) => {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(Value::Text("/".to_string())))?]); out.extend(vec![(aivi_ok(p.clone()))?]); out }))))?);
                rt.call(f, __aivi_call_args)
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }), other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), }))?;
            let mut __b1: HashMap<&'static str, Value> = HashMap::new();
            let __ok1 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("p", v.clone()); true }
                    }

            })(&__v, &mut __b1);
            if !__ok1 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let p = __b1.remove("p").expect("pattern binder");
            {
                let f = (def_trimTrailingSlashes__6b8d685f75171cd6(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(p.clone()))?);
                rt.call(f, __aivi_call_args)
            }
        }
    }) })))
}

fn def_wsPathFor__6e4c3c55ff784307(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routePath: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_normalizePath__46f15b918fec452b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(routePath.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("p", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let p = __b0.remove("p").expect("pattern binder");
            ((aivi_ok(p.clone())).and_then(|a| (aivi_ok(Value::Text("/".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/ws".to_string())), Value::Bool(false) => {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(p.clone()))?]); out.extend(vec![(aivi_ok(Value::Text("/ws".to_string())))?]); out }))))?);
                rt.call(f, __aivi_call_args)
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

#[allow(dead_code)]
fn def_wsPathFor__6e4c3c55ff784307_typed(rt: &mut Runtime) -> Result<Box<dyn Fn(String, &mut aivi_native_runtime::Runtime) -> Result<String, RuntimeError>>, RuntimeError> {
    Ok({
        Box::new(move |routePath: String, rt: &mut aivi_native_runtime::Runtime| -> Result<String, RuntimeError> {
            Ok((match ({
            let routePath = Value::Text(routePath.clone());
            ({
                let __v = ({
                    let f = (def_normalizePath__46f15b918fec452b(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(routePath.clone()))?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("p", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let p = __b0.remove("p").expect("pattern binder");
                ((aivi_ok(p.clone())).and_then(|a| (aivi_ok(Value::Text("/".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/ws".to_string())), Value::Bool(false) => {
                    let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(p.clone()))?]); out.extend(vec![(aivi_ok(Value::Text("/ws".to_string())))?]); out }))))?);
                    rt.call(f, __aivi_call_args)
                }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
            })?
        }) { Value::Text(v) => Ok(v), other => Err(RuntimeError::Message(format!("expected Text, got {}", aivi_native_runtime::format_value(&other)))) })?)
        })
    })
}

fn def_aivi_ui_ServerHtml_wsPathFor__cfb37a2488fb6bf0(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routePath: Value, rt: &mut Runtime| {
        {
            let __v = ({
                let f = (def_normalizePath__46f15b918fec452b(rt))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(routePath.clone()))?);
                rt.call(f, __aivi_call_args)
            })?;
            let mut __b0: HashMap<&'static str, Value> = HashMap::new();
            let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                    {
                        use Value::*;
                        { b.insert("p", v.clone()); true }
                    }

            })(&__v, &mut __b0);
            if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
            let p = __b0.remove("p").expect("pattern binder");
            ((aivi_ok(p.clone())).and_then(|a| (aivi_ok(Value::Text("/".to_string()))).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => aivi_ok(Value::Text("/ws".to_string())), Value::Bool(false) => {
                let f = ((aivi_ok(__builtin("text"))).and_then(|b| match b { Value::Record(map) => map.get("concat").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(Value::List(Arc::new({ let mut out = Vec::new(); out.extend(vec![(aivi_ok(p.clone()))?]); out.extend(vec![(aivi_ok(Value::Text("/ws".to_string())))?]); out }))))?);
                rt.call(f, __aivi_call_args)
            }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), })
        }
    }) })))
}

fn def_findAppForHttpPath__b8686a14273b1fab(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routes: Value, rt: &mut Runtime| {
            let path = path.clone();
            (aivi_ok(routes.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("r", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let r = __b.remove("r").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (({
                            let f = (def_normalizePath__46f15b918fec452b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(r.clone())).and_then(|b| match b { Value::Record(map) => map.get("path").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|a| (aivi_ok(path.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                            let f = (aivi_ok(__builtin("Some")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(r.clone())).and_then(|b| match b { Value::Record(map) => map.get("app").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => {
                            let f = (def_findAppForHttpPath__b8686a14273b1fab(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(path.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_ui_ServerHtml_findAppForHttpPath__02c7777fd6690f0a(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routes: Value, rt: &mut Runtime| {
            let path = path.clone();
            (aivi_ok(routes.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("r", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let r = __b.remove("r").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (({
                            let f = (def_normalizePath__46f15b918fec452b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(r.clone())).and_then(|b| match b { Value::Record(map) => map.get("path").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|a| (aivi_ok(path.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                            let f = (aivi_ok(__builtin("Some")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(r.clone())).and_then(|b| match b { Value::Record(map) => map.get("app").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => {
                            let f = (def_findAppForHttpPath__b8686a14273b1fab(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(path.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_findAppForWsPath__2b6a4042afbb799d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routes: Value, rt: &mut Runtime| {
            let path = path.clone();
            (aivi_ok(routes.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("r", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let r = __b.remove("r").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (({
                            let f = (def_wsPathFor__6e4c3c55ff784307(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(r.clone())).and_then(|b| match b { Value::Record(map) => map.get("path").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|a| (aivi_ok(path.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                            let f = (aivi_ok(__builtin("Some")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(r.clone())).and_then(|b| match b { Value::Record(map) => map.get("app").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => {
                            let f = (def_findAppForWsPath__2b6a4042afbb799d(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(path.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_aivi_ui_ServerHtml_findAppForWsPath__5b0c65b9c02e77a4(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |path: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routes: Value, rt: &mut Runtime| {
            let path = path.clone();
            (aivi_ok(routes.clone())).and_then(|__scrut| {
                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 0 { return false; }
                            items.len() == 0
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_0(&__scrut, &mut __b) {
                        return aivi_ok(__builtin("None"));
                    }
                }

                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                    {
                        use Value::*;
                        match v { Value::List(items) => {
                            let items = items.as_ref();
                            if items.len() < 1 { return false; }
                            let v0 = &items[0];
                            if !({ b.insert("r", v0.clone()); true }) { return false; }
                            let tail = Value::List(Arc::new(items[1..].to_vec()));
                            { b.insert("rest", (&tail).clone()); true }
                        }, _ => false }
                    }
                }

                {
                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                    if __match_arm_1(&__scrut, &mut __b) {
                        let r = __b.remove("r").expect("pattern binder");
                        let rest = __b.remove("rest").expect("pattern binder");
                        return (({
                            let f = (def_wsPathFor__6e4c3c55ff784307(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(r.clone())).and_then(|b| match b { Value::Record(map) => map.get("path").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            rt.call(f, __aivi_call_args)
                        }).and_then(|a| (aivi_ok(path.clone())).map(|b| Value::Bool(aivi_native_runtime::values_equal(&a, &b))))).and_then(|c| match c { Value::Bool(true) => {
                            let f = (aivi_ok(__builtin("Some")))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push(((aivi_ok(r.clone())).and_then(|b| match b { Value::Record(map) => map.get("app").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                            rt.call(f, __aivi_call_args)
                        }, Value::Bool(false) => {
                            let f = (def_findAppForWsPath__2b6a4042afbb799d(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(path.clone()))?);
                            __aivi_call_args.push((aivi_ok(rest.clone()))?);
                            rt.call(f, __aivi_call_args)
                        }, other => Err(RuntimeError::Message(format!("expected Bool, got {}", aivi_native_runtime::format_value(&other)))), });
                    }
                }

                Err(RuntimeError::Message("non-exhaustive match".to_string()))
            })
        }) })))
    }) })))
}

fn def_notFound__2e091e04ea38be06(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("status".to_string(), (aivi_ok(Value::Int(404)))?);
        map.insert("headers".to_string(), (aivi_ok(Value::List(Arc::new(vec![({
        let mut map = HashMap::new();
        map.insert("name".to_string(), (aivi_ok(Value::Text("content-type".to_string())))?);
        map.insert("value".to_string(), (aivi_ok(Value::Text("text/plain; charset=utf-8".to_string())))?);
        aivi_ok(Value::Record(Arc::new(map)))
    })?]))))?);
        map.insert("body".to_string(), (aivi_ok(Value::List(Arc::new(Vec::new()))))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_aivi_ui_ServerHtml_notFound__d763392b9fd4ff8f(rt: &mut Runtime) -> R {
    {
        let mut map = HashMap::new();
        map.insert("status".to_string(), (aivi_ok(Value::Int(404)))?);
        map.insert("headers".to_string(), (aivi_ok(Value::List(Arc::new(vec![({
        let mut map = HashMap::new();
        map.insert("name".to_string(), (aivi_ok(Value::Text("content-type".to_string())))?);
        map.insert("value".to_string(), (aivi_ok(Value::Text("text/plain; charset=utf-8".to_string())))?);
        aivi_ok(Value::Record(Arc::new(map)))
    })?]))))?);
        map.insert("body".to_string(), (aivi_ok(Value::List(Arc::new(Vec::new()))))?);
        aivi_ok(Value::Record(Arc::new(map)))
    }
}

fn def_dispatch__4592850c14d1d82b(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |req: Value, rt: &mut Runtime| {
            let routes = routes.clone();
            {
                let __v = ({
                    let f = (def_normalizePath__46f15b918fec452b(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(req.clone())).and_then(|b| match b { Value::Record(map) => map.get("path").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("path", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let path = __b0.remove("path").expect("pattern binder");
                ({
                    let f = (def_findAppForHttpPath__b8686a14273b1fab(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    __aivi_call_args.push((aivi_ok(routes.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("app", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            let app = __b.remove("app").expect("pattern binder");
                            return {
                                let f = (aivi_ok(Value::Constructor { name: "Http".to_string(), args: Vec::new() }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = (def_serveHttp__abe2546b663ceb64(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(app.clone()))?);
                                    __aivi_call_args.push((aivi_ok(req.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return ({
                                let f = (def_findAppForWsPath__2b6a4042afbb799d(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(path.clone()))?);
                                __aivi_call_args.push((aivi_ok(routes.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }).and_then(|__scrut| {
                                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                            let v0 = &args[0];
                                            if !({ b.insert("app", v0.clone()); true }) { return false; }
                                            true
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_0(&__scrut, &mut __b) {
                                        let app = __b.remove("app").expect("pattern binder");
                                        return {
                                            let f = (aivi_ok(Value::Constructor { name: "Ws".to_string(), args: Vec::new() }))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
                                                let app = app.clone();
                                                {
                                                    let f = (def_serveWs__3451db949f48405e(rt))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(app.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(socket.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                }
                                            }) }))))?);
                                            rt.call(f, __aivi_call_args)
                                        };
                                    }
                                }

                                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                            true
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_1(&__scrut, &mut __b) {
                                        return {
                                            let f = (aivi_ok(Value::Constructor { name: "Http".to_string(), args: Vec::new() }))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((def_notFound__2e091e04ea38be06(rt))?);
                                            rt.call(f, __aivi_call_args)
                                        };
                                    }
                                }

                                Err(RuntimeError::Message("non-exhaustive match".to_string()))
                            });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }
        }) })))
    }) })))
}

fn def_aivi_ui_ServerHtml_dispatch__44832d5054c86de6(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routes: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |req: Value, rt: &mut Runtime| {
            let routes = routes.clone();
            {
                let __v = ({
                    let f = (def_normalizePath__46f15b918fec452b(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push(((aivi_ok(req.clone())).and_then(|b| match b { Value::Record(map) => map.get("path").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?);
                    rt.call(f, __aivi_call_args)
                })?;
                let mut __b0: HashMap<&'static str, Value> = HashMap::new();
                let __ok0 = (|v: &Value, b: &mut HashMap<&'static str, Value>| -> bool {
                        {
                            use Value::*;
                            { b.insert("path", v.clone()); true }
                        }

                })(&__v, &mut __b0);
                if !__ok0 { return Err(RuntimeError::Message("pattern match failed".to_string())); }
                let path = __b0.remove("path").expect("pattern binder");
                ({
                    let f = (def_findAppForHttpPath__b8686a14273b1fab(rt))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(path.clone()))?);
                    __aivi_call_args.push((aivi_ok(routes.clone()))?);
                    rt.call(f, __aivi_call_args)
                }).and_then(|__scrut| {
                    fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                let v0 = &args[0];
                                if !({ b.insert("app", v0.clone()); true }) { return false; }
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_0(&__scrut, &mut __b) {
                            let app = __b.remove("app").expect("pattern binder");
                            return {
                                let f = (aivi_ok(Value::Constructor { name: "Http".to_string(), args: Vec::new() }))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push(({
                                    let f = (def_serveHttp__abe2546b663ceb64(rt))?;
                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                    __aivi_call_args.push((aivi_ok(app.clone()))?);
                                    __aivi_call_args.push((aivi_ok(req.clone()))?);
                                    rt.call(f, __aivi_call_args)
                                })?);
                                rt.call(f, __aivi_call_args)
                            };
                        }
                    }

                    fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                        {
                            use Value::*;
                            match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                true
                            }, _ => false }
                        }
                    }

                    {
                        let mut __b: HashMap<&'static str, Value> = HashMap::new();
                        if __match_arm_1(&__scrut, &mut __b) {
                            return ({
                                let f = (def_findAppForWsPath__2b6a4042afbb799d(rt))?;
                                let mut __aivi_call_args: Vec<Value> = Vec::new();
                                __aivi_call_args.push((aivi_ok(path.clone()))?);
                                __aivi_call_args.push((aivi_ok(routes.clone()))?);
                                rt.call(f, __aivi_call_args)
                            }).and_then(|__scrut| {
                                fn __match_arm_0(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::Constructor { name, args } if name == "Some" && args.len() == 1 => {
                                            let v0 = &args[0];
                                            if !({ b.insert("app", v0.clone()); true }) { return false; }
                                            true
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_0(&__scrut, &mut __b) {
                                        let app = __b.remove("app").expect("pattern binder");
                                        return {
                                            let f = (aivi_ok(Value::Constructor { name: "Ws".to_string(), args: Vec::new() }))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |socket: Value, rt: &mut Runtime| {
                                                let app = app.clone();
                                                {
                                                    let f = (def_serveWs__3451db949f48405e(rt))?;
                                                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                                                    __aivi_call_args.push((aivi_ok(app.clone()))?);
                                                    __aivi_call_args.push((aivi_ok(socket.clone()))?);
                                                    rt.call(f, __aivi_call_args)
                                                }
                                            }) }))))?);
                                            rt.call(f, __aivi_call_args)
                                        };
                                    }
                                }

                                fn __match_arm_1(v: &Value, b: &mut HashMap<&'static str, Value>) -> bool {
                                    {
                                        use Value::*;
                                        match v { Value::Constructor { name, args } if name == "None" && args.len() == 0 => {
                                            true
                                        }, _ => false }
                                    }
                                }

                                {
                                    let mut __b: HashMap<&'static str, Value> = HashMap::new();
                                    if __match_arm_1(&__scrut, &mut __b) {
                                        return {
                                            let f = (aivi_ok(Value::Constructor { name: "Http".to_string(), args: Vec::new() }))?;
                                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                                            __aivi_call_args.push((def_notFound__2e091e04ea38be06(rt))?);
                                            rt.call(f, __aivi_call_args)
                                        };
                                    }
                                }

                                Err(RuntimeError::Message("non-exhaustive match".to_string()))
                            });
                        }
                    }

                    Err(RuntimeError::Message("non-exhaustive match".to_string()))
                })
            }
        }) })))
    }) })))
}

fn def_serve__21e065308be24894(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |config: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routes: Value, rt: &mut Runtime| {
            let config = config.clone();
            {
                let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("listen").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(config.clone()))?);
                __aivi_call_args.push((aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |req: Value, rt: &mut Runtime| {
                    let routes = routes.clone();
                    {
                        let f = (aivi_ok(__builtin("pure")))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_dispatch__4592850c14d1d82b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(routes.clone()))?);
                            __aivi_call_args.push((aivi_ok(req.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    }
                }) }))))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_ui_ServerHtml_serve__4b334404ccf54e8f(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |config: Value, rt: &mut Runtime| {
        aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |routes: Value, rt: &mut Runtime| {
            let config = config.clone();
            {
                let f = ((aivi_ok(__builtin("httpServer"))).and_then(|b| match b { Value::Record(map) => map.get("listen").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
                let mut __aivi_call_args: Vec<Value> = Vec::new();
                __aivi_call_args.push((aivi_ok(config.clone()))?);
                __aivi_call_args.push((aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |req: Value, rt: &mut Runtime| {
                    let routes = routes.clone();
                    {
                        let f = (aivi_ok(__builtin("pure")))?;
                        let mut __aivi_call_args: Vec<Value> = Vec::new();
                        __aivi_call_args.push(({
                            let f = (def_dispatch__4592850c14d1d82b(rt))?;
                            let mut __aivi_call_args: Vec<Value> = Vec::new();
                            __aivi_call_args.push((aivi_ok(routes.clone()))?);
                            __aivi_call_args.push((aivi_ok(req.clone()))?);
                            rt.call(f, __aivi_call_args)
                        })?);
                        rt.call(f, __aivi_call_args)
                    }
                }) }))))?);
                rt.call(f, __aivi_call_args)
            }
        }) })))
    }) })))
}

fn def_aivi_mutableMap_create__3d3c4558a36c8582(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("create").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_empty__a910c3c6b10eac2b(rt: &mut Runtime) -> R {
    {
        let f = ((aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("empty").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), }))?;
        let mut __aivi_call_args: Vec<Value> = Vec::new();
        __aivi_call_args.push((aivi_ok(__builtin("Unit")))?);
        rt.call(f, __aivi_call_args)
    }
}

fn def_aivi_mutableMap_get__13fe5914830f5aa2(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("get").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_getOrElse__2a3b9cab92b2f8fb(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_getOrElse__a48a2518f185931e(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("getOrElse").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_insert__7271c68759916228(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_insert__0a9476374d892617(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("insert").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_remove__efd76f8f026c83c2(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("remove").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_has__335813192fef9543(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_has__83b96914c218ea06(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("has").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_size__1e171d8132a244e7(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("size").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_freeze__6e87e68aa786ea42(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("freeze").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_freeze__b95a042dfd30cccd(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("freeze").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_keys__581987d75cbd3e2d(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("keys").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_keys__6d03473fd00db50a(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("keys").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_values__21277bcf1a4d67fb(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("values").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_values__e2dd9d6691e472bc(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("values").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_modify__dbb7b63327a2f8c3(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("modify").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_aivi_mutableMap_modify__a7462823605b3cec(rt: &mut Runtime) -> R {
    (aivi_ok(__builtin("MutableMap"))).and_then(|b| match b { Value::Record(map) => map.get("modify").cloned().ok_or_else(|| RuntimeError::Message("missing field".to_string())), other => Err(RuntimeError::Message(format!("expected Record, got {}", aivi_native_runtime::format_value(&other)))), })
}

fn def_identity__e90f184c6aa3ffbb(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(x.clone())
    }) })))
}

fn def_app_main_identity__c487e4380c87865d(rt: &mut Runtime) -> R {
    aivi_ok(Value::Closure(Arc::new(aivi_native_runtime::ClosureValue { func: Arc::new(move |x: Value, rt: &mut Runtime| {
        aivi_ok(x.clone())
    }) })))
}

fn def_main__1f5962a2ce9803c8(rt: &mut Runtime) -> R {
    aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
        func: Arc::new(move |rt: &mut Runtime| {
            let mut __cleanups: Vec<Value> = Vec::new();
            let __result: R = {
                    let __e = ({
                    let f = (aivi_ok(__builtin("println")))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(Value::Text("done".to_string())))?);
                    rt.call(f, __aivi_call_args)
                })?;
                    rt.run_effect_value(__e)
            };
            let __cleanup_result: Result<(), RuntimeError> = (|| {
                    for cleanup in __cleanups.into_iter().rev() {
                        let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                    }
                    Ok(())
            })();
            match (__result, __cleanup_result) {
                    (Err(err), _) => Err(err),
                    (Ok(_), Err(err)) => Err(err),
                    (Ok(v), Ok(())) => Ok(v),
            }
        }),
    })))
}

fn def_app_main_main__e7e51e602520a022(rt: &mut Runtime) -> R {
    aivi_ok(Value::Effect(Arc::new(EffectValue::Thunk {
        func: Arc::new(move |rt: &mut Runtime| {
            let mut __cleanups: Vec<Value> = Vec::new();
            let __result: R = {
                    let __e = ({
                    let f = (aivi_ok(__builtin("println")))?;
                    let mut __aivi_call_args: Vec<Value> = Vec::new();
                    __aivi_call_args.push((aivi_ok(Value::Text("done".to_string())))?);
                    rt.call(f, __aivi_call_args)
                })?;
                    rt.run_effect_value(__e)
            };
            let __cleanup_result: Result<(), RuntimeError> = (|| {
                    for cleanup in __cleanups.into_iter().rev() {
                        let _ = rt.uncancelable(|rt| rt.run_effect_value(cleanup));
                    }
                    Ok(())
            })();
            match (__result, __cleanup_result) {
                    (Err(err), _) => Err(err),
                    (Ok(_), Err(err)) => Err(err),
                    (Ok(v), Ok(())) => Ok(v),
            }
        }),
    })))
}

fn main() {
    let mut rt = Runtime::new();
    let result: Result<(), RuntimeError> = (|| {
        let v = def_main__1f5962a2ce9803c8(&mut rt)?;
        let _ = rt.run_effect_value(v)?;
        Ok(())
    })();
    match result {
        Ok(_) => {}
        Err(err) => {
            eprintln!("{err}");
            std::process::exit(1);
        }
    }
}
